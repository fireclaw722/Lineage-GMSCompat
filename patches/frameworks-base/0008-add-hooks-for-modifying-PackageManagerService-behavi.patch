From d17dc289a5fc7a3158116c8aa053a41d6782091a Mon Sep 17 00:00:00 2001
From: Dmitry Muhomor <muhomor.dmitry@gmail.com>
Date: Mon, 27 Mar 2023 16:00:00 +0300
Subject: [PATCH 08/44] add hooks for modifying PackageManagerService behavior

13: 4e3e8c230773761183e97444020dbeb877131450
---
 .../server/ext/PackageManagerHooks.java       | 59 +++++++++++++++++++
 .../com/android/server/pm/AppsFilterBase.java |  7 +++
 .../java/com/android/server/pm/Settings.java  |  8 ++-
 .../PermissionManagerServiceImpl.java         |  8 +++
 4 files changed, 80 insertions(+), 2 deletions(-)
 create mode 100644 services/core/java/com/android/server/ext/PackageManagerHooks.java

diff --git a/services/core/java/com/android/server/ext/PackageManagerHooks.java b/services/core/java/com/android/server/ext/PackageManagerHooks.java
new file mode 100644
index 000000000000..cb5038687b6f
--- /dev/null
+++ b/services/core/java/com/android/server/ext/PackageManagerHooks.java
@@ -0,0 +1,59 @@
+package com.android.server.ext;
+
+import android.Manifest;
+import android.annotation.Nullable;
+import android.annotation.UserIdInt;
+import android.content.pm.PackageManagerInternal;
+import android.util.ArraySet;
+
+import com.android.server.pm.pkg.PackageStateInternal;
+import com.android.server.pm.pkg.parsing.ParsingPackage;
+
+public class PackageManagerHooks {
+
+    // Called when package enabled setting for a system package is deserialized from storage
+    @Nullable
+    public static Integer maybeOverrideSystemPackageEnabledSetting(String pkgName, @UserIdInt int userId) {
+        switch (pkgName) {
+            default:
+                return null;
+        }
+    }
+
+    public static boolean shouldBlockGrantRuntimePermission(
+            PackageManagerInternal pm, String permName, String packageName, int userId)
+    {
+        return false;
+    }
+
+    // Called when AppsFilter decides whether to restrict package visibility
+    public static boolean shouldFilterApplication(
+            @Nullable PackageStateInternal callingPkgSetting,
+            ArraySet<PackageStateInternal> callingSharedPkgSettings,
+            int callingUserId,
+            PackageStateInternal targetPkgSetting, int targetUserId
+    ) {
+        if (callingPkgSetting != null && restrictedVisibilityPackages.contains(callingPkgSetting.getPackageName())) {
+            if (!targetPkgSetting.isSystem()) {
+                return true;
+            }
+        }
+
+        if (restrictedVisibilityPackages.contains(targetPkgSetting.getPackageName())) {
+            if (callingPkgSetting != null) {
+                return !callingPkgSetting.isSystem();
+            } else {
+                for (int i = callingSharedPkgSettings.size() - 1; i >= 0; i--) {
+                    if (!callingSharedPkgSettings.valueAt(i).isSystem()) {
+                        return true;
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    // Packages in this array are restricted from interacting with and being interacted by non-system apps
+    private static final ArraySet<String> restrictedVisibilityPackages = new ArraySet<>(new String[] {
+    });
+}
diff --git a/services/core/java/com/android/server/pm/AppsFilterBase.java b/services/core/java/com/android/server/pm/AppsFilterBase.java
index a5bc2c36a5a8..ec471552b828 100644
--- a/services/core/java/com/android/server/pm/AppsFilterBase.java
+++ b/services/core/java/com/android/server/pm/AppsFilterBase.java
@@ -38,6 +38,7 @@ import android.util.SparseArray;
 
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.util.function.QuadFunction;
+import com.android.server.ext.PackageManagerHooks;
 import com.android.server.om.OverlayReferenceMapper;
 import com.android.server.pm.pkg.AndroidPackage;
 import com.android.server.pm.pkg.PackageStateInternal;
@@ -445,6 +446,12 @@ public abstract class AppsFilterBase implements AppsFilterSnapshot {
                 Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
             }
 
+            if (PackageManagerHooks.shouldFilterApplication(callingPkgSetting, callingSharedPkgSettings,
+                    UserHandle.getUserId(callingUid),
+                    targetPkgSetting, targetUserId)) {
+                return true;
+            }
+
             if (callingPkgSetting != null) {
                 if (callingPkgSetting.getPkg() != null
                         && !mFeatureConfig.packageIsEnabled(callingPkgSetting.getPkg())) {
diff --git a/services/core/java/com/android/server/pm/Settings.java b/services/core/java/com/android/server/pm/Settings.java
index b097b52cd759..25b0a7e95ece 100644
--- a/services/core/java/com/android/server/pm/Settings.java
+++ b/services/core/java/com/android/server/pm/Settings.java
@@ -106,6 +106,7 @@ import com.android.permission.persistence.RuntimePermissionsPersistence;
 import com.android.permission.persistence.RuntimePermissionsState;
 import com.android.server.LocalServices;
 import com.android.server.backup.PreferredActivityBackupHelper;
+import com.android.server.ext.PackageManagerHooks;
 import com.android.server.pm.Installer.InstallerException;
 import com.android.server.pm.parsing.PackageInfoUtils;
 import com.android.server.pm.permission.LegacyPermissionDataProvider;
@@ -1927,8 +1928,11 @@ public final class Settings implements Watchable, Snappable, ResilientAtomicFile
                                 parser.getAttributeBoolean(null, ATTR_INSTANT_APP, false);
                         final boolean virtualPreload =
                                 parser.getAttributeBoolean(null, ATTR_VIRTUAL_PRELOAD, false);
-                        final int enabled = parser.getAttributeInt(null, ATTR_ENABLED,
-                                COMPONENT_ENABLED_STATE_DEFAULT);
+                        final Integer enabledOverride = ps.isSystem() ?
+                                PackageManagerHooks.maybeOverrideSystemPackageEnabledSetting(name, userId) : null;
+                        final int enabled = (enabledOverride != null) ?
+                                enabledOverride.intValue() :
+                                parser.getAttributeInt(null, ATTR_ENABLED, COMPONENT_ENABLED_STATE_DEFAULT);
                         final String enabledCaller = parser.getAttributeValue(null,
                                 ATTR_ENABLED_CALLER);
                         final String harmfulAppWarning =
diff --git a/services/core/java/com/android/server/pm/permission/PermissionManagerServiceImpl.java b/services/core/java/com/android/server/pm/permission/PermissionManagerServiceImpl.java
index c7c83acaa785..bc0e3f009de0 100644
--- a/services/core/java/com/android/server/pm/permission/PermissionManagerServiceImpl.java
+++ b/services/core/java/com/android/server/pm/permission/PermissionManagerServiceImpl.java
@@ -135,6 +135,7 @@ import com.android.server.PermissionThread;
 import com.android.server.ServiceThread;
 import com.android.server.SystemConfig;
 import com.android.server.Watchdog;
+import com.android.server.ext.PackageManagerHooks;
 import com.android.server.pm.ApexManager;
 import com.android.server.pm.KnownPackages;
 import com.android.server.pm.PackageInstallerService;
@@ -1360,6 +1361,13 @@ public class PermissionManagerServiceImpl implements PermissionManagerServiceInt
             isRolePermission = permission.isRole();
             isSoftRestrictedPermission = permission.isSoftRestricted();
         }
+
+        if (PackageManagerHooks.shouldBlockGrantRuntimePermission(mPackageManagerInt, permName, packageName, userId)) {
+            // this method is called from within system_server and from critical system processes,
+            // do not throw an exception, just return
+            return;
+        }
+
         final boolean mayGrantRolePermission = isRolePermission
                 && mayManageRolePermission(callingUid);
         final boolean mayGrantSoftRestrictedPermission = isSoftRestrictedPermission
-- 
2.34.1

