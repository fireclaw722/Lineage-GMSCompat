From b51dab2f75057faeaa13978bc61db56e7425318c Mon Sep 17 00:00:00 2001
From: GrapheneOS <contact@grapheneos.org>
Date: Tue, 6 Jun 2023 14:44:05 +0300
Subject: [PATCH 26/44] gmscompat: add compatibility layer for unprivileged GMS

Originally authored by Danny Lin <danny@kdrag0n.dev> for inclusion in
GrapheneOS. It has since been substantially extended and partially
rewritten by Dmitry Muhomor <muhomor.dmitry@gmail.com> (primarily) and
Daniel Micay <danielmicay@gmail.com>.

Commit history:
(better viewed with git log --grep gmscompat $TAG_NAME)

November 2023 - March 2024:
https://github.com/GrapheneOS/platform_frameworks_base/commits/2024030300

August 2023 - November 2023:
https://github.com/GrapheneOS/platform_frameworks_base/commits/2023112900

May 2023 - August 2023:
https://github.com/GrapheneOS/platform_frameworks_base/commits/2023080800

February 2023 - May 2023:
https://github.com/GrapheneOS/platform_frameworks_base/commits/TQ2A.230505.002.2023052900

August 2022 - February 2023:
https://github.com/GrapheneOS/platform_frameworks_base/commits/TQ1A.230205.002.2023020600

June 2022 - August 2022:
https://github.com/GrapheneOS/platform_frameworks_base/commits/SP2A.220505.006.2022073000

October 2021 - June 2022:
https://github.com/GrapheneOS/platform_frameworks_base/commits/SP2A.220505.002.2022053100

July 2021 - October 2021:
https://github.com/GrapheneOS/platform_frameworks_base/commits/RQ3A.211001.001.2021100606

Change-Id: If49c145333fc62d1de47e1e8a2e6c8fbcd7eaefa
---
 .../java/android/app/AlarmManager.java        |  12 +
 .../android/os/PowerExemptionManager.java     |   8 +
 core/api/module-lib-current.txt               |  13 +
 core/api/system-current.txt                   |  16 +
 core/java/android/app/Activity.java           |  53 ++
 core/java/android/app/ActivityManager.java    |  17 +-
 core/java/android/app/ActivityThread.java     |  13 +
 .../java/android/app/ActivityThreadHooks.java |   4 +
 core/java/android/app/AppOpsManager.java      |  14 +
 core/java/android/app/Application.java        |   6 +
 .../android/app/ApplicationErrorReport.aidl   |   3 +-
 .../app/ApplicationPackageManager.java        |  17 +-
 core/java/android/app/BroadcastOptions.java   |   9 +
 core/java/android/app/ContextImpl.java        |  64 +-
 core/java/android/app/DownloadManager.java    |   8 +
 core/java/android/app/Instrumentation.java    |   9 +
 .../java/android/app/NotificationManager.java |  19 +
 core/java/android/app/PendingIntent.java      |  20 +
 core/java/android/app/Service.java            |  22 +
 .../android/app/SharedPreferencesImpl.java    |  17 +-
 .../android/app/SystemServiceRegistry.java    |   7 +
 core/java/android/app/WallpaperManager.java   |  11 +
 .../android/app/compat/gms/GmsCompat.java     | 316 ++++++++
 .../app/compat/gms/GmsModuleHooks.java        | 120 +++
 .../java/android/app/compat/gms/GmsUtils.java |  20 +
 .../app/usage/StorageStatsManager.java        |  10 +
 .../java/android/content/ContentResolver.java |  57 +-
 core/java/android/content/Intent.java         |  10 +
 .../content/pm/AppPermissionUtils.java        |   8 +
 .../android/content/pm/CrossProfileApps.java  |  13 +
 .../content/pm/IPackageInstallerSession.aidl  |   2 +
 .../android/content/pm/PackageInstaller.java  |  41 +
 .../android/content/pm/PackageManager.java    |   4 +
 core/java/android/content/res/ApkAssets.java  |  10 +-
 .../database/sqlite/SQLiteOpenHelper.java     |   7 +
 core/java/android/ext/AppInfoExt.java         |   2 +
 core/java/android/nfc/NfcAdapter.java         |  10 +
 core/java/android/os/Binder.java              |  35 +-
 core/java/android/os/BinderDef.aidl           |   3 +
 core/java/android/os/BinderDef.java           | 102 +++
 core/java/android/os/Build.java               |  13 +
 core/java/android/os/HybridBinder.java        |  85 ++
 core/java/android/os/Parcel.java              |  20 +
 core/java/android/os/UserHandle.java          |  10 +
 core/java/android/os/UserManager.java         |   4 +-
 core/java/android/provider/Settings.java      |  51 ++
 .../telephony/TelephonyRegistryManager.java   |  16 +
 .../internal/gmscompat/BinderGca2Gms.java     | 118 +++
 .../internal/gmscompat/GmcBinderDefs.java     | 111 +++
 .../gmscompat/GmcMediaProjectionService.java  |  85 ++
 .../internal/gmscompat/GmsCompatApp.java      | 298 +++++++
 .../internal/gmscompat/GmsCompatConfig.aidl   |   3 +
 .../internal/gmscompat/GmsCompatConfig.java   | 238 ++++++
 .../internal/gmscompat/GmsCoreConst.java      |   6 +
 .../android/internal/gmscompat/GmsHooks.java  | 752 ++++++++++++++++++
 .../android/internal/gmscompat/GmsInfo.java   |  34 +
 .../gmscompat/IClientOfGmsCore2Gca.aidl       |  14 +
 .../android/internal/gmscompat/IGca2Gms.aidl  |  16 +
 .../android/internal/gmscompat/IGms2Gca.aidl  |  46 ++
 .../internal/gmscompat/PlayStoreHooks.java    | 340 ++++++++
 .../android/internal/gmscompat/StubDef.java   | 293 +++++++
 .../client/ClientPriorityManager.java         | 121 +++
 .../client/GmsCompatClientService.java        |  41 +
 .../dynamite/GmsDynamiteClientHooks.java      | 203 +++++
 .../dynamite/server/FileProxyService.java     |  99 +++
 .../dynamite/server/IFileProxyService.aidl    |   5 +
 .../internal/gmscompat/flags/GmsFlag.java     | 300 +++++++
 .../gcarriersettings/GCarrierSettingsApp.java |  83 ++
 .../ICarrierConfigsLoader.aidl                |   8 +
 .../TestCarrierConfigService.java             | 160 ++++
 .../sysservice/GmcPackageManager.java         | 603 ++++++++++++++
 .../sysservice/GmcTelephonyManager.java       | 152 ++++
 .../gmscompat/sysservice/GmcUserManager.java  | 190 +++++
 .../gmscompat/util/CursorWrapperExt.java      |  67 ++
 .../gmscompat/util/GmcActivityUtils.java      | 142 ++++
 .../pm/pkg/parsing/ParsingPackageUtils.java   |   5 +
 core/res/AndroidManifest.xml                  |   2 +-
 .../android/location/LocationManager.java     |  25 +
 media/java/android/media/AudioManager.java    |  12 +
 media/java/android/media/AudioRecord.java     |  38 +
 .../media/audiopolicy/AudioPolicy.java        |  14 +
 .../media/projection/MediaProjection.java     |  14 +
 .../server/am/ActivityManagerService.java     |   5 +
 .../com/android/server/pm/AppsFilterImpl.java |   5 +
 .../server/pm/PackageInstallerSession.java    |  53 ++
 .../server/pm/PackageManagerService.java      |   3 +-
 .../android/server/pm/SilentUpdatePolicy.java |  15 +
 .../server/pm/ext/GCarrierSettingsHooks.java  |  37 +
 .../pm/ext/GmsCompatPkgParsingHooks.java      |  62 ++
 .../android/server/pm/ext/GmsCoreHooks.java   |  38 +
 .../server/pm/ext/GsfParsingHooks.java        |  32 +
 .../android/server/pm/ext/PackageExtInit.java |   3 +
 .../server/pm/ext/PackageHooksRegistry.java   |   6 +
 .../android/server/pm/ext/PlayStoreHooks.java |  24 +
 .../DefaultPermissionGrantPolicy.java         |   2 +
 .../android/server/wm/ActivityStarter.java    |   7 +
 .../telephony/SubscriptionManager.java        |  15 +
 .../android/telephony/TelephonyManager.java   |  27 +
 98 files changed, 6288 insertions(+), 15 deletions(-)
 create mode 100644 core/java/android/app/compat/gms/GmsCompat.java
 create mode 100644 core/java/android/app/compat/gms/GmsModuleHooks.java
 create mode 100644 core/java/android/app/compat/gms/GmsUtils.java
 create mode 100644 core/java/android/os/BinderDef.aidl
 create mode 100644 core/java/android/os/BinderDef.java
 create mode 100644 core/java/android/os/HybridBinder.java
 create mode 100644 core/java/com/android/internal/gmscompat/BinderGca2Gms.java
 create mode 100644 core/java/com/android/internal/gmscompat/GmcBinderDefs.java
 create mode 100644 core/java/com/android/internal/gmscompat/GmcMediaProjectionService.java
 create mode 100644 core/java/com/android/internal/gmscompat/GmsCompatApp.java
 create mode 100644 core/java/com/android/internal/gmscompat/GmsCompatConfig.aidl
 create mode 100644 core/java/com/android/internal/gmscompat/GmsCompatConfig.java
 create mode 100644 core/java/com/android/internal/gmscompat/GmsCoreConst.java
 create mode 100644 core/java/com/android/internal/gmscompat/GmsHooks.java
 create mode 100644 core/java/com/android/internal/gmscompat/GmsInfo.java
 create mode 100644 core/java/com/android/internal/gmscompat/IClientOfGmsCore2Gca.aidl
 create mode 100644 core/java/com/android/internal/gmscompat/IGca2Gms.aidl
 create mode 100644 core/java/com/android/internal/gmscompat/IGms2Gca.aidl
 create mode 100644 core/java/com/android/internal/gmscompat/PlayStoreHooks.java
 create mode 100644 core/java/com/android/internal/gmscompat/StubDef.java
 create mode 100644 core/java/com/android/internal/gmscompat/client/ClientPriorityManager.java
 create mode 100644 core/java/com/android/internal/gmscompat/client/GmsCompatClientService.java
 create mode 100644 core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteClientHooks.java
 create mode 100644 core/java/com/android/internal/gmscompat/dynamite/server/FileProxyService.java
 create mode 100644 core/java/com/android/internal/gmscompat/dynamite/server/IFileProxyService.aidl
 create mode 100644 core/java/com/android/internal/gmscompat/flags/GmsFlag.java
 create mode 100644 core/java/com/android/internal/gmscompat/gcarriersettings/GCarrierSettingsApp.java
 create mode 100644 core/java/com/android/internal/gmscompat/gcarriersettings/ICarrierConfigsLoader.aidl
 create mode 100644 core/java/com/android/internal/gmscompat/gcarriersettings/TestCarrierConfigService.java
 create mode 100644 core/java/com/android/internal/gmscompat/sysservice/GmcPackageManager.java
 create mode 100644 core/java/com/android/internal/gmscompat/sysservice/GmcTelephonyManager.java
 create mode 100644 core/java/com/android/internal/gmscompat/sysservice/GmcUserManager.java
 create mode 100644 core/java/com/android/internal/gmscompat/util/CursorWrapperExt.java
 create mode 100644 core/java/com/android/internal/gmscompat/util/GmcActivityUtils.java
 create mode 100644 services/core/java/com/android/server/pm/ext/GCarrierSettingsHooks.java
 create mode 100644 services/core/java/com/android/server/pm/ext/GmsCompatPkgParsingHooks.java
 create mode 100644 services/core/java/com/android/server/pm/ext/GmsCoreHooks.java
 create mode 100644 services/core/java/com/android/server/pm/ext/GsfParsingHooks.java
 create mode 100644 services/core/java/com/android/server/pm/ext/PlayStoreHooks.java

diff --git a/apex/jobscheduler/framework/java/android/app/AlarmManager.java b/apex/jobscheduler/framework/java/android/app/AlarmManager.java
index ec6a8b8af899..bb0127db5124 100644
--- a/apex/jobscheduler/framework/java/android/app/AlarmManager.java
+++ b/apex/jobscheduler/framework/java/android/app/AlarmManager.java
@@ -26,6 +26,7 @@ import android.annotation.SdkConstant.SdkConstantType;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledSince;
 import android.compat.annotation.UnsupportedAppUsage;
@@ -1049,6 +1050,17 @@ public class AlarmManager {
             long intervalMillis, int flags, PendingIntent operation, final OnAlarmListener listener,
             String listenerTag, Executor targetExecutor, WorkSource workSource,
             AlarmClockInfo alarmClock) {
+        if (GmsCompat.isEnabled()) {
+            if (windowMillis == WINDOW_EXACT && !canScheduleExactAlarms()) {
+                windowMillis = WINDOW_HEURISTIC;
+            }
+            // non-null WorkSource requires privileged UPDATE_DEVICE_STATS permission
+            workSource = null;
+
+            // requires privileged SCHEDULE_PRIORITIZED_ALARM permission
+            flags &= ~FLAG_PRIORITIZE;
+        }
+
         if (triggerAtMillis < 0) {
             /* NOTYET
             if (mAlwaysExact) {
diff --git a/apex/jobscheduler/framework/java/android/os/PowerExemptionManager.java b/apex/jobscheduler/framework/java/android/os/PowerExemptionManager.java
index 24d815f2964b..164979b3b852 100644
--- a/apex/jobscheduler/framework/java/android/os/PowerExemptionManager.java
+++ b/apex/jobscheduler/framework/java/android/os/PowerExemptionManager.java
@@ -30,8 +30,11 @@ import android.annotation.RequiresPermission;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.UserHandleAware;
+import android.app.compat.gms.GmsCompat;
 import android.content.Context;
 
+import com.android.internal.gmscompat.client.ClientPriorityManager;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Collections;
@@ -618,6 +621,11 @@ public class PowerExemptionManager {
     @RequiresPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST)
     public void addToTemporaryAllowList(@NonNull String packageName, @ReasonCode int reasonCode,
             @Nullable String reason, long durationMs) {
+        if (GmsCompat.isEnabled()) {
+            ClientPriorityManager.raiseToForeground(packageName, durationMs, reason, reasonCode);
+            return;
+        }
+
         try {
             mService.addPowerSaveTempWhitelistApp(packageName, durationMs, mContext.getUserId(),
                     reasonCode, reason);
diff --git a/core/api/module-lib-current.txt b/core/api/module-lib-current.txt
index 190fe9f31f3c..6d0f93ef8173 100644
--- a/core/api/module-lib-current.txt
+++ b/core/api/module-lib-current.txt
@@ -82,6 +82,19 @@ package android.app.admin {
 
 }
 
+package android.app.compat.gms {
+
+  public class GmsModuleHooks {
+    method @Nullable public static String deviceConfigGetProperty(@NonNull String, @NonNull String);
+    method public static boolean deviceConfigSetProperties(@NonNull android.provider.DeviceConfig.Properties);
+    method public static boolean deviceConfigSetProperty(@NonNull String, @NonNull String, @Nullable String);
+    method @Nullable public static Boolean enableBluetoothAdapter();
+    method public static boolean interceptSynchronousResultReceiverException(@NonNull RuntimeException);
+    method public static void makeBluetoothAdapterDiscoverable();
+  }
+
+}
+
 package android.companion {
 
   public final class CompanionDeviceManager {
diff --git a/core/api/system-current.txt b/core/api/system-current.txt
index 27a77d5715e6..2321bce48382 100644
--- a/core/api/system-current.txt
+++ b/core/api/system-current.txt
@@ -2070,6 +2070,22 @@ package android.app.compat {
 
 }
 
+package android.app.compat.gms {
+
+  public final class GmsCompat {
+    method public static boolean hasPermission(@NonNull String);
+    method public static boolean isEnabled();
+    method public static boolean isEnabledFor(@NonNull android.content.pm.ApplicationInfo);
+    method public static boolean isEnabledFor(int, boolean);
+    method public static boolean isEnabledFor(@NonNull String, int);
+  }
+
+  public class GmsUtils {
+    method @NonNull public static android.content.Intent createAppPlayStoreIntent(@NonNull String);
+  }
+
+}
+
 package android.app.contentsuggestions {
 
   public final class ClassificationsRequest implements android.os.Parcelable {
diff --git a/core/java/android/app/Activity.java b/core/java/android/app/Activity.java
index 4a9fa9e63bf9..a021ea7a6503 100644
--- a/core/java/android/app/Activity.java
+++ b/core/java/android/app/Activity.java
@@ -49,6 +49,7 @@ import android.app.VoiceInteractor.Request;
 import android.app.admin.DevicePolicyManager;
 import android.app.assist.AssistContent;
 import android.app.compat.CompatChanges;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledSince;
 import android.compat.annotation.UnsupportedAppUsage;
@@ -170,6 +171,9 @@ import com.android.internal.app.IVoiceInteractionManagerService;
 import com.android.internal.app.IVoiceInteractor;
 import com.android.internal.app.ToolbarActionBar;
 import com.android.internal.app.WindowDecorActionBar;
+import com.android.internal.gmscompat.GmsCompatApp;
+import com.android.internal.gmscompat.GmsHooks;
+import com.android.internal.gmscompat.util.GmcActivityUtils;
 import com.android.internal.policy.PhoneWindow;
 import com.android.internal.util.dump.DumpableContainerImpl;
 
@@ -1712,6 +1716,10 @@ public class Activity extends ContextThemeWrapper
     @MainThread
     @CallSuper
     protected void onCreate(@Nullable Bundle savedInstanceState) {
+        if (GmsCompat.isEnabled()) {
+            GmsHooks.activityOnCreate(this);
+        }
+
         if (DEBUG_LIFECYCLE) Slog.v(TAG, "onCreate " + this + ": " + savedInstanceState);
 
         if (mLastNonConfigurationInstances != null) {
@@ -5737,6 +5745,44 @@ public class Activity extends ContextThemeWrapper
      */
     public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
             @Nullable Bundle options) {
+        if (GmsCompat.isEnabled()) {
+            Intent orig = intent;
+            intent = GmcActivityUtils.overrideStartActivityIntent(intent);
+            if (intent == null) {
+                Log.d("GmsCompat", "skipped startActivity for " + orig, new Throwable());
+                return;
+            }
+        }
+
+        if (android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS.equals(intent.getAction())) {
+            Uri data = intent.getData();
+            if (data != null && "package".equals(data.getScheme())) {
+                String pkg = data.getSchemeSpecificPart();
+
+                if (pkg != null) {
+                    switch (pkg) {
+                        case "com.google.android.tts":
+                        if (GmsCompat.isClientOfGmsCore()) {
+                            boolean installed;
+                            try {
+                                installed = ActivityThread.getPackageManager().getApplicationInfo(pkg, 0, getUserId()) != null;
+                            } catch (RemoteException e) {
+                                throw e.rethrowFromSystemServer();
+                            }
+
+                            if (!installed) {
+                                try {
+                                    GmsCompatApp.iClientOfGmsCore2Gca().showMissingAppNotification(pkg);
+                                } catch (RemoteException e) {
+                                    GmsCompatApp.callFailed(e);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
         if (mParent == null) {
             options = transferSpringboardActivityOptions(options);
             Instrumentation.ActivityResult ar =
@@ -6113,6 +6159,13 @@ public class Activity extends ContextThemeWrapper
             @Nullable Bundle options)
             throws IntentSender.SendIntentException {
         try {
+            if (intent != null) {
+                String pkg = intent.getCreatorPackage();
+                if (pkg != null && GmsCompat.isGmsAppAndUnprivilegedProcess(pkg)) {
+                    options = GmcActivityUtils.allowActivityLaunchFromPendingIntent(options);
+                }
+            }
+
             options = transferSpringboardActivityOptions(options);
             String resolvedType = null;
             if (fillInIntent != null) {
diff --git a/core/java/android/app/ActivityManager.java b/core/java/android/app/ActivityManager.java
index 6b7f4880e2f0..3b4bd6ac73db 100644
--- a/core/java/android/app/ActivityManager.java
+++ b/core/java/android/app/ActivityManager.java
@@ -35,6 +35,7 @@ import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
 import android.annotation.UserIdInt;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledSince;
 import android.compat.annotation.UnsupportedAppUsage;
@@ -87,6 +88,8 @@ import android.window.TaskSnapshot;
 
 import com.android.internal.app.LocalePicker;
 import com.android.internal.app.procstats.ProcessStats;
+import com.android.internal.gmscompat.sysservice.GmcUserManager;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.os.RoSystemProperties;
 import com.android.internal.os.TransferPipe;
 import com.android.internal.util.FastPrintWriter;
@@ -3987,7 +3990,11 @@ public class ActivityManager {
      */
     public List<RunningAppProcessInfo> getRunningAppProcesses() {
         try {
-            return getService().getRunningAppProcesses();
+            List<RunningAppProcessInfo> res = getService().getRunningAppProcesses();
+            if (GmsCompat.isEnabled()) {
+                res = GmsHooks.addRecentlyBoundPids(mContext, res);
+            }
+            return res;
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
@@ -4869,6 +4876,10 @@ public class ActivityManager {
             "android.permission.INTERACT_ACROSS_USERS_FULL"
     })
     public static int getCurrentUser() {
+        if (GmsCompat.isEnabled()) {
+            return GmcUserManager.amGetCurrentUser();
+        }
+
         try {
             return getService().getCurrentUserId();
         } catch (RemoteException e) {
@@ -5160,6 +5171,10 @@ public class ActivityManager {
      */
     @UnsupportedAppUsage
     public boolean isUserRunning(int userId) {
+        if (GmsCompat.isEnabled()) {
+            return GmcUserManager.amIsUserRunning(userId);
+        }
+
         try {
             return getService().isUserRunning(userId, 0);
         } catch (RemoteException e) {
diff --git a/core/java/android/app/ActivityThread.java b/core/java/android/app/ActivityThread.java
index 1ffa1380e74e..4feb8ad4b571 100644
--- a/core/java/android/app/ActivityThread.java
+++ b/core/java/android/app/ActivityThread.java
@@ -3679,6 +3679,10 @@ public final class ActivityThread extends ClientTransactionHandler
         }
     }
 
+    public int getProcessState() {
+        return mLastProcessState;
+    }
+
     @Override
     public void updateProcessState(int processState, boolean fromIpc) {
         synchronized (mAppThread) {
@@ -5027,6 +5031,15 @@ public final class ActivityThread extends ClientTransactionHandler
                 r.mLocalProvider.dump(info.fd.getFileDescriptor(), pw, info.args);
                 pw.flush();
             }
+        } catch (NoSuchMethodError e) {
+            if (android.app.compat.gms.GmsCompat.isEnabled()) {
+                // one of the GSF content providers accesses a hidden method from ContentProvider.dump(),
+                // which leads to a confusing crash when a bugreport is being taken (dumps of all
+                // of the active ContentProviders are included in bugreports)
+                Log.d(TAG, "handleDumpProvider", e);
+            } else {
+                throw e;
+            }
         } finally {
             IoUtils.closeQuietly(info.fd);
             StrictMode.setThreadPolicy(oldPolicy);
diff --git a/core/java/android/app/ActivityThreadHooks.java b/core/java/android/app/ActivityThreadHooks.java
index b78e85b70d94..04566cf2ed91 100644
--- a/core/java/android/app/ActivityThreadHooks.java
+++ b/core/java/android/app/ActivityThreadHooks.java
@@ -10,6 +10,7 @@ import android.os.RemoteException;
 import android.util.Log;
 
 import com.android.internal.app.StorageScopesAppHooks;
+import com.android.internal.gmscompat.GmsHooks;
 
 import java.util.Objects;
 
@@ -71,6 +72,9 @@ class ActivityThreadHooks {
 
     static Service instantiateService(String className) {
         Service res = null;
+        if (res == null) {
+            res = GmsHooks.maybeInstantiateService(className);
+        }
         return res;
     }
 }
diff --git a/core/java/android/app/AppOpsManager.java b/core/java/android/app/AppOpsManager.java
index 1794a1fd7eb8..63a19a35581f 100644
--- a/core/java/android/app/AppOpsManager.java
+++ b/core/java/android/app/AppOpsManager.java
@@ -35,6 +35,7 @@ import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
+import android.app.compat.gms.GmsCompat;
 import android.app.usage.UsageStatsManager;
 import android.compat.Compatibility;
 import android.compat.annotation.ChangeId;
@@ -8616,6 +8617,10 @@ public class AppOpsManager {
 
     private int noteOpNoThrow(int op, int uid, @Nullable String packageName,
             @Nullable String attributionTag, int virtualDeviceId, @Nullable String message) {
+        if (GmsCompat.isEnabled() && uid != Process.myUid()) {
+            return noteProxyOpNoThrow(opToPublicName(op), packageName, uid, attributionTag, message);
+        }
+
         try {
             collectNoteOpCallsForValidation(op);
             int collectionMode = getNotedOpCollectionMode(uid, packageName, op);
@@ -9203,6 +9208,10 @@ public class AppOpsManager {
             boolean startIfModeDefault, @Nullable String attributionTag, int virtualDeviceId,
             @Nullable String message, @AttributionFlags int attributionFlags,
             int attributionChainId) {
+        if (GmsCompat.isEnabled() && uid != Process.myUid()) {
+            return startProxyOpNoThrow(opToPublicName(op), uid, packageName, attributionTag, message);
+        }
+
         try {
             collectNoteOpCallsForValidation(op);
             int collectionMode = getNotedOpCollectionMode(uid, packageName, op);
@@ -9451,6 +9460,11 @@ public class AppOpsManager {
 
     private void finishOp(IBinder token, int op, int uid, @NonNull String packageName,
             @Nullable String attributionTag, int virtualDeviceId ) {
+        if (GmsCompat.isEnabled() && uid != Process.myUid()) {
+            finishProxyOp(opToPublicName(op), uid, packageName, attributionTag);
+            return;
+        }
+
         try {
             if (virtualDeviceId == Context.DEVICE_ID_DEFAULT) {
                 mService.finishOperation(token, op, uid, packageName, attributionTag);
diff --git a/core/java/android/app/Application.java b/core/java/android/app/Application.java
index 6a50e74ca3a4..4202352c9524 100644
--- a/core/java/android/app/Application.java
+++ b/core/java/android/app/Application.java
@@ -19,6 +19,7 @@ package android.app;
 import android.annotation.CallSuper;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentCallbacks;
 import android.content.ComponentCallbacks2;
@@ -232,6 +233,11 @@ public class Application extends ContextWrapper implements ComponentCallbacks2 {
 
     public Application() {
         super(null);
+
+        if (GmsCompat.isEnabled()) {
+            registerActivityLifecycleCallbacks(com.android.internal.gmscompat.util
+                    .GmcActivityUtils.INSTANCE);
+        }
     }
 
     private String getLoadedApkInfo() {
diff --git a/core/java/android/app/ApplicationErrorReport.aidl b/core/java/android/app/ApplicationErrorReport.aidl
index 5b57457a3315..34a05ab33ae1 100644
--- a/core/java/android/app/ApplicationErrorReport.aidl
+++ b/core/java/android/app/ApplicationErrorReport.aidl
@@ -17,4 +17,5 @@
 package android.app;
 
 /** @hide */
-parcelable ApplicationErrorReport.ParcelableCrashInfo;
\ No newline at end of file
+parcelable ApplicationErrorReport;
+parcelable ApplicationErrorReport.ParcelableCrashInfo;
diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index d1694013ae52..e5c11e5f51e7 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -37,6 +37,7 @@ import android.annotation.StringRes;
 import android.annotation.UserIdInt;
 import android.annotation.XmlRes;
 import android.app.admin.DevicePolicyManager;
+import android.app.compat.gms.GmsCompat;
 import android.app.role.RoleManager;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentName;
@@ -124,6 +125,7 @@ import android.util.Log;
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.Immutable;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.gmscompat.sysservice.GmcPackageManager;
 import com.android.internal.os.SomeArgs;
 import com.android.internal.util.UserIcons;
 
@@ -267,6 +269,7 @@ public class ApplicationPackageManager extends PackageManager {
         if (pi == null) {
             throw new NameNotFoundException(packageName);
         }
+        GmcPackageManager.maybeAdjustPackageInfo(pi);
         return pi;
     }
 
@@ -527,6 +530,9 @@ public class ApplicationPackageManager extends PackageManager {
         if (ai == null) {
             throw new NameNotFoundException(packageName);
         }
+
+        GmcPackageManager.maybeAdjustApplicationInfo(ai);
+
         return maybeAdjustApplicationInfo(ai);
     }
 
@@ -1708,12 +1714,17 @@ public class ApplicationPackageManager extends PackageManager {
     @Override
     public ProviderInfo resolveContentProviderAsUser(String name, ComponentInfoFlags flags,
             int userId) {
+        ProviderInfo res;
         try {
-            return mPM.resolveContentProvider(name,
+            res = mPM.resolveContentProvider(name,
                     updateFlagsForComponent(flags.getValue(), userId, null), userId);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
+        if (res != null && res.applicationInfo != null && "com.google.android.gms.chimera".equals(name)) {
+            GmcPackageManager.maybeAdjustApplicationInfo(res.applicationInfo);
+        }
+        return res;
     }
 
     @Override
@@ -2159,8 +2170,8 @@ public class ApplicationPackageManager extends PackageManager {
     }
 
     @UnsupportedAppUsage
-    protected ApplicationPackageManager(ContextImpl context, IPackageManager pm) {
-        mContext = context;
+    protected ApplicationPackageManager(Context context, IPackageManager pm) {
+        mContext = (ContextImpl) context;
         mPM = pm;
     }
 
diff --git a/core/java/android/app/BroadcastOptions.java b/core/java/android/app/BroadcastOptions.java
index 41b400459526..86ab978d4577 100644
--- a/core/java/android/app/BroadcastOptions.java
+++ b/core/java/android/app/BroadcastOptions.java
@@ -24,6 +24,7 @@ import android.annotation.RequiresPermission;
 import android.annotation.SystemApi;
 import android.annotation.TestApi;
 import android.app.compat.CompatChanges;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.Disabled;
 import android.compat.annotation.EnabledSince;
@@ -563,6 +564,10 @@ public class BroadcastOptions extends ComponentOptions {
     @SystemApi
     @RequiresPermission(android.Manifest.permission.START_ACTIVITIES_FROM_BACKGROUND)
     public void setBackgroundActivityStartsAllowed(boolean allowBackgroundActivityStarts) {
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         if (allowBackgroundActivityStarts) {
             mFlags |= FLAG_ALLOW_BACKGROUND_ACTIVITY_STARTS;
         } else {
@@ -775,6 +780,10 @@ public class BroadcastOptions extends ComponentOptions {
     @SystemApi
     @RequiresPermission(android.Manifest.permission.ACCESS_BROADCAST_RESPONSE_STATS)
     public void recordResponseEventWhileInBackground(@IntRange(from = 0) long id) {
+        if (GmsCompat.isEnabled()) {
+            return;
+        }
+
         mIdForResponseEvent = id;
     }
 
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 014ddd41f8d4..1283c248f9c2 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -21,12 +21,14 @@ import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 import static android.os.StrictMode.vmIncorrectContextUseEnabled;
 import static android.view.WindowManager.LayoutParams.WindowType;
 
+import android.Manifest;
 import android.annotation.CallbackExecutor;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.SuppressLint;
 import android.annotation.UiContext;
+import android.app.compat.gms.GmsCompat;
 import android.companion.virtual.VirtualDeviceManager;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.AttributionSource;
@@ -99,6 +101,9 @@ import android.window.WindowTokenClient;
 import android.window.WindowTokenClientController;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.sysservice.GmcPackageManager;
+import com.android.internal.gmscompat.GmsHooks;
+import com.android.internal.gmscompat.sysservice.GmcUserManager;
 import com.android.internal.util.Preconditions;
 
 import dalvik.system.BlockGuard;
@@ -429,7 +434,7 @@ class ContextImpl extends Context {
         final IPackageManager pm = ActivityThread.getPackageManager();
         if (pm != null) {
             // Doesn't matter if we make more than one instance.
-            return (mPackageManager = new ApplicationPackageManager(this, pm));
+            return (mPackageManager = GmsCompat.isEnabled() ? new GmcPackageManager(this, pm) : new ApplicationPackageManager(this, pm));
         }
 
         return null;
@@ -1317,6 +1322,10 @@ class ContextImpl extends Context {
 
     @Override
     public void sendBroadcast(Intent intent, String receiverPermission, Bundle options) {
+        if (GmsCompat.isEnabled()) {
+            options = GmsHooks.filterBroadcastOptions(intent, options);
+        }
+
         warnIfCallingFromSystemProcess();
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         String[] receiverPermissions = receiverPermission == null ? null
@@ -1415,6 +1424,10 @@ class ContextImpl extends Context {
             String receiverPermission, int appOp, BroadcastReceiver resultReceiver,
             Handler scheduler, int initialCode, String initialData,
             Bundle initialExtras, Bundle options) {
+        if (GmsCompat.isEnabled()) {
+            options = GmsHooks.filterBroadcastOptions(intent, options);
+        }
+
         warnIfCallingFromSystemProcess();
         IIntentReceiver rd = null;
         if (resultReceiver != null) {
@@ -1450,6 +1463,10 @@ class ContextImpl extends Context {
 
     @Override
     public void sendBroadcastAsUser(Intent intent, UserHandle user) {
+        if (GmsCompat.isEnabled()) {
+            user = GmcUserManager.translateUserHandle(user);
+        }
+
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         try {
             intent.prepareToLeaveProcess(this);
@@ -1471,6 +1488,11 @@ class ContextImpl extends Context {
     @Override
     public void sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission,
             Bundle options) {
+        if (GmsCompat.isEnabled()) {
+            options = GmsHooks.filterBroadcastOptions(intent, options);
+            user = GmcUserManager.translateUserHandle(user);
+        }
+
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         String[] receiverPermissions = receiverPermission == null ? null
                 : new String[] {receiverPermission};
@@ -1489,6 +1511,10 @@ class ContextImpl extends Context {
     @Override
     public void sendBroadcastAsUser(Intent intent, UserHandle user,
             String receiverPermission, int appOp) {
+        if (GmsCompat.isEnabled()) {
+            user = GmcUserManager.translateUserHandle(user);
+        }
+
         String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());
         String[] receiverPermissions = receiverPermission == null ? null
                 : new String[] {receiverPermission};
@@ -1524,6 +1550,11 @@ class ContextImpl extends Context {
     public void sendOrderedBroadcastAsUser(Intent intent, UserHandle user,
             String receiverPermission, int appOp, Bundle options, BroadcastReceiver resultReceiver,
             Handler scheduler, int initialCode, String initialData, Bundle initialExtras) {
+        if (GmsCompat.isEnabled()) {
+            options = GmsHooks.filterBroadcastOptions(intent, options);
+            user = GmcUserManager.translateUserHandle(user);
+        }
+
         IIntentReceiver rd = null;
         if (resultReceiver != null) {
             if (mPackageInfo != null) {
@@ -2117,6 +2148,25 @@ class ContextImpl extends Context {
             throw new RuntimeException("Not supported in system context");
         }
         validateServiceIntent(service);
+
+        if (GmsCompat.isEnabled()) {
+            if (!GmsCompat.hasPermission(Manifest.permission.START_ACTIVITIES_FROM_BACKGROUND)) {
+                flags &= ~BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS;
+            }
+        }
+
+        String pkg = service.getPackage();
+        if (pkg == null) {
+            ComponentName cn = service.getComponent();
+            if (cn != null) {
+                pkg = cn.getPackageName();
+            }
+        }
+
+        if (pkg != null && GmsCompat.isGmsAppAndUnprivilegedProcess(pkg)) {
+            flags |= BIND_ALLOW_ACTIVITY_STARTS;
+        }
+
         try {
             IBinder token = getActivityToken();
             if (token == null && (flags&BIND_AUTO_CREATE) == 0 && mPackageInfo != null
@@ -2195,6 +2245,12 @@ class ContextImpl extends Context {
 
     @Override
     public Object getSystemService(String name) {
+        if (GmsCompat.isEnabled()) {
+            if (GmsHooks.isHiddenSystemService(name)) {
+                return null;
+            }
+        }
+
         if (vmIncorrectContextUseEnabled()) {
             // Check incorrect Context usage.
             if (WINDOW_SERVICE.equals(name) && !isUiContext()) {
@@ -2319,6 +2375,12 @@ class ContextImpl extends Context {
             return PERMISSION_DENIED;
         }
 
+        if (GmsCompat.isEnabled()) {
+            if (GmsHooks.shouldSpoofSelfPermissionCheck(permission)) {
+                return PERMISSION_GRANTED;
+            }
+        }
+
         return checkPermission(permission, Process.myPid(), Process.myUid());
     }
 
diff --git a/core/java/android/app/DownloadManager.java b/core/java/android/app/DownloadManager.java
index de0244f3934f..99d20758424d 100644
--- a/core/java/android/app/DownloadManager.java
+++ b/core/java/android/app/DownloadManager.java
@@ -24,6 +24,7 @@ import android.annotation.SdkConstant.SdkConstantType;
 import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ClipDescription;
 import android.content.ContentProviderClient;
@@ -713,6 +714,13 @@ public class DownloadManager {
          * @return this object
          */
         public Request setNotificationVisibility(int visibility) {
+            if (GmsCompat.isEnabled()) {
+                // requires the privileged DOWNLOAD_WITHOUT_NOTIFICATION permission
+                if (visibility == VISIBILITY_HIDDEN) {
+                    return this;
+                }
+            }
+
             mNotificationVisibility = visibility;
             return this;
         }
diff --git a/core/java/android/app/Instrumentation.java b/core/java/android/app/Instrumentation.java
index df6fc69f4e4f..5ab067fc4664 100644
--- a/core/java/android/app/Instrumentation.java
+++ b/core/java/android/app/Instrumentation.java
@@ -19,6 +19,7 @@ package android.app;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ActivityNotFoundException;
 import android.content.ComponentName;
@@ -62,6 +63,7 @@ import android.view.WindowManagerGlobal;
 
 import com.android.internal.app.StorageScopesAppHooks;
 import com.android.internal.content.ReferrerIntent;
+import com.android.internal.gmscompat.GmsHooks;
 
 import java.io.File;
 import java.lang.annotation.Retention;
@@ -1342,6 +1344,7 @@ public class Instrumentation {
     public Application newApplication(ClassLoader cl, String className, Context context)
             throws InstantiationException, IllegalAccessException, 
             ClassNotFoundException {
+        GmsCompat.maybeEnable(context);
         Application app = getFactory(context.getPackageName())
                 .instantiateApplication(cl, className);
         app.attach(context);
@@ -1360,6 +1363,7 @@ public class Instrumentation {
     static public Application newApplication(Class<?> clazz, Context context)
             throws InstantiationException, IllegalAccessException, 
             ClassNotFoundException {
+        GmsCompat.maybeEnable(context);
         Application app = (Application)clazz.newInstance();
         app.attach(context);
         return app;
@@ -1949,6 +1953,11 @@ public class Instrumentation {
                     target != null ? target.mEmbeddedID : null, requestCode, 0, null, options);
             notifyStartActivityResult(result, options);
             checkStartActivityResult(result, intent);
+
+            if (GmsCompat.isEnabled()) {
+                GmsHooks.onActivityStart(result, intent, requestCode, options);
+            }
+
         } catch (RemoteException e) {
             throw new RuntimeException("Failure from system", e);
         }
diff --git a/core/java/android/app/NotificationManager.java b/core/java/android/app/NotificationManager.java
index d23b16d636a7..bc95a79ae0ea 100644
--- a/core/java/android/app/NotificationManager.java
+++ b/core/java/android/app/NotificationManager.java
@@ -16,6 +16,7 @@
 
 package android.app;
 
+import android.Manifest;
 import android.annotation.FlaggedApi;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
@@ -30,6 +31,7 @@ import android.annotation.UserHandleAware;
 import android.annotation.WorkerThread;
 import android.app.Notification.Builder;
 import android.app.compat.CompatChanges;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledSince;
 import android.compat.annotation.UnsupportedAppUsage;
@@ -61,6 +63,8 @@ import android.service.notification.ZenPolicy;
 import android.util.Log;
 import android.util.proto.ProtoOutputStream;
 
+import com.android.internal.gmscompat.GmsCompatApp;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
@@ -714,6 +718,17 @@ public class NotificationManager {
     @UnsupportedAppUsage
     public void notifyAsUser(String tag, int id, Notification notification, UserHandle user)
     {
+        if (GmsCompat.isEnabled()) {
+            if (!GmsCompat.hasPermission(Manifest.permission.POST_NOTIFICATIONS)) {
+                String pkg = GmsCompat.appContext().getPackageName();
+                try {
+                    GmsCompatApp.iGms2Gca().showMissingPostNotifsPermissionNotification(pkg);
+                } catch (RemoteException e) {
+                    GmsCompatApp.callFailed(e);
+                }
+            }
+        }
+
         INotificationManager service = getService();
         String pkg = mContext.getPackageName();
 
@@ -1569,6 +1584,10 @@ public class NotificationManager {
      * {@link android.provider.Settings#ACTION_NOTIFICATION_LISTENER_SETTINGS}.
      */
     public boolean isNotificationListenerAccessGranted(ComponentName listener) {
+        if (GmsCompat.isAndroidAuto()) {
+            return true;
+        }
+
         INotificationManager service = getService();
         try {
             return service.isNotificationListenerAccessGranted(listener);
diff --git a/core/java/android/app/PendingIntent.java b/core/java/android/app/PendingIntent.java
index 62209b0fd27d..c7c0dd624d9c 100644
--- a/core/java/android/app/PendingIntent.java
+++ b/core/java/android/app/PendingIntent.java
@@ -30,6 +30,7 @@ import android.annotation.SystemApi;
 import android.annotation.SystemApi.Client;
 import android.annotation.TestApi;
 import android.app.ActivityManager.PendingIntentInfo;
+import android.app.compat.gms.GmsCompat;
 import android.compat.Compatibility;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledAfter;
@@ -60,6 +61,9 @@ import android.util.Pair;
 import android.util.proto.ProtoOutputStream;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.GmsHooks;
+import com.android.internal.gmscompat.GmsInfo;
+import com.android.internal.gmscompat.util.GmcActivityUtils;
 import com.android.internal.os.IResultReceiver;
 
 import java.lang.annotation.Retention;
@@ -1071,6 +1075,22 @@ public final class PendingIntent implements Parcelable {
             @Nullable OnFinished onFinished, @Nullable Handler handler,
             @Nullable String requiredPermission, @Nullable Bundle options)
             throws CanceledException {
+        if (GmsCompat.isEnabled()) {
+            if (options != null && intent != null && isBroadcast()) {
+                String targetPkg = getCreatorPackage();
+                if (targetPkg != null) {
+                    options = GmsHooks.filterBroadcastOptions(options, targetPkg);
+                }
+            }
+        }
+
+        if (isActivity()) {
+            String pkg = getCreatorPackage();
+            if (pkg != null && GmsCompat.isGmsAppAndUnprivilegedProcess(pkg)) {
+                options = GmcActivityUtils.allowActivityLaunchFromPendingIntent(options);
+            }
+        }
+
         if (sendAndReturnResult(context, code, intent, onFinished, handler, requiredPermission,
                 options) < 0) {
             throw new CanceledException();
diff --git a/core/java/android/app/Service.java b/core/java/android/app/Service.java
index a1554572c7df..89cf14e551cb 100644
--- a/core/java/android/app/Service.java
+++ b/core/java/android/app/Service.java
@@ -20,10 +20,12 @@ import static android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_MANIFEST;
 import static android.os.Trace.TRACE_TAG_ACTIVITY_MANAGER;
 import static android.text.TextUtils.formatSimple;
 
+import android.Manifest;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentCallbacks2;
 import android.content.ComponentName;
@@ -857,6 +859,20 @@ public abstract class Service extends ContextWrapper implements ComponentCallbac
      */
     public final void startForeground(int id, @NonNull Notification notification,
             @RequiresPermission @ForegroundServiceType int foregroundServiceType) {
+        if (GmsCompat.isEnabled()) {
+            if ((foregroundServiceType & ServiceInfo.FOREGROUND_SERVICE_TYPE_MICROPHONE) != 0) {
+                if (!GmsCompat.hasPermission(Manifest.permission.RECORD_AUDIO)) {
+                    foregroundServiceType &= ~ServiceInfo.FOREGROUND_SERVICE_TYPE_MICROPHONE;
+                }
+            }
+
+            if ((foregroundServiceType & ServiceInfo.FOREGROUND_SERVICE_TYPE_LOCATION) != 0) {
+                if (!GmsCompat.hasPermission(Manifest.permission.ACCESS_COARSE_LOCATION)) {
+                    foregroundServiceType &= ~ServiceInfo.FOREGROUND_SERVICE_TYPE_LOCATION;
+                }
+            }
+        }
+
         try {
             final ComponentName comp = new ComponentName(this, mClassName);
             mActivityManager.setServiceForeground(
@@ -865,6 +881,12 @@ public abstract class Service extends ContextWrapper implements ComponentCallbac
             clearStartForegroundServiceStackTrace();
             logForegroundServiceStart(comp, foregroundServiceType);
         } catch (RemoteException ex) {
+        } catch (SecurityException e) {
+            if (GmsCompat.isEnabled()) {
+                Log.e(TAG, "fgsType: " + Integer.toHexString(foregroundServiceType), e);
+                return;
+            }
+            throw e;
         }
     }
 
diff --git a/core/java/android/app/SharedPreferencesImpl.java b/core/java/android/app/SharedPreferencesImpl.java
index a87187b8affb..9f5e947fe9fd 100644
--- a/core/java/android/app/SharedPreferencesImpl.java
+++ b/core/java/android/app/SharedPreferencesImpl.java
@@ -17,6 +17,7 @@
 package android.app;
 
 import android.annotation.Nullable;
+import android.app.compat.gms.GmsCompat;
 import android.compat.Compatibility;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledSince;
@@ -32,6 +33,7 @@ import android.system.StructTimespec;
 import android.util.Log;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.util.ExponentiallyBucketedHistogram;
 import com.android.internal.util.XmlUtils;
 
@@ -295,11 +297,24 @@ final class SharedPreferencesImpl implements SharedPreferences {
 
     @Override
     public Map<String, ?> getAll() {
+        HashMap<String, Object> res;
         synchronized (mLock) {
             awaitLoadedLocked();
             //noinspection unchecked
-            return new HashMap<String, Object>(mMap);
+            res = new HashMap<String, Object>(mMap);
         }
+
+        if (GmsCompat.isEnabled()) {
+            String fileName = mFile.getName();
+            String suffix = ".xml";
+            if (fileName.endsWith(suffix)) {
+                int endIndex = fileName.length() - suffix.length();
+                String name = fileName.substring(0, endIndex);
+                GmsHooks.maybeModifySharedPreferencesValues(name, res);
+            }
+        }
+
+        return res;
     }
 
     @Override
diff --git a/core/java/android/app/SystemServiceRegistry.java b/core/java/android/app/SystemServiceRegistry.java
index 9cf732abb86a..791810cdc732 100644
--- a/core/java/android/app/SystemServiceRegistry.java
+++ b/core/java/android/app/SystemServiceRegistry.java
@@ -29,6 +29,7 @@ import android.app.ambientcontext.AmbientContextManager;
 import android.app.ambientcontext.IAmbientContextManager;
 import android.app.appsearch.AppSearchManagerFrameworkInitializer;
 import android.app.blob.BlobStoreManagerFrameworkInitializer;
+import android.app.compat.gms.GmsCompat;
 import android.app.contentsuggestions.ContentSuggestionsManager;
 import android.app.contentsuggestions.IContentSuggestionsManager;
 import android.app.job.JobSchedulerFrameworkInitializer;
@@ -253,6 +254,7 @@ import com.android.internal.app.IAppOpsService;
 import com.android.internal.app.IBatteryStats;
 import com.android.internal.app.ISoundTriggerService;
 import com.android.internal.appwidget.IAppWidgetService;
+import com.android.internal.gmscompat.sysservice.GmcUserManager;
 import com.android.internal.graphics.fonts.IFontManager;
 import com.android.internal.net.INetworkWatchlistManager;
 import com.android.internal.os.IBinaryTransparencyService;
@@ -814,6 +816,11 @@ public final class SystemServiceRegistry {
             public UserManager createService(ContextImpl ctx) throws ServiceNotFoundException {
                 IBinder b = ServiceManager.getServiceOrThrow(Context.USER_SERVICE);
                 IUserManager service = IUserManager.Stub.asInterface(b);
+
+                if (GmsCompat.isEnabled()) {
+                    return new GmcUserManager(ctx, service);
+                }
+
                 return new UserManager(ctx, service);
             }});
 
diff --git a/core/java/android/app/WallpaperManager.java b/core/java/android/app/WallpaperManager.java
index f58378e8d64d..2185ffd343e4 100644
--- a/core/java/android/app/WallpaperManager.java
+++ b/core/java/android/app/WallpaperManager.java
@@ -36,6 +36,7 @@ import android.annotation.SystemService;
 import android.annotation.TestApi;
 import android.annotation.UiContext;
 import android.app.compat.CompatChanges;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledSince;
 import android.compat.annotation.UnsupportedAppUsage;
@@ -648,6 +649,11 @@ public class WallpaperManager {
                         return getDefaultWallpaper(context, FLAG_SYSTEM);
                     }
 
+                    if (GmsCompat.isEnabled()) {
+                        Log.d("GmsCompat", "", e);
+                        return getDefaultWallpaper(context, FLAG_SYSTEM);
+                    }
+
                     if (StorageScopesAppHooks.isEnabled()) {
                         Log.d("StorageScopes", "returning default wallpaper");
                         return getDefaultWallpaper(context, FLAG_SYSTEM);
@@ -1703,6 +1709,11 @@ public class WallpaperManager {
                     return getDefaultSystemWallpaperFile();
                 }
 
+                if (GmsCompat.isEnabled()) {
+                    Log.d("GmsCompat", "", e);
+                    return getDefaultSystemWallpaperFile();
+                }
+
                 if (StorageScopesAppHooks.isEnabled()) {
                     Log.d("StorageScopes", "returning default wallpaper file");
                     return getDefaultSystemWallpaperFile();
diff --git a/core/java/android/app/compat/gms/GmsCompat.java b/core/java/android/app/compat/gms/GmsCompat.java
new file mode 100644
index 000000000000..1e61e46aacc6
--- /dev/null
+++ b/core/java/android/app/compat/gms/GmsCompat.java
@@ -0,0 +1,316 @@
+package android.app.compat.gms;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.annotation.SystemApi;
+import android.app.ActivityThread;
+import android.app.AppGlobals;
+import android.app.Application;
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+import android.ext.AppInfoExt;
+import android.ext.PackageId;
+import android.os.Binder;
+import android.os.Build;
+import android.os.Process;
+import android.os.RemoteException;
+import android.os.SystemProperties;
+import android.os.UserHandle;
+
+import com.android.internal.gmscompat.GmsHooks;
+import com.android.internal.gmscompat.GmsInfo;
+import com.android.internal.util.ArrayUtils;
+
+/**
+ * This class provides helpers for GMS ("Google Mobile Services") compatibility.
+ * <p>
+ * It allows the following apps to work as regular, unprivileged user apps:
+ * <ul>
+ *     <li>GSF ("Google Services Framework")</li>
+ *     <li>GmsCore ("Google Play services")</li>
+ *     <li>Google Play Store</li>
+ *     <li>GSA ("Google Search app", com.google.android.googlequicksearchbox)</li>
+ *     <li>Apps that depend on the above</li>
+ * </ul>
+ * <p>
+ *
+ * @hide
+ */
+@SystemApi
+public final class GmsCompat {
+    private static final String TAG = "GmsCompat/Core";
+
+    private static boolean isGmsCompatEnabled;
+    private static int curPackageId;
+    private static boolean isGmsCore;
+
+    private static boolean isEligibleForClientCompat;
+
+    // Static only
+    private GmsCompat() { }
+
+    public static boolean isEnabled() {
+        return isGmsCompatEnabled;
+    }
+
+    /** @hide */
+    public static boolean isGmsCore() {
+        return curPackageId == PackageId.GMS_CORE;
+    }
+
+    /** @hide */
+    public static boolean isPlayStore() {
+        return curPackageId == PackageId.PLAY_STORE;
+    }
+
+    /** @hide */
+    public static boolean isGCarrierSettings() {
+        return curPackageId == PackageId.G_CARRIER_SETTINGS;
+    }
+
+    /** @hide */
+    public static boolean isAndroidAuto() {
+        return curPackageId == PackageId.ANDROID_AUTO;
+    }
+
+    /** @hide */
+    public static int getCurrentPackageId() {
+        return curPackageId;
+    }
+
+    private static Context appContext;
+
+    /** @hide */
+    public static Context appContext() {
+        return appContext;
+    }
+
+    /**
+     * Call from Instrumentation.newApplication() before Application class in instantiated to
+     * make sure init is completed in GMS processes before any of the app's code is executed.
+     *
+     * @hide
+     */
+    public static void maybeEnable(Context appCtx) {
+        if (!Process.isApplicationUid(Process.myUid())) {
+            // note that isApplicationUid() returns false for processes of services that have
+            // 'android:isolatedProcess="true"' directive in AndroidManifest, which is fine,
+            // because they have no need for GmsCompat
+            return;
+        }
+
+        appContext = appCtx;
+        ApplicationInfo appInfo = appCtx.getApplicationInfo();
+        AppInfoExt appInfoExt = appInfo.ext();
+
+        curPackageId = appInfoExt.getPackageId();
+
+        if (isEnabledFor(appInfo)) {
+            isGmsCompatEnabled = true;
+            GmsHooks.init(appCtx, appInfo.packageName);
+        }
+
+        isEligibleForClientCompat = !isGmsCore() &&
+                appInfoExt.hasFlag(AppInfoExt.FLAG_HAS_GMSCORE_CLIENT_LIBRARY);
+    }
+
+    public static boolean isEnabledFor(@NonNull ApplicationInfo app) {
+        if (Build.IS_DEBUGGABLE) {
+            if (isTestPackage(app.packageName)) {
+                return true;
+            }
+        }
+
+        return isEnabledFor(app.ext().getPackageId(), app.isPrivilegedApp());
+    }
+
+    public static boolean isEnabledFor(int packageId, boolean isPrivileged) {
+        if (isPrivileged) {
+            // don't enable GmsCompat for privileged GMS
+            return false;
+        }
+
+        return switch (packageId) {
+            case
+                PackageId.GSF,
+                PackageId.GMS_CORE,
+                PackageId.PLAY_STORE,
+                PackageId.G_SEARCH_APP,
+                PackageId.ANDROID_AUTO,
+                PackageId.G_CARRIER_SETTINGS ->
+                    true;
+            default ->
+                    false;
+        };
+    }
+
+    /** @hide */
+    public static boolean canBeEnabledFor(String pkgName) {
+        if (Build.IS_DEBUGGABLE) {
+            if (isTestPackage(pkgName)) {
+                return true;
+            }
+        }
+
+        return switch (pkgName) {
+            case
+                PackageId.GSF_NAME,
+                PackageId.GMS_CORE_NAME,
+                PackageId.PLAY_STORE_NAME,
+                PackageId.G_SEARCH_APP_NAME,
+                PackageId.ANDROID_AUTO_NAME,
+                PackageId.G_CARRIER_SETTINGS_NAME ->
+                    true;
+            default ->
+                    false;
+        };
+
+    }
+
+    /** @hide */
+    public static boolean isGmsAppAndUnprivilegedProcess(@NonNull String packageName) {
+        if (!isEnabledFor(packageName, UserHandle.USER_CURRENT)) {
+            return false;
+        }
+
+        Application a = AppGlobals.getInitialApplication();
+        if (a == null) {
+            return false;
+        }
+
+        ApplicationInfo ai = a.getApplicationInfo();
+        if (ai == null) {
+            return false;
+        }
+
+        return !ai.isPrivilegedApp();
+    }
+
+    public static boolean isEnabledFor(@NonNull String packageName, int userId) {
+        return isEnabledFor(packageName, userId, false);
+    }
+
+    /** @hide */
+    public static boolean isEnabledFor(@NonNull String packageName, int userId, boolean matchDisabledApp) {
+        if (Build.isDebuggable()) {
+            if (isTestPackage(packageName, userId, matchDisabledApp)) {
+                return true;
+            }
+        }
+
+        if (!canBeEnabledFor(packageName)) {
+            return false;
+        }
+
+        if (userId == UserHandle.USER_CURRENT) {
+            userId = UserHandle.myUserId();
+        }
+
+        Context ctx = AppGlobals.getInitialApplication();
+        if (ctx == null) {
+            return false;
+        }
+
+        PackageManager pm = ctx.getPackageManager();
+
+        ApplicationInfo appInfo;
+        long token = Binder.clearCallingIdentity();
+        try {
+            appInfo = pm.getApplicationInfoAsUser(packageName, 0, userId);
+        } catch (PackageManager.NameNotFoundException e) {
+            return false;
+        } finally {
+            Binder.restoreCallingIdentity(token);
+        }
+
+        return isEnabledFor(appInfo, matchDisabledApp);
+    }
+
+    /** @hide */
+    public static boolean isEnabledFor(@Nullable ApplicationInfo app, boolean matchDisabledApp) {
+        if (app == null) {
+            return false;
+        }
+        if (!app.enabled && !matchDisabledApp) {
+            return false;
+        }
+        return isEnabledFor(app);
+    }
+
+    private static volatile boolean cachedIsClientOfGmsCore;
+
+    /** @hide */
+    public static boolean isClientOfGmsCore() {
+        return isClientOfGmsCore(null);
+    }
+
+    /** @hide */
+    public static boolean isClientOfGmsCore(@Nullable ApplicationInfo gmsCoreAppInfo) {
+        if (cachedIsClientOfGmsCore) {
+            return true;
+        }
+
+        if (!isEligibleForClientCompat) {
+            return false;
+        }
+
+        boolean res = (gmsCoreAppInfo != null) ?
+                isEnabledFor(gmsCoreAppInfo) :
+                isEnabledFor(GmsInfo.PACKAGE_GMS_CORE, appContext().getUserId());
+
+        cachedIsClientOfGmsCore = res;
+        return res;
+    }
+
+    public static boolean hasPermission(@NonNull String perm) {
+        Context ctx = appContext();
+
+        if (GmsHooks.config().shouldSpoofSelfPermissionCheck(perm)) {
+            // result of checkSelfPermission() below would be spoofed, ask the PackageManager directly
+            IPackageManager pm = ActivityThread.getPackageManager();
+            try {
+                return pm.checkPermission(perm, ctx.getPackageName(), ctx.getUserId())
+                        == PackageManager.PERMISSION_GRANTED;
+            } catch (RemoteException e) {
+                throw e.rethrowFromSystemServer();
+            }
+        }
+
+        return ctx.checkSelfPermission(perm) == PackageManager.PERMISSION_GRANTED;
+    }
+
+    private static boolean isTestPackage(String packageName) {
+        String testPkgs = SystemProperties.get("persist.gmscompat_test_pkgs");
+        return ArrayUtils.contains(testPkgs.split(","), packageName);
+    }
+
+    // call only when Build.isDebuggable() is true
+    /** @hide */
+    public static boolean isTestPackage(String packageName, int userId, boolean matchDisabledApp) {
+        if (!Build.isDebuggable()) {
+            return false;
+        }
+        if (!isTestPackage(packageName)) {
+            return false;
+        }
+
+        IPackageManager pm = ActivityThread.getPackageManager();
+        ApplicationInfo ai;
+
+        long token = Binder.clearCallingIdentity();
+        try {
+            ai = pm.getApplicationInfo(packageName, 0, userId);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        } finally {
+            Binder.restoreCallingIdentity(token);
+        }
+
+        if (ai == null) {
+            return false;
+        }
+        return ai.enabled || matchDisabledApp;
+    }
+}
diff --git a/core/java/android/app/compat/gms/GmsModuleHooks.java b/core/java/android/app/compat/gms/GmsModuleHooks.java
new file mode 100644
index 000000000000..7056d0962abc
--- /dev/null
+++ b/core/java/android/app/compat/gms/GmsModuleHooks.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2022 GrapheneOS
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.compat.gms;
+
+import android.Manifest;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.annotation.SuppressLint;
+import android.annotation.SystemApi;
+import android.app.Activity;
+import android.bluetooth.BluetoothAdapter;
+import android.content.Intent;
+import android.os.Build;
+import android.os.RemoteException;
+import android.util.Log;
+
+import com.android.internal.gmscompat.GmsCompatApp;
+import com.android.internal.gmscompat.GmsHooks;
+import com.android.internal.gmscompat.StubDef;
+import com.android.internal.gmscompat.util.GmcActivityUtils;
+
+/**
+ * Hooks that are accessed from APEX modules.
+ *
+ * @hide
+ */
+@SystemApi(client = SystemApi.Client.MODULE_LIBRARIES)
+public class GmsModuleHooks {
+    private static final String TAG = "GmsCompat/MHooks";
+
+    // BluetoothAdapter#enable()
+    // BluetoothAdapter#enableBLE()
+    @SuppressLint("AutoBoxing")
+    @Nullable
+    // returns null if hook wasn't applied, otherwise returns boxed return value for the original method
+    public static Boolean enableBluetoothAdapter() {
+        if (!GmsCompat.isGmsCore()) {
+            // others handle this themselves
+            return null;
+        }
+
+        Activity activity = GmcActivityUtils.getMostRecentVisibleActivity();
+
+        if (activity != null) {
+            if (GmsCompat.hasPermission(Manifest.permission.BLUETOOTH_CONNECT)) {
+                activity.startActivity(new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE));
+            } else {
+                try {
+                    GmsCompatApp.iGms2Gca().showGmsCoreMissingNearbyDevicesPermissionGeneric();
+                } catch (RemoteException e) {
+                    GmsCompatApp.callFailed(e);
+                }
+            }
+        } // else don't bother the user
+
+        return Boolean.TRUE;
+    }
+
+    // BluetoothAdapter#setScanMode()
+    public static void makeBluetoothAdapterDiscoverable() {
+        // don't use BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE intent here, this method is often
+        // called at a time when the user wouldn't expect to see it
+        Log.d(TAG, "makeBluetoothAdapterDiscoverable", new Throwable());
+    }
+
+    // com.android.modules.utils.SynchronousResultReceiver.Result#getValue()
+    public static boolean interceptSynchronousResultReceiverException(@NonNull RuntimeException origException) {
+        if (!(origException instanceof SecurityException)) {
+            return false;
+        }
+
+        // origException contains service-side stack trace, need to obtain an app-side one
+        var stackTrace = new Throwable();
+        StubDef stub = StubDef.find(stackTrace.getStackTrace(), GmsHooks.config(), StubDef.FIND_MODE_SynchronousResultReceiver);
+
+        if (stub == null) {
+            return false;
+        }
+
+        if (stub.type != StubDef.DEFAULT) {
+            Log.d(TAG, "interceptSynchronousResultReceiverException: unexpected stub type " + stub.type, stackTrace);
+            return false;
+        }
+
+        if (Build.isDebuggable()) {
+            Log.i(TAG, "intercepted " + origException, stackTrace);
+        }
+
+        return true;
+    }
+
+    @Nullable
+    public static String deviceConfigGetProperty(@NonNull String namespace, @NonNull String name) {
+        return GmsCompatApp.getString(GmsCompatApp.deviceConfigNamespace(namespace), name);
+    }
+
+    public static boolean deviceConfigSetProperty(@NonNull String namespace, @NonNull String name, @Nullable String value) {
+        return GmsCompatApp.putString(GmsCompatApp.deviceConfigNamespace(namespace), name, value);
+    }
+
+    public static boolean deviceConfigSetProperties(@NonNull android.provider.DeviceConfig.Properties properties) {
+        return GmsCompatApp.setProperties(properties);
+    }
+
+    private GmsModuleHooks() {}
+}
diff --git a/core/java/android/app/compat/gms/GmsUtils.java b/core/java/android/app/compat/gms/GmsUtils.java
new file mode 100644
index 000000000000..e7fa4b9378ad
--- /dev/null
+++ b/core/java/android/app/compat/gms/GmsUtils.java
@@ -0,0 +1,20 @@
+package android.app.compat.gms;
+
+import android.annotation.NonNull;
+import android.annotation.SystemApi;
+import android.content.Intent;
+import android.ext.PackageId;
+import android.net.Uri;
+
+/** @hide */
+@SystemApi
+public class GmsUtils {
+
+    public static @NonNull Intent createAppPlayStoreIntent(@NonNull String pkgName) {
+        var i = new Intent(Intent.ACTION_VIEW, Uri.parse("market://details?id=" + pkgName));
+        i.setPackage(PackageId.PLAY_STORE_NAME);
+        return i;
+    }
+
+    private GmsUtils() {}
+}
diff --git a/core/java/android/app/usage/StorageStatsManager.java b/core/java/android/app/usage/StorageStatsManager.java
index a4b17537f4b2..fc4455d6a04c 100644
--- a/core/java/android/app/usage/StorageStatsManager.java
+++ b/core/java/android/app/usage/StorageStatsManager.java
@@ -24,6 +24,7 @@ import android.annotation.RequiresPermission;
 import android.annotation.SystemService;
 import android.annotation.TestApi;
 import android.annotation.WorkerThread;
+import android.app.compat.gms.GmsCompat;
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageInfo;
@@ -35,6 +36,9 @@ import android.os.UserHandle;
 import android.os.storage.CrateInfo;
 import android.os.storage.StorageManager;
 
+import com.android.internal.gmscompat.GmsInfo;
+import com.android.internal.gmscompat.PlayStoreHooks;
+
 import java.io.File;
 import java.io.IOException;
 import java.util.Collection;
@@ -207,6 +211,12 @@ public class StorageStatsManager {
     public @NonNull StorageStats queryStatsForPackage(@NonNull UUID storageUuid,
             @NonNull String packageName, @NonNull UserHandle user)
             throws PackageManager.NameNotFoundException, IOException {
+        if (GmsCompat.isPlayStore()) {
+            if (!GmsInfo.PACKAGE_PLAY_STORE.equals(packageName)) {
+                return PlayStoreHooks.queryStatsForPackage(packageName);
+            }
+        }
+
         try {
             return mService.queryStatsForPackage(convert(storageUuid), packageName,
                     user.getIdentifier(), mContext.getOpPackageName());
diff --git a/core/java/android/content/ContentResolver.java b/core/java/android/content/ContentResolver.java
index 9253998b325a..ab1a9b1fa5c6 100644
--- a/core/java/android/content/ContentResolver.java
+++ b/core/java/android/content/ContentResolver.java
@@ -31,6 +31,7 @@ import android.app.ActivityManager;
 import android.app.ActivityThread;
 import android.app.AppGlobals;
 import android.app.UriGrantsManager;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
@@ -71,6 +72,10 @@ import android.util.Size;
 import android.util.SparseArray;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.GmsCompatApp;
+import com.android.internal.gmscompat.GmsHooks;
+import com.android.internal.gmscompat.PlayStoreHooks;
+import com.android.internal.gmscompat.dynamite.GmsDynamiteClientHooks;
 import com.android.internal.util.MimeIconUtils;
 
 import dalvik.system.CloseGuard;
@@ -1241,6 +1246,10 @@ public abstract class ContentResolver implements ContentInterface {
                         queryArgs, remoteCancellationSignal);
             }
             if (qCursor == null) {
+                if (GmsCompat.isEnabled()) {
+                    return GmsHooks.maybeModifyQueryResult(uri, projection, queryArgs, null);
+                }
+
                 return null;
             }
 
@@ -1255,12 +1264,27 @@ public abstract class ContentResolver implements ContentInterface {
             final CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, provider);
             stableProvider = null;
             qCursor = null;
+
+            if (GmsCompat.isEnabled()) {
+                Cursor modified = GmsHooks.maybeModifyQueryResult(uri, projection, queryArgs, wrapper);
+                if (modified != null) {
+                    return modified;
+                }
+            }
+
             return wrapper;
         } catch (RemoteException e) {
             // Arbitrary and not worth documenting, as Activity
             // Manager will kill this process shortly anyway.
             return null;
-        } finally {
+        } catch (SecurityException se) {
+            if (GmsCompat.isEnabled()) {
+                Log.d("GmsCompat", "", se);
+                return null;
+            }
+            throw se;
+        }
+        finally {
             if (qCursor != null) {
                 qCursor.close();
             }
@@ -2193,6 +2217,9 @@ public abstract class ContentResolver implements ContentInterface {
     public final @Nullable Uri insert(@RequiresPermission.Write @NonNull Uri url,
             @Nullable ContentValues values, @Nullable Bundle extras) {
         Objects.requireNonNull(url, "url");
+        if (GmsCompat.isEnabled()) {
+            GmsHooks.filterContentValues(url, values);
+        }
 
         try {
             if (mWrapped != null) return mWrapped.insert(url, values, extras);
@@ -2490,6 +2517,8 @@ public abstract class ContentResolver implements ContentInterface {
         }
         final String auth = uri.getAuthority();
         if (auth != null) {
+            GmsDynamiteClientHooks.maybeInit(auth);
+
             return acquireProvider(mContext, auth);
         }
         return null;
@@ -2568,7 +2597,18 @@ public abstract class ContentResolver implements ContentInterface {
      */
     public final @Nullable ContentProviderClient acquireContentProviderClient(@NonNull Uri uri) {
         Objects.requireNonNull(uri, "uri");
-        IContentProvider provider = acquireProvider(uri);
+
+        IContentProvider provider;
+        try {
+            provider = acquireProvider(uri);
+        } catch (SecurityException se) {
+            if (GmsCompat.isEnabled()) {
+                Log.d("GmsCompat", "uri: " + uri, se);
+                return null;
+            }
+            throw se;
+        }
+
         if (provider != null) {
             return new ContentProviderClient(this, provider, uri.getAuthority(), true);
         }
@@ -2724,6 +2764,12 @@ public abstract class ContentResolver implements ContentInterface {
     @UnsupportedAppUsage
     public final void registerContentObserver(Uri uri, boolean notifyForDescendents,
             ContentObserver observer, @UserIdInt int userHandle) {
+        if (GmsCompat.isEnabled()) {
+            if (GmsCompatApp.registerObserver(uri, observer)) {
+                return;
+            }
+        }
+
         try {
             getContentService().registerContentObserver(uri, notifyForDescendents,
                     observer.getContentObserver(), userHandle, mTargetSdkVersion);
@@ -2740,6 +2786,13 @@ public abstract class ContentResolver implements ContentInterface {
      */
     public final void unregisterContentObserver(@NonNull ContentObserver observer) {
         Objects.requireNonNull(observer, "observer");
+
+        if (GmsCompat.isEnabled()) {
+            if (GmsCompatApp.unregisterObserver(observer)) {
+                return;
+            }
+        }
+
         try {
             IContentObserver contentObserver = observer.releaseContentObserver();
             if (contentObserver != null) {
diff --git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.java
index 7af0be3b3e75..a7d49ce7e92e 100644
--- a/core/java/android/content/Intent.java
+++ b/core/java/android/content/Intent.java
@@ -38,6 +38,7 @@ import android.app.Activity;
 import android.app.ActivityThread;
 import android.app.AppGlobals;
 import android.app.StatusBarManager;
+import android.app.compat.gms.GmsCompat;
 import android.bluetooth.BluetoothDevice;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.pm.ActivityInfo;
@@ -72,6 +73,7 @@ import android.provider.DocumentsContract;
 import android.provider.DocumentsProvider;
 import android.provider.MediaStore;
 import android.provider.OpenableColumns;
+import android.provider.Settings;
 import android.service.chooser.ChooserAction;
 import android.telecom.PhoneAccount;
 import android.telecom.TelecomManager;
@@ -9788,6 +9790,14 @@ public class Intent implements Parcelable, Cloneable {
      * @see #resolveActivityInfo
      */
     public ComponentName resolveActivity(@NonNull PackageManager pm) {
+        if (GmsCompat.isEnabled()) {
+            if (Settings.ACTION_SETTINGS_EMBED_DEEP_LINK_ACTIVITY.equals(getAction())) {
+                if (!GmsCompat.hasPermission(Manifest.permission.LAUNCH_MULTI_PANE_SETTINGS_DEEP_LINK)) {
+                    return null;
+                }
+            }
+        }
+
         if (mComponent != null) {
             return mComponent;
         }
diff --git a/core/java/android/content/pm/AppPermissionUtils.java b/core/java/android/content/pm/AppPermissionUtils.java
index 32333689235c..e1cd196cb269 100644
--- a/core/java/android/content/pm/AppPermissionUtils.java
+++ b/core/java/android/content/pm/AppPermissionUtils.java
@@ -18,8 +18,10 @@ package android.content.pm;
 
 import android.annotation.NonNull;
 import android.annotation.SystemApi;
+import android.app.compat.gms.GmsCompat;
 
 import com.android.internal.app.StorageScopesAppHooks;
+import com.android.internal.gmscompat.GmsHooks;
 
 /** @hide */
 @SystemApi
@@ -40,6 +42,12 @@ public class AppPermissionUtils {
             return true;
         }
 
+        if (GmsCompat.isEnabled()) {
+            if (GmsHooks.config().shouldSpoofSelfPermissionCheck(permName)) {
+                return true;
+            }
+        }
+
         return false;
     }
 
diff --git a/core/java/android/content/pm/CrossProfileApps.java b/core/java/android/content/pm/CrossProfileApps.java
index 529363f828bb..8f2e72ccc777 100644
--- a/core/java/android/content/pm/CrossProfileApps.java
+++ b/core/java/android/content/pm/CrossProfileApps.java
@@ -30,6 +30,7 @@ import android.app.Activity;
 import android.app.ActivityOptions;
 import android.app.AppOpsManager.Mode;
 import android.app.admin.DevicePolicyManager;
+import android.app.compat.gms.GmsCompat;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
@@ -307,6 +308,10 @@ public class CrossProfileApps {
      * @see UserManager#getUserProfiles()
      */
     public @NonNull List<UserHandle> getTargetUserProfiles() {
+        if (GmsCompat.isEnabled()) {
+            return java.util.Collections.emptyList();
+        }
+
         try {
             return mService.getTargetUserProfiles(mContext.getPackageName());
         } catch (RemoteException ex) {
@@ -439,6 +444,10 @@ public class CrossProfileApps {
      * @return true if the calling package can request to interact across profiles.
      */
     public boolean canRequestInteractAcrossProfiles() {
+        if (GmsCompat.isEnabled()) {
+            return false;
+        }
+
         try {
             return mService.canRequestInteractAcrossProfiles(mContext.getPackageName());
         } catch (RemoteException ex) {
@@ -470,6 +479,10 @@ public class CrossProfileApps {
      * calling UID.
      */
     public boolean canInteractAcrossProfiles() {
+        if (GmsCompat.isEnabled()) {
+            return false;
+        }
+
         try {
             return mService.canInteractAcrossProfiles(mContext.getPackageName());
         } catch (RemoteException ex) {
diff --git a/core/java/android/content/pm/IPackageInstallerSession.aidl b/core/java/android/content/pm/IPackageInstallerSession.aidl
index ea69a2b178dd..697510fd4743 100644
--- a/core/java/android/content/pm/IPackageInstallerSession.aidl
+++ b/core/java/android/content/pm/IPackageInstallerSession.aidl
@@ -73,4 +73,6 @@ interface IPackageInstallerSession {
     ParcelFileDescriptor getAppMetadataFd();
     ParcelFileDescriptor openWriteAppMetadata();
     void removeAppMetadata();
+
+    long getSilentUpdateWaitMillis();
 }
diff --git a/core/java/android/content/pm/PackageInstaller.java b/core/java/android/content/pm/PackageInstaller.java
index 0e131b413d0c..d6bb031e0b60 100644
--- a/core/java/android/content/pm/PackageInstaller.java
+++ b/core/java/android/content/pm/PackageInstaller.java
@@ -48,6 +48,7 @@ import android.app.ActivityManager;
 import android.app.ActivityThread;
 import android.app.AppGlobals;
 import android.app.PendingIntent;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.BroadcastReceiver;
 import android.content.Context;
@@ -75,6 +76,7 @@ import android.os.ParcelableException;
 import android.os.PersistableBundle;
 import android.os.RemoteCallback;
 import android.os.RemoteException;
+import android.os.SystemClock;
 import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.system.ErrnoException;
@@ -83,8 +85,10 @@ import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.ExceptionUtils;
+import android.util.Log;
 
 import com.android.internal.content.InstallLocationUtils;
+import com.android.internal.gmscompat.PlayStoreHooks;
 import com.android.internal.util.ArrayUtils;
 import com.android.internal.util.DataClass;
 import com.android.internal.util.IndentingPrintWriter;
@@ -791,6 +795,10 @@ public class PackageInstaller {
      *         session is finalized. IDs are not reused during a given boot.
      */
     public int createSession(@NonNull SessionParams params) throws IOException {
+        if (GmsCompat.isPlayStore()) {
+            PlayStoreHooks.adjustSessionParams(params);
+        }
+
         try {
             return mInstaller.createSession(params, mInstallerPackageName, mAttributionTag,
                     mUserId);
@@ -1960,6 +1968,26 @@ public class PackageInstaller {
          * @see #requestUserPreapproval
          */
         public void commit(@NonNull IntentSender statusReceiver) {
+            if (GmsCompat.isPlayStore()) {
+                long waitMs = 0;
+                try {
+                    waitMs = mSession.getSilentUpdateWaitMillis();
+                } catch (Exception e) {
+                    // getSilentUpdateWaitMillis() will fail if Play Store didn't set packageName
+                    // of this session. It always does currently AFAIK (September 2022)
+                    Log.e("GmsCompat", "", e);
+                }
+
+                if (waitMs > 0) {
+                    // Should happen only if the same package is updated twice within 30 seconds
+                    // (likely a Play Store bug, possibly related to APK splits)
+                    Log.d("GmsCompat", "PackageInstaller.Session.getSilentUpdateWaitMillis returned " + waitMs + ", sleeping...");
+                    SystemClock.sleep(waitMs + 100);
+                }
+
+                statusReceiver = PlayStoreHooks.wrapCommitStatusReceiver(this, statusReceiver);
+            }
+
             try {
                 mSession.commit(statusReceiver, false);
             } catch (RemoteException e) {
@@ -2700,6 +2728,12 @@ public class PackageInstaller {
         public IntentSender unarchiveIntentSender;
 
         private final ArrayMap<String, Integer> mPermissionStates;
+        /**
+         * {@hide}
+         *
+         *  Used only by gmscompat, to disallow updates to unknown versions of GmsCore and Play Store.
+         */
+        public long maxAllowedVersion = Long.MAX_VALUE;
 
         /**
          * Construct parameters for a new package install session.
@@ -2711,6 +2745,10 @@ public class PackageInstaller {
         public SessionParams(int mode) {
             this.mode = mode;
             mPermissionStates = new ArrayMap<>();
+            if (GmsCompat.isPlayStore()) {
+                // called here instead of in createSession() to give Play Store a chance to override
+                setRequireUserAction(USER_ACTION_NOT_REQUIRED);
+            }
         }
 
         /** {@hide} */
@@ -2751,6 +2789,7 @@ public class PackageInstaller {
             developmentInstallFlags = source.readInt();
             unarchiveId = source.readInt();
             unarchiveIntentSender = source.readParcelable(null, IntentSender.class);
+            maxAllowedVersion = source.readLong();
         }
 
         /** {@hide} */
@@ -2786,6 +2825,7 @@ public class PackageInstaller {
             ret.developmentInstallFlags = developmentInstallFlags;
             ret.unarchiveId = unarchiveId;
             ret.unarchiveIntentSender = unarchiveIntentSender;
+            ret.maxAllowedVersion = maxAllowedVersion;
             return ret;
         }
 
@@ -3541,6 +3581,7 @@ public class PackageInstaller {
             dest.writeInt(developmentInstallFlags);
             dest.writeInt(unarchiveId);
             dest.writeParcelable(unarchiveIntentSender, flags);
+            dest.writeLong(maxAllowedVersion);
         }
 
         public static final Parcelable.Creator<SessionParams>
diff --git a/core/java/android/content/pm/PackageManager.java b/core/java/android/content/pm/PackageManager.java
index 87a84d9ad08f..27b29a7136d4 100644
--- a/core/java/android/content/pm/PackageManager.java
+++ b/core/java/android/content/pm/PackageManager.java
@@ -1794,6 +1794,7 @@ public abstract class PackageManager {
     @IntDef(flag = true, value = {
             DONT_KILL_APP,
             SYNCHRONOUS,
+            SKIP_IF_MISSING,
     })
     @Retention(RetentionPolicy.SOURCE)
     public @interface EnabledFlags {}
@@ -1815,6 +1816,9 @@ public abstract class PackageManager {
      */
     public static final int SYNCHRONOUS = 0x00000002;
 
+    /** @hide */
+    public static final int SKIP_IF_MISSING = 0x4000_0000;
+
     /** @hide */
     @IntDef(flag = true, value = {
             FLAG_SUSPEND_QUARANTINED,
diff --git a/core/java/android/content/res/ApkAssets.java b/core/java/android/content/res/ApkAssets.java
index 653e243f5e06..9849075d1d22 100644
--- a/core/java/android/content/res/ApkAssets.java
+++ b/core/java/android/content/res/ApkAssets.java
@@ -25,6 +25,7 @@ import android.content.res.loader.ResourcesProvider;
 import android.text.TextUtils;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.dynamite.GmsDynamiteClientHooks;
 
 import dalvik.annotation.optimization.CriticalNative;
 
@@ -149,7 +150,7 @@ public final class ApkAssets {
      */
     public static @NonNull ApkAssets loadFromPath(@NonNull String path, @PropertyFlags int flags)
             throws IOException {
-        return new ApkAssets(FORMAT_APK, path, flags, null /* assets */);
+        return loadFromPath(path, flags, null);
     }
 
     /**
@@ -163,6 +164,13 @@ public final class ApkAssets {
      */
     public static @NonNull ApkAssets loadFromPath(@NonNull String path, @PropertyFlags int flags,
             @Nullable AssetsProvider assets) throws IOException {
+        if (GmsDynamiteClientHooks.enabled()) {
+            ApkAssets apkAssets = GmsDynamiteClientHooks.loadAssetsFromPath(path, flags, assets);
+            if (apkAssets != null) {
+                return apkAssets;
+            }
+        }
+
         return new ApkAssets(FORMAT_APK, path, flags, assets);
     }
 
diff --git a/core/java/android/database/sqlite/SQLiteOpenHelper.java b/core/java/android/database/sqlite/SQLiteOpenHelper.java
index 5e523c0112b1..a2a325866cdd 100644
--- a/core/java/android/database/sqlite/SQLiteOpenHelper.java
+++ b/core/java/android/database/sqlite/SQLiteOpenHelper.java
@@ -19,6 +19,7 @@ package android.database.sqlite;
 import android.annotation.IntRange;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.Context;
 import android.database.DatabaseErrorHandler;
@@ -27,6 +28,8 @@ import android.database.sqlite.SQLiteDatabase.CursorFactory;
 import android.os.FileUtils;
 import android.util.Log;
 
+import com.android.internal.gmscompat.GmsHooks;
+
 import java.io.File;
 import java.util.Objects;
 
@@ -168,6 +171,10 @@ public abstract class SQLiteOpenHelper implements AutoCloseable {
         mNewVersion = version;
         mMinimumSupportedVersion = Math.max(0, minimumSupportedVersion);
         setOpenParamsBuilder(openParamsBuilder);
+
+        if (GmsCompat.isEnabled()) {
+            GmsHooks.onSQLiteOpenHelperConstructed(this, context);
+        }
     }
 
     /**
diff --git a/core/java/android/ext/AppInfoExt.java b/core/java/android/ext/AppInfoExt.java
index 4807f5d3db6c..5fd4182ca3fb 100644
--- a/core/java/android/ext/AppInfoExt.java
+++ b/core/java/android/ext/AppInfoExt.java
@@ -18,6 +18,8 @@ public final class AppInfoExt implements Parcelable {
     public static final long HAS_COMPAT_CHANGES = 1L << 63;
     private final long compatChanges;
 
+    public static final int FLAG_HAS_GMSCORE_CLIENT_LIBRARY = 0;
+
     public AppInfoExt(int packageId, int flags, long compatChanges) {
         this.packageId = packageId;
         this.flags = flags;
diff --git a/core/java/android/nfc/NfcAdapter.java b/core/java/android/nfc/NfcAdapter.java
index 98a980f5e7f8..ba4f5553cba9 100644
--- a/core/java/android/nfc/NfcAdapter.java
+++ b/core/java/android/nfc/NfcAdapter.java
@@ -29,6 +29,7 @@ import android.annotation.SystemApi;
 import android.annotation.UserIdInt;
 import android.app.Activity;
 import android.app.PendingIntent;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.Context;
 import android.content.IntentFilter;
@@ -46,6 +47,8 @@ import android.os.IBinder;
 import android.os.RemoteException;
 import android.util.Log;
 
+import com.android.internal.gmscompat.GmsHooks;
+
 import java.io.IOException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -986,6 +989,13 @@ public final class NfcAdapter {
     @SystemApi
     @RequiresPermission(android.Manifest.permission.WRITE_SECURE_SETTINGS)
     public boolean enable() {
+        if (GmsCompat.isEnabled()) {
+            if (!GmsCompat.hasPermission(android.Manifest.permission.WRITE_SECURE_SETTINGS)) {
+                GmsHooks.enableNfc();
+                return false;
+            }
+        }
+
         try {
             return sService.enable();
         } catch (RemoteException e) {
diff --git a/core/java/android/os/Binder.java b/core/java/android/os/Binder.java
index 02e40cfbecaa..8a420c58f96a 100644
--- a/core/java/android/os/Binder.java
+++ b/core/java/android/os/Binder.java
@@ -20,12 +20,14 @@ import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.SystemApi;
 import android.app.AppOpsManager;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.util.ExceptionUtils;
 import android.util.Log;
 import android.util.Slog;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.os.BinderCallHeavyHitterWatcher;
 import com.android.internal.os.BinderCallHeavyHitterWatcher.BinderCallHeavyHitterListener;
 import com.android.internal.os.BinderInternal;
@@ -835,8 +837,18 @@ public class Binder implements IBinder {
     public void attachInterface(@Nullable IInterface owner, @Nullable String descriptor) {
         mOwner = owner;
         mDescriptor = descriptor;
+
+        // Interface that is used when obtaining a binder from GmsCore
+        mIsIGmsCallbacks = "com.google.android.gms.common.internal.IGmsCallbacks".equals(descriptor);
+
+        if (GmsCompat.isGmsCore()) {
+            mIsGmsServiceBroker = GmsHooks.GMS_SERVICE_BROKER_INTERFACE_DESCRIPTOR.equals(descriptor);
+        }
     }
 
+    private boolean mIsIGmsCallbacks;
+    private boolean mIsGmsServiceBroker;
+
     /**
      * Default implementation returns an empty interface name.
      */
@@ -1416,10 +1428,22 @@ public class Binder implements IBinder {
         sWorkSourceProvider = workSourceProvider;
     }
 
+    private volatile int mPreviousUid;
+
     // Entry point from android_util_Binder.cpp's onTransact.
     @UnsupportedAppUsage
     private boolean execTransact(int code, long dataObj, long replyObj,
             int flags) {
+        final int binderCallingUid = Binder.getCallingUid();
+        if (GmsCompat.isEnabled()) {
+            if (binderCallingUid != mPreviousUid) {
+                // harmless race
+                mPreviousUid = binderCallingUid;
+                if (Process.isApplicationUid(binderCallingUid)) {
+                    GmsHooks.onBinderTransaction(Binder.getCallingPid(), binderCallingUid);
+                }
+            }
+        }
 
         Parcel data = Parcel.obtain(dataObj);
         Parcel reply = Parcel.obtain(replyObj);
@@ -1432,7 +1456,7 @@ public class Binder implements IBinder {
         // for Java now
         //
         // This attribution support is not generic and therefore not support in RPC mode
-        final int callingUid = data.isForRpc() ? -1 : Binder.getCallingUid();
+        final int callingUid = data.isForRpc() ? -1 : binderCallingUid;
         final long origWorkSource = callingUid == -1
                 ? -1 : ThreadLocalWorkSource.setUid(callingUid);
 
@@ -1475,7 +1499,12 @@ public class Binder implements IBinder {
         }
 
         final boolean tracingEnabled = tagEnabled && transactionTraceName != null;
+        data.mCallMaybeOverrideBinder = mIsIGmsCallbacks;
+        boolean onBeginGmsServiceBrokerCallRet = false;
         try {
+            if (mIsGmsServiceBroker) {
+                onBeginGmsServiceBrokerCallRet = GmsHooks.onBeginGmsServiceBrokerCall(code, data);
+            }
             // TODO(b/299356201) - this logic should not be in Java - it should be in native
             // code in libbinder so that it works for all binder users.
             final BinderCallHeavyHitterWatcher heavyHitterWatcher = sHeavyHitterWatcher;
@@ -1521,6 +1550,10 @@ public class Binder implements IBinder {
             }
             res = true;
         } finally {
+            data.mCallMaybeOverrideBinder = false;
+            if (onBeginGmsServiceBrokerCallRet) {
+                GmsHooks.onEndGmsServiceBrokerCall();
+            }
             if (tracingEnabled) {
                 Trace.traceEnd(Trace.TRACE_TAG_AIDL);
             }
diff --git a/core/java/android/os/BinderDef.aidl b/core/java/android/os/BinderDef.aidl
new file mode 100644
index 000000000000..6b55861e809a
--- /dev/null
+++ b/core/java/android/os/BinderDef.aidl
@@ -0,0 +1,3 @@
+package android.os;
+
+parcelable BinderDef;
diff --git a/core/java/android/os/BinderDef.java b/core/java/android/os/BinderDef.java
new file mode 100644
index 000000000000..f846f3ed0f73
--- /dev/null
+++ b/core/java/android/os/BinderDef.java
@@ -0,0 +1,102 @@
+package android.os;
+
+import android.annotation.Nullable;
+import android.content.Context;
+import android.util.ArrayMap;
+import android.util.Log;
+
+import java.lang.reflect.Constructor;
+
+import dalvik.system.DexClassLoader;
+
+/**
+ * Definition of a binder in another Android package.
+ *
+ * @hide
+ */
+public class BinderDef implements Parcelable {
+    private static final String TAG = BinderDef.class.getSimpleName();
+
+    public final String interfaceName; // also referred to as "interface descriptor"
+    public final String apkPath;
+    public final String className;
+    // Sorted array of handled binder transactions codes, null means "all transactions are handled"
+    @Nullable public final int[] transactionCodes;
+
+    public BinderDef(String interfaceName, String apkPath, String className, @Nullable int[] transactionCodes) {
+        this.interfaceName = interfaceName;
+        this.apkPath = apkPath;
+        this.className = className;
+        this.transactionCodes = transactionCodes;
+    }
+
+    protected BinderDef(Parcel in) {
+        interfaceName = in.readString();
+        apkPath = in.readString();
+        className = in.readString();
+        transactionCodes = in.createIntArray();
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(interfaceName);
+        dest.writeString(apkPath);
+        dest.writeString(className);
+        dest.writeIntArray(transactionCodes);
+    }
+
+    private volatile IBinder instance;
+
+    @Nullable
+    public IBinder getInstance(Context ctx) {
+        { IBinder cache = instance; if (cache != null) return cache; }
+
+        synchronized (this) {
+            { IBinder cache = instance; if (cache != null) return cache; }
+            try {
+                return instance = instantiate(ctx);
+            } catch (ReflectiveOperationException e) {
+                Log.e(TAG, "unable to instantiate " + className + " from " + apkPath, e);
+                return null;
+            }
+        }
+    }
+
+    private IBinder instantiate(Context ctx) throws ReflectiveOperationException {
+        Class cls = getDexClassLoader().loadClass(className);
+        Constructor constructor = cls.getConstructor(Context.class);
+
+        return (IBinder) constructor.newInstance(ctx);
+    }
+
+    private static final ArrayMap<String, DexClassLoader> classLoaders = new ArrayMap<>();
+
+    private DexClassLoader getDexClassLoader() {
+        final var map = classLoaders;
+        synchronized (map) {
+            DexClassLoader cl = map.get(apkPath);
+            if (cl == null) {
+                cl = new DexClassLoader(apkPath, null, null, String.class.getClassLoader());
+                map.put(apkPath, cl);
+            }
+            return cl;
+        }
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    public static final Creator<BinderDef> CREATOR = new Creator<BinderDef>() {
+        @Override
+        public BinderDef createFromParcel(Parcel in) {
+            return new BinderDef(in);
+        }
+
+        @Override
+        public BinderDef[] newArray(int size) {
+            return new BinderDef[size];
+        }
+    };
+}
diff --git a/core/java/android/os/Build.java b/core/java/android/os/Build.java
index a9b7257a5406..588241833fb3 100755
--- a/core/java/android/os/Build.java
+++ b/core/java/android/os/Build.java
@@ -26,6 +26,7 @@ import android.annotation.SystemApi;
 import android.annotation.TestApi;
 import android.app.ActivityThread;
 import android.app.Application;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.Context;
 import android.sysprop.DeviceProperties;
@@ -36,6 +37,8 @@ import android.util.ArraySet;
 import android.util.Slog;
 import android.view.View;
 
+import com.android.internal.gmscompat.GmsHooks;
+
 import dalvik.system.VMRuntime;
 
 import java.util.ArrayList;
@@ -256,6 +259,16 @@ public class Build {
     @SuppressAutoDoc // No support for device / profile owner.
     @RequiresPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
     public static String getSerial() {
+        if (GmsCompat.isEnabled()) {
+            boolean shouldHook =
+                    !GmsCompat.hasPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)
+                    && !GmsCompat.hasPermission(Manifest.permission.READ_DEVICE_SERIAL_NUMBER);
+
+            if (shouldHook) {
+                return GmsHooks.getSerial();
+            }
+        }
+
         IDeviceIdentifiersPolicyService service = IDeviceIdentifiersPolicyService.Stub
                 .asInterface(ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE));
         try {
diff --git a/core/java/android/os/HybridBinder.java b/core/java/android/os/HybridBinder.java
new file mode 100644
index 000000000000..0776baebc18a
--- /dev/null
+++ b/core/java/android/os/HybridBinder.java
@@ -0,0 +1,85 @@
+package android.os;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.content.Context;
+import android.util.Log;
+
+import java.io.FileDescriptor;
+import java.util.Arrays;
+
+/**
+ * Fuses two binders together.
+ * Transaction routing decisions are made by looking at transaction codes.
+ * The rest of operations are forwarded to the first ("original") binder.
+ *
+ * @hide
+ */
+public final class HybridBinder implements IBinder {
+    private static final String TAG = "HybridBinder";
+    private static final boolean DEBUG = Log.isLoggable(TAG, Log.VERBOSE);
+
+    private final IBinder original;
+    private final IBinder secondBinder;
+    // sorted array of handled transactions codes
+    private final int[] secondBinderTxnCodes;
+
+    public HybridBinder(Context ctx, IBinder original, BinderDef secondBinderDef) {
+        this.original = original;
+        this.secondBinder = secondBinderDef.getInstance(ctx);
+        this.secondBinderTxnCodes = secondBinderDef.transactionCodes;
+    }
+
+    public boolean transact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException {
+        if (DEBUG) {
+            Log.d(TAG, "call " + (code - IBinder.FIRST_CALL_TRANSACTION));
+        }
+        if (Arrays.binarySearch(secondBinderTxnCodes, code) >= 0) {
+            return secondBinder.transact(code, data, reply, flags);
+        }
+        return original.transact(code, data, reply, flags);
+    }
+
+    @Nullable
+    public IInterface queryLocalInterface(@NonNull String descriptor) {
+        return null;
+    }
+
+    @Nullable
+    public String getInterfaceDescriptor() throws RemoteException {
+        return original.getInterfaceDescriptor();
+    }
+
+    public boolean pingBinder() {
+        return original.pingBinder();
+    }
+
+    public boolean isBinderAlive() {
+        return original.isBinderAlive();
+    }
+
+    public void dump(@NonNull FileDescriptor fd, @Nullable String[] args) throws RemoteException {
+        original.dump(fd, args);
+    }
+
+    public void dumpAsync(@NonNull FileDescriptor fd, @Nullable String[] args) throws RemoteException {
+        original.dumpAsync(fd, args);
+    }
+
+    public void shellCommand(@Nullable FileDescriptor in, @Nullable FileDescriptor out, @Nullable FileDescriptor err, @NonNull String[] args, @Nullable ShellCallback shellCallback, @NonNull ResultReceiver resultReceiver) throws RemoteException {
+        original.shellCommand(in, out, err, args, shellCallback, resultReceiver);
+    }
+
+    public void linkToDeath(@NonNull DeathRecipient recipient, int flags) throws RemoteException {
+        original.linkToDeath(recipient, flags);
+    }
+
+    public boolean unlinkToDeath(@NonNull DeathRecipient recipient, int flags) {
+        return original.unlinkToDeath(recipient, flags);
+    }
+
+    @Nullable
+    public IBinder getExtension() throws RemoteException {
+        return original.getExtension();
+    }
+}
diff --git a/core/java/android/os/Parcel.java b/core/java/android/os/Parcel.java
index 8e860c35388d..f8014e469815 100644
--- a/core/java/android/os/Parcel.java
+++ b/core/java/android/os/Parcel.java
@@ -26,6 +26,7 @@ import android.annotation.Nullable;
 import android.annotation.SuppressLint;
 import android.annotation.TestApi;
 import android.app.AppOpsManager;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.ravenwood.annotation.RavenwoodKeepWholeClass;
 import android.ravenwood.annotation.RavenwoodNativeSubstitutionClass;
@@ -46,6 +47,7 @@ import android.util.SparseBooleanArray;
 import android.util.SparseIntArray;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.GmsHooks;
 import com.android.internal.util.ArrayUtils;
 
 import dalvik.annotation.optimization.CriticalNative;
@@ -3153,6 +3155,13 @@ public final class Parcel {
                     "Remote stack trace:\n" + remoteStackTrace, null, false, false);
             ExceptionUtils.appendCause(e, cause);
         }
+
+        if (GmsCompat.isEnabled()) {
+            if (GmsHooks.interceptException(e, this)) {
+                return;
+            }
+        }
+
         SneakyThrow.sneakyThrow(e);
     }
 
@@ -3285,6 +3294,9 @@ public final class Parcel {
         return TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(this);
     }
 
+    /** {@hide} */
+    public boolean mCallMaybeOverrideBinder;
+
     /**
      * Read an object from the parcel at the current dataPosition().
      */
@@ -3297,6 +3309,14 @@ public final class Parcel {
                 FLAG_IS_REPLY_FROM_BLOCKING_ALLOWED_OBJECT | FLAG_PROPAGATE_ALLOW_BLOCKING)) {
             Binder.allowBlocking(result);
         }
+
+        if (mCallMaybeOverrideBinder && result != null) {
+            IBinder override = GmsHooks.maybeOverrideBinder(result);
+            if (override != null) {
+                return override;
+            }
+        }
+
         return result;
     }
 
diff --git a/core/java/android/os/UserHandle.java b/core/java/android/os/UserHandle.java
index 0644ef1c788f..82825d5ae3d8 100644
--- a/core/java/android/os/UserHandle.java
+++ b/core/java/android/os/UserHandle.java
@@ -22,6 +22,7 @@ import android.annotation.Nullable;
 import android.annotation.SystemApi;
 import android.annotation.TestApi;
 import android.annotation.UserIdInt;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.util.SparseArray;
 
@@ -574,6 +575,10 @@ public final class UserHandle implements Parcelable {
     @Deprecated
     @SystemApi
     public boolean isOwner() {
+        if (GmsCompat.isEnabled()) {
+            return isSystem();
+        }
+
         return this.equals(OWNER);
     }
 
@@ -583,6 +588,11 @@ public final class UserHandle implements Parcelable {
      */
     @SystemApi
     public boolean isSystem() {
+        if (GmsCompat.isEnabled()) {
+            // "system" user means "primary" ("Owner") user
+            return true;
+        }
+
         return this.equals(SYSTEM);
     }
 
diff --git a/core/java/android/os/UserManager.java b/core/java/android/os/UserManager.java
index 1994cd740c85..ce92b56f5232 100644
--- a/core/java/android/os/UserManager.java
+++ b/core/java/android/os/UserManager.java
@@ -3194,8 +3194,8 @@ public class UserManager {
         return getProfileType(mUserId);
     }
 
-    /** @see #getProfileType() */
-    private @Nullable String getProfileType(@UserIdInt int userId) {
+    /** @hide */
+    protected @Nullable String getProfileType(@UserIdInt int userId) {
         // First, the typical case (i.e. the *process* user, not necessarily the context user).
         // This cache cannot be become invalidated since it's about the calling process itself.
         if (userId == UserHandle.myUserId()) {
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 64d48d990f4f..e25c242e45a9 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -41,6 +41,7 @@ import android.app.NotificationChannel;
 import android.app.NotificationManager;
 import android.app.SearchManager;
 import android.app.WallpaperManager;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.ComponentName;
 import android.content.ContentResolver;
@@ -101,6 +102,7 @@ import android.view.WindowManager.LayoutParams;
 import android.widget.Editor;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.GmsCompatApp;
 import com.android.internal.util.Preconditions;
 
 import java.io.IOException;
@@ -3299,9 +3301,31 @@ public final class Settings {
                     mReadableFieldsWithMaxTargetSdk);
         }
 
+        // Returns last path component of the relevant Uri.
+        // Keep in sync with GmsCompatApp#registerObserver
+        private String maybeGetGmsCompatNamespace() {
+            Uri uri = mUri;
+            // no need to use expensive equals() method in this case
+            if (uri == Global.CONTENT_URI) {
+                return "global";
+            }
+            if (uri == Secure.CONTENT_URI) {
+                return "secure";
+            }
+            return null;
+        }
+
         public boolean putStringForUser(ContentResolver cr, String name, String value,
                 String tag, boolean makeDefault, final int userHandle,
                 boolean overrideableByRestore) {
+            if (GmsCompat.isEnabled()) {
+                String ns = maybeGetGmsCompatNamespace();
+                if (ns != null && !mAllFields.contains(name)) {
+                    return GmsCompatApp.putString(ns, name, value);
+                }
+                return false;
+            }
+
             try {
                 Bundle arg = new Bundle();
                 arg.putString(Settings.NameValueTable.VALUE, value);
@@ -3362,6 +3386,15 @@ public final class Settings {
 
         @UnsupportedAppUsage
         public String getStringForUser(ContentResolver cr, String name, final int userHandle) {
+            if (GmsCompat.isEnabled()) {
+                String ns = maybeGetGmsCompatNamespace();
+                if (ns != null) {
+                    if (!mAllFields.contains(name) && !name.startsWith("gmscompat")) {
+                        return GmsCompatApp.getString(ns, name);
+                    }
+                }
+            }
+
             final boolean isSelf = (userHandle == UserHandle.myUserId());
             final boolean useCache = isSelf && !isInSystemServer();
             boolean needsGenerationTracker = false;
@@ -3409,6 +3442,10 @@ public final class Settings {
             // still be regarded as readable.
             if (!isCallerExemptFromReadableRestriction() && mAllFields.contains(name)) {
                 if (!mReadableFields.contains(name)) {
+                    if (GmsCompat.isEnabled()) {
+                        return null;
+                    }
+
                     throw new SecurityException(
                             "Settings key: <" + name + "> is not readable. From S+, settings keys "
                                     + "annotated with @hide are restricted to system_server and "
@@ -3425,6 +3462,10 @@ public final class Settings {
                                 && application.getApplicationInfo().targetSdkVersion
                                 <= maxTargetSdk;
                         if (!targetSdkCheckOk) {
+                            if (GmsCompat.isEnabled()) {
+                                return null;
+                            }
+
                             throw new SecurityException(
                                     "Settings key: <" + name + "> is only readable to apps with "
                                             + "targetSdkVersion lower than or equal to: "
@@ -6618,6 +6659,11 @@ public final class Settings {
                 sProviderHolder,
                 Secure.class);
 
+        /** @hide */
+        public static boolean isKnownKey(String key) {
+            return sNameValueCache.mAllFields.contains(key);
+        }
+
         @UnsupportedAppUsage
         private static final HashSet<String> MOVED_TO_LOCK_SETTINGS;
         @UnsupportedAppUsage
@@ -17454,6 +17500,11 @@ public final class Settings {
                     sProviderHolder,
                     Global.class);
 
+        /** @hide */
+        public static boolean isKnownKey(String key) {
+            return sNameValueCache.mAllFields.contains(key);
+        }
+
         // Certain settings have been moved from global to the per-user secure namespace
         @UnsupportedAppUsage
         private static final HashSet<String> MOVED_TO_SECURE;
diff --git a/core/java/android/telephony/TelephonyRegistryManager.java b/core/java/android/telephony/TelephonyRegistryManager.java
index 886727ea43ef..78ac2bc30416 100644
--- a/core/java/android/telephony/TelephonyRegistryManager.java
+++ b/core/java/android/telephony/TelephonyRegistryManager.java
@@ -19,6 +19,7 @@ import android.annotation.CallbackExecutor;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.RequiresPermission;
+import android.app.compat.gms.GmsCompat;
 import android.compat.Compatibility;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledAfter;
@@ -45,6 +46,7 @@ import android.util.ArraySet;
 import android.util.Log;
 
 import com.android.internal.annotations.GuardedBy;
+import com.android.internal.gmscompat.sysservice.GmcTelephonyManager;
 import com.android.internal.listeners.ListenerExecutor;
 import com.android.internal.telephony.ICarrierConfigChangeListener;
 import com.android.internal.telephony.ICarrierPrivilegesCallback;
@@ -273,6 +275,13 @@ public class TelephonyRegistryManager {
             } else if (listener.mSubId != null) {
                 subId = listener.mSubId;
             }
+
+            if (GmsCompat.isEnabled()) {
+                eventsList = GmcTelephonyManager.filterTelephonyCallbackEvents(eventsList);
+                // empty eventsList means "unregister the listener". It's fine if eventsList becomes
+                // empty after filtering, unregistration of a never-registered listener is allowed.
+            }
+
             sRegistry.listenWithEventList(renounceFineLocationAccess, renounceCoarseLocationAccess,
                     subId, pkg, featureId, listener.callback, eventsList, notifyNow);
         } catch (RemoteException e) {
@@ -294,6 +303,13 @@ public class TelephonyRegistryManager {
             @NonNull String pkg, @NonNull String featureId,
             @NonNull TelephonyCallback telephonyCallback, @NonNull int[] events,
             boolean notifyNow) {
+
+        if (GmsCompat.isEnabled()) {
+            events = GmcTelephonyManager.filterTelephonyCallbackEvents(events);
+            // empty events array means "unregister the listener". It's fine if events array becomes
+            // empty after filtering, unregistration of a never-registered listener is allowed.
+        }
+
         try {
             sRegistry.listenWithEventList(renounceFineLocationAccess, renounceCoarseLocationAccess,
                     subId, pkg, featureId, telephonyCallback.callback, events, notifyNow);
diff --git a/core/java/com/android/internal/gmscompat/BinderGca2Gms.java b/core/java/com/android/internal/gmscompat/BinderGca2Gms.java
new file mode 100644
index 000000000000..0fd6cd98f76a
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/BinderGca2Gms.java
@@ -0,0 +1,118 @@
+package com.android.internal.gmscompat;
+
+import android.app.Activity;
+import android.app.compat.gms.GmsCompat;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Intent;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.net.Uri;
+import android.util.ArraySet;
+import android.util.Log;
+
+import com.android.internal.gmscompat.util.GmcActivityUtils;
+
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+
+import static com.android.internal.gmscompat.GmsHooks.inPersistentGmsCoreProcess;
+import static com.android.internal.gmscompat.GmsInfo.PACKAGE_GMS_CORE;
+
+// see IGca2Gms
+class BinderGca2Gms extends IGca2Gms.Stub {
+    private static final String TAG = "BinderGca2Gms";
+    private static final boolean DEV = false;
+
+    @Override
+    public void updateConfig(GmsCompatConfig newConfig) {
+        GmsHooks.setConfig(newConfig);
+    }
+
+    @Override
+    public void invalidateConfigCaches() {
+        if (!inPersistentGmsCoreProcess) {
+            throw new IllegalStateException();
+        }
+
+        SQLiteOpenHelper phenotypeDb = GmsHooks.getPhenotypeDb();
+
+        if (phenotypeDb == null) {
+            // shouldn't happen in practice, phenotype db is opened on startup
+            Log.e(TAG, "phenotypeDb is null");
+        } else {
+            updatePhenotype(phenotypeDb, GmsHooks.config());
+        }
+
+        // Gservices flags are hosted by GservicesProvider ContentProvider in
+        // "Google Services Framework" app.
+        // Its clients register change listeners via
+        // BroadcastReceivers (com.google.gservices.intent.action.GSERVICES_CHANGED) and
+        // ContentResolver#registerContentObserver().
+        // Code below performs a delete of a non-existing key (key is chosen randomly).
+        // GSF will notify all of its listeners after this operation, despite database remaining
+        // unchanged. There's no other simple way to achieve the same effect (AFAIK).
+        //
+        // Additional values from GmsCompatConfig will be added only inside client's processes,
+        // database inside GSF remains unchanged.
+
+        ContentResolver cr = GmsCompat.appContext().getContentResolver();
+        ContentValues cv = new ContentValues();
+        cv.put("iquee6jo8ooquoomaeraip7gah4shee8phiet0Ahng0yeipei3", (String) null);
+
+        Uri gservicesUri = Uri.parse("content://" + GmsInfo.PACKAGE_GSF + ".gservices/override");
+        cr.update(gservicesUri, cv, null, null);
+    }
+
+    private static void updatePhenotype(SQLiteOpenHelper phenotypeDb, GmsCompatConfig newConfig) {
+        SQLiteDatabase db = phenotypeDb.getReadableDatabase();
+        String[] columns = { "androidPackageName" };
+        String selection = "packageName = ?";
+
+        ArraySet<String> configPackageNames = new ArraySet<>(newConfig.flags.keySet());
+        configPackageNames.addAll(newConfig.forceDefaultFlagsMap.keySet());
+
+        for (String configPackageName : configPackageNames) {
+            String[] selectionArgs = { configPackageName };
+            String packageName = null;
+            try (Cursor c = db.query("Packages", columns, selection, selectionArgs, null, null, null, "1")) {
+                if (c.moveToFirst()) {
+                    packageName = c.getString(0);
+                }
+            }
+
+            if (packageName == null) {
+                Log.d(TAG, "unknown configPackageName " + configPackageName);
+                continue;
+            }
+
+            Intent i = new Intent(PACKAGE_GMS_CORE + ".phenotype.UPDATE");
+            i.putExtra(PACKAGE_GMS_CORE + ".phenotype.PACKAGE_NAME", configPackageName);
+            i.setPackage(packageName);
+            GmsCompat.appContext().sendBroadcast(i);
+        }
+    }
+
+    @Override
+    public boolean startActivityIfVisible(Intent intent) {
+        Callable<Boolean> callable = () -> {
+            Activity activity = GmcActivityUtils.getMostRecentVisibleActivity();
+            if (activity == null) {
+                return false;
+            }
+            activity.startActivity(intent);
+            return true;
+        };
+        var task = new FutureTask<>(callable);
+        // getMostRecentVisibleActivity() needs to be called from main thread to avoid races
+        GmsCompat.appContext().getMainThreadHandler().post(task);
+        try {
+            return task.get().booleanValue();
+        } catch (InterruptedException | ExecutionException e) {
+            e.printStackTrace();
+            return false;
+        }
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/GmcBinderDefs.java b/core/java/com/android/internal/gmscompat/GmcBinderDefs.java
new file mode 100644
index 000000000000..6b88d67855ed
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/GmcBinderDefs.java
@@ -0,0 +1,111 @@
+package com.android.internal.gmscompat;
+
+import android.annotation.Nullable;
+import android.app.ActivityThread;
+import android.app.compat.gms.GmsCompat;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.BinderDef;
+import android.os.HybridBinder;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.ArrayMap;
+import android.util.ArraySet;
+import android.util.Log;
+
+public class GmcBinderDefs {
+    static final String TAG = GmcBinderDefs.class.getSimpleName();
+
+    private static final ArrayMap<String, BinderDef> seenInterfaces = new ArrayMap<>();
+
+    @Nullable
+    public static IBinder maybeOverrideBinder(IBinder originalBinder, String ifaceName) {
+        BinderDef bdef = maybeGetBinderDef(ifaceName);
+        if (bdef == null) {
+            return null;
+        }
+
+        Context ctx = GmsCompat.appContext();
+
+        if (bdef.transactionCodes == null) {
+            // this is a complete interface implementation
+            return bdef.getInstance(ctx);
+        }
+
+        return new HybridBinder(ctx, originalBinder, bdef);
+    }
+
+    private static BinderDef maybeGetBinderDef(String iface) {
+        synchronized (seenInterfaces) {
+            int i = seenInterfaces.indexOfKey(iface);
+            if (i >= 0) {
+                return seenInterfaces.valueAt(i);
+            }
+        }
+
+        Context ctx = GmsCompat.appContext();
+        String pkgName = ctx.getPackageName();
+        int processState = ActivityThread.currentActivityThread().getProcessState();
+
+        BinderDef maybeBinderDef;
+        try {
+            if (GmsCompat.isEnabled()) {
+                maybeBinderDef = GmsCompatApp.iGms2Gca()
+                        .maybeGetBinderDef(pkgName, processState, iface);
+            } else {
+                maybeBinderDef = GmsCompatApp.iClientOfGmsCore2Gca()
+                        .maybeGetBinderDef(pkgName, processState, iface);
+            }
+        } catch (RemoteException e) {
+            throw GmsCompatApp.callFailed(e);
+        }
+
+        synchronized (seenInterfaces) {
+            // in case seenInterfaces changed since last check
+            int idx = seenInterfaces.indexOfKey(iface);
+            if (idx >= 0) {
+                return seenInterfaces.valueAt(idx);
+            }
+
+            if (seenInterfaces.size() == 0) {
+                BinderDefStateListener.register(ctx);
+            }
+
+            seenInterfaces.put(iface, maybeBinderDef);
+        }
+
+        return maybeBinderDef;
+    }
+
+    public static class BinderDefStateListener extends BroadcastReceiver {
+        public static final String INTENT_ACTION = GmsCompatApp.PKG_NAME + ".ACTION_BINDER_DEFS_CHANGED";
+        public static final String KEY_CHANGED_IFACE_NAMES = "changed_iface_names";
+
+        static void register(Context ctx) {
+            var l = new BinderDefStateListener();
+            var filter = new IntentFilter(INTENT_ACTION);
+            String permission = GmsCompatApp.SIGNATURE_PROTECTED_PERMISSION;
+            ctx.registerReceiver(l, filter, permission, null, Context.RECEIVER_EXPORTED);
+        }
+
+        public void onReceive(Context context, Intent intent) {
+            String[] changedIfaces = intent.getStringArrayExtra(KEY_CHANGED_IFACE_NAMES);
+
+            boolean exit = false;
+            synchronized (seenInterfaces) {
+                for (String changedIface : changedIfaces) {
+                    if (seenInterfaces.containsKey(changedIface)) {
+                        // it's infeasible to apply updated BinderDef without restarting app process
+                        Log.d(TAG, "state of BinderDef " + changedIface + " changed, will call System.exit(0)");
+                        exit = true;
+                    }
+                }
+            }
+            if (exit) {
+                System.exit(0);
+            }
+        }
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/GmcMediaProjectionService.java b/core/java/com/android/internal/gmscompat/GmcMediaProjectionService.java
new file mode 100644
index 000000000000..f71ecb2e88a1
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/GmcMediaProjectionService.java
@@ -0,0 +1,85 @@
+package com.android.internal.gmscompat;
+
+import android.app.Notification;
+import android.app.Service;
+import android.content.Intent;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.util.ArrayMap;
+import android.util.Log;
+
+import java.util.UUID;
+import java.util.concurrent.CountDownLatch;
+
+import static android.app.compat.gms.GmsCompat.appContext;
+
+// Unprivileged app that is performing a screen capture is required by the OS to run
+// a foreground service with FOREGROUND_SERVICE_TYPE_MEDIA_PROJECTION
+public class GmcMediaProjectionService extends Service {
+    private static final String TAG = "GmcMediaProjService";
+
+    private static final ArrayMap<String, CountDownLatch> latches = new ArrayMap<>();
+
+    public static void start() {
+        if (Thread.currentThread() == appContext().getMainLooper().getThread()) {
+            // otherwise, latch.await() below would deadlock
+            throw new IllegalStateException("should never be called from the main thread");
+        }
+
+        String id = UUID.randomUUID().toString();
+        var latch = new CountDownLatch(1);
+        synchronized (latches) {
+            latches.put(id, latch);
+        }
+        Intent intent = intent().setIdentifier(id);
+        Log.d(TAG, "start " + id);
+        appContext().startForegroundService(intent);
+        try {
+            latch.await();
+        } catch (InterruptedException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    public static void stop() {
+        Log.d(TAG, "stop");
+        appContext().stopService(intent());
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        Log.d(TAG, "onStartCommand " + intent);
+
+        Notification n;
+        try {
+            // notification icon and text are stored in GmsCompat app
+            n = GmsCompatApp.iGms2Gca().getMediaProjectionNotification();
+        } catch (RemoteException e) {
+            throw GmsCompatApp.callFailed(e);
+        }
+
+        startForeground(GmsCoreConst.NOTIF_ID_MEDIA_PROJECTION_SERVICE, n);
+
+        String id = intent.getIdentifier();
+        CountDownLatch latch;
+
+        synchronized (latches) {
+            latch = latches.remove(id);
+        }
+        if (latch != null) {
+            latch.countDown();
+        } else {
+            // can happen if our process died after startForegroundService() but before
+            // onStartCommand(), OS recreates process in that case
+            Log.e(TAG, "missing latch");
+        }
+
+        return START_NOT_STICKY;
+    }
+
+    private static Intent intent() {
+        return new Intent(appContext(), GmcMediaProjectionService.class);
+    }
+
+    @Override public IBinder onBind(Intent intent) { return null; }
+}
diff --git a/core/java/com/android/internal/gmscompat/GmsCompatApp.java b/core/java/com/android/internal/gmscompat/GmsCompatApp.java
new file mode 100644
index 000000000000..ada29f44dbae
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/GmsCompatApp.java
@@ -0,0 +1,298 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat;
+
+import android.Manifest;
+import android.accounts.AccountManager;
+import android.annotation.Nullable;
+import android.app.compat.gms.GmsCompat;
+import android.content.Context;
+import android.database.ContentObserver;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.provider.DeviceConfig;
+import android.provider.Settings;
+import android.util.ArraySet;
+import android.util.Log;
+
+import com.android.internal.gmscompat.dynamite.server.FileProxyService;
+
+import static com.android.internal.gmscompat.GmsHooks.inPersistentGmsCoreProcess;
+
+public final class GmsCompatApp {
+    private static final String TAG = "GmsCompat/GCA";
+    public static final String PKG_NAME = "app.grapheneos.gmscompat";
+    // permission that is held only by GmsCompatApp
+    public static final String SIGNATURE_PROTECTED_PERMISSION = PKG_NAME + ".SIGNATURE_PROTECTED_PERMISSION";
+
+    @SuppressWarnings("FieldCanBeLocal")
+    // written to fields to prevent GC from collecting them
+    private static BinderGca2Gms binderGca2Gms;
+    @SuppressWarnings("FieldCanBeLocal")
+    private static FileProxyService dynamiteFileProxyService;
+
+    private static IGms2Gca binderGms2Gca;
+
+    static GmsCompatConfig connect(Context ctx, String processName) {
+        registeredContentObservers = new ArraySet<>();
+
+        BinderGca2Gms gca2Gms = new BinderGca2Gms();
+        binderGca2Gms = gca2Gms;
+
+        try {
+            IGms2Gca iGms2Gca = IGms2Gca.Stub.asInterface(getBinder(RPC_GET_BINDER_IGms2Gca));
+            binderGms2Gca = iGms2Gca;
+
+            if (GmsCompat.isGmsCore()) {
+                FileProxyService fileProxyService = null;
+                if (inPersistentGmsCoreProcess) {
+                    // FileProxyService binder needs to be always available to the Dynamite clients.
+                    // "persistent" process launches at bootup and is kept alive by the ServiceConnection
+                    // from the GmsCompatApp, which makes it fit for the purpose of hosting the FileProxyService
+                    fileProxyService = new FileProxyService(ctx);
+                    dynamiteFileProxyService = fileProxyService;
+
+                    ctx.getMainThreadHandler().postDelayed(GmsCompatApp::maybeShowContactsSyncNotification, 3000L);
+                }
+                return iGms2Gca.connectGmsCore(processName, gca2Gms, fileProxyService);
+            } else {
+                return iGms2Gca.connect(ctx.getPackageName(), processName, gca2Gms);
+            }
+        } catch (RemoteException e) {
+            throw callFailed(e);
+        }
+    }
+
+    public static IGms2Gca iGms2Gca() {
+        return binderGms2Gca;
+    }
+
+    private static volatile IClientOfGmsCore2Gca binderClientOfGmsCore2Gca;
+
+    public static IClientOfGmsCore2Gca iClientOfGmsCore2Gca() {
+        IClientOfGmsCore2Gca cache = binderClientOfGmsCore2Gca;
+        if (cache != null) {
+            return cache;
+        }
+
+        if (GmsCompat.isGmsCore()) {
+            throw new IllegalStateException();
+        }
+
+        IBinder binder = getBinder(RPC_GET_BINDER_IClientOfGmsCore2Gca);
+        IClientOfGmsCore2Gca iface = IClientOfGmsCore2Gca.Stub.asInterface(binder);
+        // benign race, it's fine to obtain this interface more than once
+        binderClientOfGmsCore2Gca = iface;
+        return iface;
+    }
+
+    private static final String RPC_PROVIDER_AUTHORITY = PKG_NAME + ".RpcProvider";
+    public static final String KEY_BINDER = "binder";
+    public static final String KEY_PKG_NAME = "pkg";
+
+    public static final int RPC_GET_BINDER_IGms2Gca = 0;
+    public static final int RPC_GET_BINDER_IClientOfGmsCore2Gca = 1;
+
+    public static Bundle callRpcProvider(Context ctx, int method, String arg, Bundle extras) {
+        String authority = RPC_PROVIDER_AUTHORITY;
+        var cr = ctx.getContentResolver();
+        try {
+            return cr.call(authority, Integer.toString(method), arg, extras);
+        } catch (Throwable t) {
+            Log.e(TAG, "call to " + authority + " failed", t);
+            if (GmsCompat.isEnabled()) {
+                // content provider calls are infallible unless something goes very wrong, better fail fast in that case
+                System.exit(1);
+            }
+            // don't crash processes that call GmsCompatApp, but don't use GmsCompat layer
+            return null;
+        }
+    }
+
+    private static IBinder getBinder(int which) {
+        Bundle bundle = callRpcProvider(GmsCompat.appContext(), which, null, null);
+        IBinder binder = bundle.getBinder(KEY_BINDER);
+        DeathRecipient.register(binder);
+        return binder;
+    }
+
+    static class DeathRecipient implements IBinder.DeathRecipient {
+        private static final DeathRecipient INSTANCE = new DeathRecipient();
+        private DeathRecipient() {}
+
+        static void register(IBinder b) {
+            try {
+                b.linkToDeath(INSTANCE, 0);
+            } catch (RemoteException e) {
+                // binder already died
+                INSTANCE.binderDied();
+            }
+        }
+
+        public void binderDied() {
+            // see comment in callFailed()
+            Log.e(TAG, PKG_NAME + " died");
+            System.exit(1);
+        }
+    }
+
+    public static RuntimeException callFailed(RemoteException e) {
+        // running GmsCompat app process is a hard dependency of sandboxed GMS
+        Log.e(TAG, "call failed, calling System.exit(1)", e);
+        System.exit(1);
+        // unreachable, needed for control flow checks by the compiler
+        // (Java doesn't have a concept of "noreturn")
+        return e.rethrowAsRuntimeException();
+    }
+
+    public static final String NS_DeviceConfig = "config";
+
+    public static String deviceConfigNamespace(String namespace) {
+        // last path component of DeviceConfig.CONTENT_URI
+        String topNs = "config";
+        return NS_DeviceConfig + ':' + namespace;
+    }
+
+    public static String getString(String ns, String key) {
+        try {
+            return iGms2Gca().privSettingsGetString(ns, key);
+        } catch (RemoteException e) {
+            throw callFailed(e);
+        }
+    }
+
+    public static boolean putString(String ns, String key, @Nullable String value) {
+        try {
+            return iGms2Gca().privSettingsPutString(ns, key, value);
+        } catch (RemoteException e) {
+            throw callFailed(e);
+        }
+    }
+
+    public static boolean setProperties(DeviceConfig.Properties props) {
+        String[] keys = props.getKeyset().toArray(new String[0]);
+        String[] values = new String[keys.length];
+
+        for (int i = 0; i < keys.length; ++i) {
+            values[i] = props.getString(keys[i], null);
+        }
+
+        String ns = deviceConfigNamespace(props.getNamespace());
+
+        try {
+            return iGms2Gca().privSettingsPutStrings(ns, keys, values);
+        } catch (RemoteException e) {
+            throw callFailed(e);
+        }
+    }
+
+    private static ArraySet<ContentObserver> registeredContentObservers;
+
+    public static boolean registerObserver(Uri uri, ContentObserver observer) {
+        String s = uri.toString();
+
+        String prefix = "content://settings/";
+
+        if (!s.startsWith(prefix)) {
+            return false;
+        }
+
+        int nsStart = prefix.length();
+        int nsEnd = s.indexOf('/', nsStart);
+
+        if (nsEnd < 0 || nsStart == nsEnd) {
+            return false;
+        }
+
+        String ns = s.substring(nsStart, nsEnd);
+        String key = s.substring(nsEnd + 1);
+
+        switch (ns) {
+            // keep in sync with Settings.NameValueCache#maybeGetGmsCompatNamespace
+            case "global":
+                if (Settings.Global.isKnownKey(key)) {
+                    return false;
+                }
+                break;
+            case "secure":
+                if (Settings.Secure.isKnownKey(key)) {
+                    return false;
+                }
+                break;
+            default:
+                return false;
+        }
+
+        android.database.IContentObserver iObserver = observer.getContentObserver();
+
+        try {
+            iGms2Gca().privSettingsRegisterObserver(ns, key, iObserver);
+        } catch (RemoteException e) {
+            throw callFailed(e);
+        }
+
+        synchronized (registeredContentObservers) {
+            registeredContentObservers.add(observer);
+        }
+
+        return true;
+    }
+
+    public static boolean unregisterObserver(ContentObserver observer) {
+        synchronized (registeredContentObservers) {
+            if (registeredContentObservers.contains(observer)) {
+                registeredContentObservers.remove(observer);
+            } else {
+                return false;
+            }
+        }
+
+        android.database.IContentObserver iObserver = observer.getContentObserver();
+
+        try {
+            iGms2Gca().privSettingsUnregisterObserver(iObserver);
+        } catch (RemoteException e) {
+            throw callFailed(e);
+        }
+        return true;
+    }
+
+    static void maybeShowContactsSyncNotification() {
+        if (GmsCompat.hasPermission(Manifest.permission.WRITE_CONTACTS)) {
+            return;
+        }
+
+        Context ctx = GmsCompat.appContext();
+        var am = ctx.getSystemService(AccountManager.class);
+
+        am.addOnAccountsUpdatedListener(accounts -> {
+            // invoked only for Google accounts, "updateImmediately" arg ensures that it'll be called
+            // even if account is already added
+            if (accounts.length != 0) {
+                try {
+                    iGms2Gca().maybeShowContactsSyncNotification();
+                } catch (RemoteException e) {
+                    callFailed(e);
+                }
+            }
+        }, ctx.getMainThreadHandler(), true);
+    }
+
+    private GmsCompatApp() {}
+}
diff --git a/core/java/com/android/internal/gmscompat/GmsCompatConfig.aidl b/core/java/com/android/internal/gmscompat/GmsCompatConfig.aidl
new file mode 100644
index 000000000000..23491f79e42c
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/GmsCompatConfig.aidl
@@ -0,0 +1,3 @@
+package com.android.internal.gmscompat;
+
+parcelable GmsCompatConfig;
diff --git a/core/java/com/android/internal/gmscompat/GmsCompatConfig.java b/core/java/com/android/internal/gmscompat/GmsCompatConfig.java
new file mode 100644
index 000000000000..c46a7b55713e
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/GmsCompatConfig.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2022 GrapheneOS
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package com.android.internal.gmscompat;
+
+import android.app.compat.gms.GmsCompat;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.ArrayMap;
+import android.util.ArraySet;
+import android.util.SparseArray;
+
+import com.android.internal.gmscompat.flags.GmsFlag;
+
+import java.util.ArrayList;
+import java.util.function.BiConsumer;
+import java.util.function.Function;
+
+// Instances of this object should be immutable after publication, make sure to never change it afterwards
+public class GmsCompatConfig implements Parcelable {
+    public long version;
+    public final ArrayMap<String, ArrayMap<String, GmsFlag>> flags = new ArrayMap<>();
+    public ArrayMap<String, GmsFlag> gservicesFlags;
+    public final ArrayMap<String, ArrayMap<String, StubDef>> stubs = new ArrayMap<>();
+    // keys are namespaces, values are regexes of flag names that should be forced to default value
+    public final ArrayMap<String, ArrayList<String>> forceDefaultFlagsMap = new ArrayMap<>();
+    // keys are package names, values are list of permissions self-checks of which should be spoofed
+    public final ArrayMap<String, ArrayList<String>> spoofSelfPermissionChecksMap = new ArrayMap<>();
+    // keys are serviceIds, values are service permission requirements that need to be bypassed
+    public final SparseArray<ArraySet<String>> gmsServiceBrokerPermissionBypasses = new SparseArray<>();
+
+    // keys are package names, values are maps of components names to their component enabled setting
+    public final ArrayMap<String, ArrayMap<String, Integer>> forceComponentEnabledSettingsMap = new ArrayMap<>();
+
+    // set only in processes for which GmsCompat is enabled, to speed up lookups
+    public ArraySet<String> spoofSelfPermissionChecks;
+
+    public long maxGmsCoreVersion;
+    public long maxPlayStoreVersion;
+
+    public void addFlag(String namespace, GmsFlag flag) {
+        ArrayMap<String, GmsFlag> nsFlags = flags.get(namespace);
+        if (nsFlags == null) {
+            nsFlags = new ArrayMap<>();
+            flags.put(namespace, nsFlags);
+        }
+        nsFlags.put(flag.name, flag);
+    }
+
+    public void addGservicesFlag(String key, String value) {
+        GmsFlag f = new GmsFlag(key);
+        f.initAsSetString(value);
+        addGservicesFlag(f);
+    }
+
+    public void addGservicesFlag(GmsFlag flag) {
+        ArrayMap<String, GmsFlag> map = gservicesFlags;
+        if (map == null) {
+            map = new ArrayMap<>();
+            gservicesFlags = map;
+        }
+        map.put(flag.name, flag);
+    }
+
+    public boolean shouldSpoofSelfPermissionCheck(String perm) {
+        return spoofSelfPermissionChecks.contains(perm);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel p, int wtpFlags) {
+        p.writeLong(version);
+
+        writeStringArrayMapMap(flags, GmsFlag::writeMapEntry, p);
+        writeArrayMap(gservicesFlags, GmsFlag::writeMapEntry, p);
+
+        writeStringArrayMapMap(stubs, p);
+
+        p.writeLong(maxGmsCoreVersion);
+        p.writeLong(maxPlayStoreVersion);
+
+        writeArrayMapStringStringList(forceDefaultFlagsMap, p);
+        writeArrayMapStringStringList(spoofSelfPermissionChecksMap, p);
+        {
+            var map = gmsServiceBrokerPermissionBypasses;
+            int cnt = map.size();
+            p.writeInt(cnt);
+            for (int i = 0; i < cnt; ++i) {
+                p.writeInt(map.keyAt(i));
+                p.writeArraySet(map.valueAt(i));
+            }
+        }
+        writeStringArrayMapMap(forceComponentEnabledSettingsMap, Parcel::writeString, Parcel::writeInt, p);
+    }
+
+    public static final Creator<GmsCompatConfig> CREATOR = new Creator<>() {
+        @Override
+        public GmsCompatConfig createFromParcel(Parcel p) {
+            GmsCompatConfig r = new GmsCompatConfig();
+            r.version = p.readLong();
+
+            readStringArrayMapMap(p, r.flags, GmsFlag::readMapEntry);
+            r.gservicesFlags = readArrayMap(p, GmsFlag::readMapEntry);
+
+            readStringArrayMapMap(p, r.stubs, StubDef.CREATOR);
+
+            r.maxGmsCoreVersion = p.readLong();
+            r.maxPlayStoreVersion = p.readLong();
+
+            readArrayMapStringStringList(p, r.forceDefaultFlagsMap);
+            readArrayMapStringStringList(p, r.spoofSelfPermissionChecksMap);
+            {
+                int cnt = p.readInt();
+                ClassLoader cl = String.class.getClassLoader();
+                for (int i = 0; i < cnt; ++i) {
+                    r.gmsServiceBrokerPermissionBypasses.put(p.readInt(), (ArraySet<String>) p.readArraySet(cl));
+                }
+            }
+
+            readStringArrayMapMap(p, r.forceComponentEnabledSettingsMap,
+                    Parcel::readString, Parcel::readInt);
+
+            if (GmsCompat.isEnabled()) {
+                String pkgName = GmsCompat.appContext().getPackageName();
+
+                ArrayList<String> perms = r.spoofSelfPermissionChecksMap.get(pkgName);
+                r.spoofSelfPermissionChecks = perms != null ?
+                        new ArraySet<>(perms) :
+                        new ArraySet<>();
+            }
+            return r;
+        }
+
+        @Override
+        public GmsCompatConfig[] newArray(int size) {
+            return new GmsCompatConfig[size];
+        }
+    };
+
+    static <V extends Parcelable> void writeStringArrayMapMap(
+            ArrayMap<String, ArrayMap<String, V>> outerMap, Parcel p) {
+        writeStringArrayMapMap(outerMap, Parcel::writeString,
+                (parcel, v) -> v.writeToParcel(parcel, 0), p);
+    }
+
+    static <V extends Parcelable> void readStringArrayMapMap(Parcel p,
+            ArrayMap<String, ArrayMap<String, V>> outerMap, Parcelable.Creator<V> valueCreator) {
+
+        readStringArrayMapMap(p, outerMap, Parcel::readString, valueCreator::createFromParcel);
+    }
+
+    static <K, V> void writeStringArrayMapMap(ArrayMap<String, ArrayMap<K, V>> outerMap,
+              BiConsumer<Parcel, K> writeK, BiConsumer<Parcel, V> writeV, Parcel p) {
+        ArrayMapEntryWriter<K, V> entryWriter = (map, i, parcel) -> {
+            writeK.accept(p, map.keyAt(i));
+            writeV.accept(p, map.valueAt(i));
+        };
+        writeStringArrayMapMap(outerMap, entryWriter, p);
+    }
+
+    static <K, V> void readStringArrayMapMap(Parcel p, ArrayMap<String, ArrayMap<K, V>> outerMap,
+             Function<Parcel, K> readK, Function<Parcel, V> readV) {
+        ArrayMapEntryReader<K, V> entryReader = (parcel, map) -> {
+            map.append(readK.apply(p), readV.apply(p));
+        };
+        readStringArrayMapMap(p, outerMap, entryReader);
+    }
+
+    interface ArrayMapEntryWriter<K, V> {
+        void write(ArrayMap<K, V> map, int idx, Parcel dst);
+    }
+
+    interface ArrayMapEntryReader<K, V> {
+        void read(Parcel p, ArrayMap<K, V> dst);
+    }
+
+    static <K, V> void writeStringArrayMapMap(ArrayMap<String, ArrayMap<K, V>> outerMap,
+                                              ArrayMapEntryWriter<K, V> entryWriter, Parcel p) {
+        int outerCnt = outerMap.size();
+        p.writeInt(outerCnt);
+        for (int outerIdx = 0; outerIdx < outerCnt; ++outerIdx) {
+            String outerK = outerMap.keyAt(outerIdx);
+            p.writeString(outerK);
+            writeArrayMap(outerMap.valueAt(outerIdx), entryWriter, p);
+        }
+    }
+
+    static <K, V> void readStringArrayMapMap(Parcel p, ArrayMap<String, ArrayMap<K, V>> outerMap,
+             ArrayMapEntryReader<K, V> entryReader) {
+        int outerCnt = p.readInt();
+        outerMap.ensureCapacity(outerCnt);
+        for (int outerIdx = 0; outerIdx < outerCnt; ++outerIdx) {
+            String outerK = p.readString();
+            outerMap.put(outerK, readArrayMap(p, entryReader));
+        }
+    }
+
+    static <K, V> void writeArrayMap(ArrayMap<K, V> map, ArrayMapEntryWriter<K, V> entryWriter,
+                                     Parcel p) {
+        int cnt = map.size();
+        p.writeInt(cnt);
+        for (int i = 0; i < cnt; ++i) {
+            entryWriter.write(map, i, p);
+        }
+    }
+
+    static <K, V> ArrayMap<K, V> readArrayMap(Parcel p, ArrayMapEntryReader<K, V> entryReader) {
+        int cnt = p.readInt();
+        var map = new ArrayMap<K, V>(cnt);
+        for (int i = 0; i < cnt; ++i) {
+            entryReader.read(p, map);
+        }
+        return map;
+    }
+
+    static void writeArrayMapStringStringList(ArrayMap<String, ArrayList<String>> map, Parcel p) {
+        int cnt = map.size();
+        p.writeInt(cnt);
+        for (int i = 0; i < cnt; ++i) {
+            p.writeString(map.keyAt(i));
+            p.writeStringList(map.valueAt(i));
+        }
+    }
+
+    static void readArrayMapStringStringList(Parcel p, ArrayMap<String, ArrayList<String>> map) {
+        int cnt = p.readInt();
+        map.ensureCapacity(cnt);
+        for (int i = 0; i < cnt; ++i) {
+            map.put(p.readString(), p.createStringArrayList());
+        }
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/GmsCoreConst.java b/core/java/com/android/internal/gmscompat/GmsCoreConst.java
new file mode 100644
index 000000000000..47f737f8f9d9
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/GmsCoreConst.java
@@ -0,0 +1,6 @@
+package com.android.internal.gmscompat;
+
+public interface GmsCoreConst {
+    int NOTIFICATION_ID_BASE = 0x7fff_0000;
+    int NOTIF_ID_MEDIA_PROJECTION_SERVICE = NOTIFICATION_ID_BASE + 1;
+}
diff --git a/core/java/com/android/internal/gmscompat/GmsHooks.java b/core/java/com/android/internal/gmscompat/GmsHooks.java
new file mode 100644
index 000000000000..ed38d7b221c6
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/GmsHooks.java
@@ -0,0 +1,752 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat;
+
+import android.Manifest;
+import android.annotation.Nullable;
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.app.ActivityManager.RunningAppProcessInfo;
+import android.app.Application;
+import android.app.ApplicationErrorReport;
+import android.app.BroadcastOptions;
+import android.app.PendingIntent;
+import android.app.Service;
+import android.app.compat.gms.GmsCompat;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.net.Uri;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.DeadSystemRuntimeException;
+import android.os.IBinder;
+import android.os.Parcel;
+import android.os.PowerExemptionManager;
+import android.os.Process;
+import android.os.RemoteException;
+import android.os.SystemClock;
+import android.os.UserHandle;
+import android.provider.Downloads;
+import android.provider.Settings;
+import android.util.ArrayMap;
+import android.util.ArraySet;
+import android.util.Log;
+import android.util.SparseArray;
+import android.webkit.WebView;
+
+import com.android.internal.gmscompat.client.ClientPriorityManager;
+import com.android.internal.gmscompat.client.GmsCompatClientService;
+import com.android.internal.gmscompat.flags.GmsFlag;
+import com.android.internal.gmscompat.gcarriersettings.GCarrierSettingsApp;
+import com.android.internal.gmscompat.gcarriersettings.TestCarrierConfigService;
+import com.android.internal.gmscompat.sysservice.GmcPackageManager;
+import com.android.internal.gmscompat.util.GmcActivityUtils;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.UUID;
+import java.util.function.Consumer;
+import java.util.regex.Pattern;
+
+import static com.android.internal.gmscompat.GmsInfo.PACKAGE_GMS_CORE;
+
+public final class GmsHooks {
+    private static final String TAG = "GmsCompat/Hooks";
+
+    private static volatile GmsCompatConfig config;
+
+    public static final String PERSISTENT_GmsCore_PROCESS = PACKAGE_GMS_CORE + ".persistent";
+    public static boolean inPersistentGmsCoreProcess;
+    public static final String UI_GmsCore_PROCESS = PACKAGE_GMS_CORE + ".ui";
+
+    public static GmsCompatConfig config() {
+        // thread-safe: immutable after publication
+        return config;
+    }
+
+    public static void init(Context ctx, String packageName) {
+        String processName = Application.getProcessName();
+
+        if (!packageName.equals(processName)) {
+            // Fix RuntimeException: Using WebView from more than one process at once with the same data
+            // directory is not supported. https://crbug.com/558377
+            WebView.setDataDirectorySuffix("process-shim--" + processName);
+        }
+
+        if (GmsCompat.isGmsCore()) {
+            inPersistentGmsCoreProcess = processName.equals(PERSISTENT_GmsCore_PROCESS);
+        }
+
+        if (GmsCompat.isPlayStore()) {
+            PlayStoreHooks.init();
+        }
+
+        if (GmsCompat.isGCarrierSettings()) {
+            GCarrierSettingsApp.init();
+        }
+
+        configUpdateLock = new Object();
+        tlPermissionsToSpoof = new ThreadLocal<>();
+
+        // Locking is needed to prevent a race that would occur if config is updated via
+        // BinderGca2Gms#updateConfig in the time window between BinderGms2Gca#connect and setConfig()
+        // call below. Older GmsCompatConfig would overwrite the newer one in that case.
+        synchronized (configUpdateLock) {
+            GmsCompatConfig config = GmsCompatApp.connect(ctx, processName);
+            setConfig(config);
+        }
+
+        Thread.setUncaughtExceptionPreHandler(new UncaughtExceptionPreHandler());
+
+        GmcPackageManager.init(ctx);
+    }
+
+    static Object configUpdateLock;
+
+    static void setConfig(GmsCompatConfig c) {
+        // configUpdateLock should never be null at this point, it's initialized before GmsCompatApp
+        // gets a handle to BinderGca2Gms that is used for updating GmsCompatConfig
+        synchronized (configUpdateLock) {
+            config = c;
+        }
+    }
+
+    static class UncaughtExceptionPreHandler implements Thread.UncaughtExceptionHandler {
+        final Thread.UncaughtExceptionHandler orig = Thread.getUncaughtExceptionPreHandler();
+
+        @Override
+        public void uncaughtException(Thread t, Throwable e) {
+            Context ctx = GmsCompat.appContext();
+
+            ApplicationErrorReport aer = new ApplicationErrorReport();
+            aer.type = ApplicationErrorReport.TYPE_CRASH;
+            aer.crashInfo = new ApplicationErrorReport.ParcelableCrashInfo(e);
+
+            ApplicationInfo ai = ctx.getApplicationInfo();
+            aer.packageName = ai.packageName;
+            aer.packageVersion = ai.longVersionCode;
+            aer.processName = Application.getProcessName();
+
+            // In some cases, GMS kills its process when it receives an uncaught exception, which
+            // bypasses the standard crash handling infrastructure.
+            // Send the report to GmsCompatApp before GMS receives the uncaughtException() callback.
+
+            if (!shouldSkipException(e)) {
+                try {
+                    GmsCompatApp.iGms2Gca().onUncaughtException(aer);
+                } catch (RemoteException re) {
+                    Log.e(TAG, "", re);
+                }
+            }
+
+            if (orig != null) {
+                orig.uncaughtException(t, e);
+            }
+        }
+
+        private static boolean shouldSkipException(Throwable e) {
+            for (;;) {
+                if (e == null) {
+                    return false;
+                }
+
+                boolean skip =
+    // in some cases a DeadSystemRuntimeException is thrown despite the system being actually
+    // still alive, likely when the Binder buffer space is full and a binder transaction with
+    // system_server fails.
+    // See https://cs.android.com/android/platform/superproject/+/android-13.0.0_r3:frameworks/base/core/jni/android_util_Binder.cpp;l=894
+    // (DeadObjectException is rethrown as DeadSystemRuntimeException by
+    // android.os.RemoteException#rethrowFromSystemServer())
+                    e instanceof DeadSystemRuntimeException
+                ;
+
+                if (skip) {
+                    return true;
+                }
+
+                e = e.getCause();
+            }
+        }
+    }
+
+    // ContextImpl#getSystemService(String)
+    public static boolean isHiddenSystemService(String name) {
+        // return true only for services that are null-checked
+        switch (name) {
+            case Context.WIFI_SCANNING_SERVICE:
+                return !GmsCompat.isAndroidAuto();
+            case Context.CONTEXTHUB_SERVICE:
+            case Context.APP_INTEGRITY_SERVICE:
+            // used for factory reset protection
+            case Context.PERSISTENT_DATA_BLOCK_SERVICE:
+            // used for updateable fonts
+            case Context.FONT_SERVICE:
+            // requires privileged permissions
+            case Context.STATS_MANAGER:
+                return true;
+        }
+        return false;
+    }
+
+    /**
+     * Use the per-app SSAID as a random serial number for SafetyNet. This doesn't necessarily make
+     * pass, but at least it retusn a valid "failed" response and stops spamming device key
+     * requests.
+     *
+     * This isn't a privacy risk because all unprivileged apps already have access to random SSAIDs.
+     */
+    // Build#getSerial()
+    @SuppressLint("HardwareIds")
+    public static String getSerial() {
+        String ssaid = Settings.Secure.getString(GmsCompat.appContext().getContentResolver(),
+                Settings.Secure.ANDROID_ID);
+        String serial = ssaid.toUpperCase();
+        Log.d(TAG, "Generating serial number from SSAID: " + serial);
+        return serial;
+    }
+
+    static class RecentBinderPid implements Comparable<RecentBinderPid> {
+        int pid;
+        int uid;
+        long lastSeen;
+        volatile String[] packageNames; // lazily inited
+
+        static final int MAX_MAP_SIZE = 50;
+        static final int MAP_SIZE_TRIM_TO = 40;
+        static final SparseArray<RecentBinderPid> map = new SparseArray(MAX_MAP_SIZE + 1);
+
+        public int compareTo(RecentBinderPid b) {
+            return Long.compare(b.lastSeen, lastSeen); // newest come first
+        }
+    }
+
+    // Remember recent Binder peers to include them in the result of ActivityManager.getRunningAppProcesses()
+    // Binder#execTransact(int, long, long, int)
+    public static void onBinderTransaction(int pid, int uid) {
+        SparseArray<RecentBinderPid> map = RecentBinderPid.map;
+        synchronized (map) {
+            RecentBinderPid rbp = map.get(pid);
+            if (rbp != null) {
+                if (rbp.uid != uid) { // pid was reused
+                    rbp = null;
+                }
+            }
+            if (rbp == null) {
+                rbp = new RecentBinderPid();
+                rbp.pid = pid;
+                rbp.uid = uid;
+                map.put(pid, rbp);
+            }
+            rbp.lastSeen = SystemClock.uptimeMillis();
+
+            int mapSize = map.size();
+            if (mapSize <= RecentBinderPid.MAX_MAP_SIZE) {
+                return;
+            }
+            RecentBinderPid[] arr = new RecentBinderPid[mapSize];
+            for (int i = 0; i < mapSize; ++i) {
+                arr[i] = map.valueAt(i);
+            }
+            // sorted by lastSeen field in reverse order
+            Arrays.sort(arr);
+            map.clear();
+            for (int i = 0; i < RecentBinderPid.MAP_SIZE_TRIM_TO; ++i) {
+                RecentBinderPid e = arr[i];
+                map.put(e.pid, e);
+            }
+        }
+    }
+
+    // In some cases (Play Games Services, Play {Asset, Feature} Delivery)
+    // GMS relies on getRunningAppProcesses() to figure out whether its client is running.
+    // This workaround is racy, because unprivileged apps can't know whether an arbitrary pid is alive.
+    // ActivityManager#getRunningAppProcesses()
+    public static ArrayList<RunningAppProcessInfo> addRecentlyBoundPids(Context context,
+                                                                        List<RunningAppProcessInfo> orig) {
+        final RecentBinderPid[] binderPids;
+        final int binderPidsCount;
+        // copy to array to avoid long lock contention with Binder.execTransact(),
+        // there are expensive getPackagesForUid() calls below
+        {
+            SparseArray<RecentBinderPid> map = RecentBinderPid.map;
+            synchronized (map) {
+                binderPidsCount = map.size();
+                binderPids = new RecentBinderPid[binderPidsCount];
+                for (int i = 0; i < binderPidsCount; ++i) {
+                    binderPids[i] = map.valueAt(i);
+                }
+            }
+        }
+        PackageManager pm = context.getPackageManager();
+        ArrayList<RunningAppProcessInfo> res = new ArrayList<>(orig.size() + binderPidsCount);
+        res.addAll(orig);
+        for (int i = 0; i < binderPidsCount; ++i) {
+            RecentBinderPid rbp = binderPids[i];
+            String[] pkgs = rbp.packageNames;
+            if (pkgs == null) {
+                if (UserHandle.getUserId(rbp.uid) != UserHandle.myUserId()) {
+                    // SystemUI from userId 0 sends callbacks to apps from all userIds via
+                    // android.window.IOnBackInvokedCallback.
+                    // getPackagesForUid() will fail due to missing privileged
+                    // INTERACT_ACROSS_USERS permission
+                    continue;
+                }
+
+                pkgs = pm.getPackagesForUid(rbp.uid);
+                if (pkgs == null || pkgs.length == 0) {
+                    continue;
+                }
+                // this field is volatile
+                rbp.packageNames = pkgs;
+            }
+            RunningAppProcessInfo pi = new RunningAppProcessInfo();
+            // these fields are immutable after publication
+            pi.pid = rbp.pid;
+            pi.uid = rbp.uid;
+            pi.processName = pkgs[0];
+            pi.pkgList = pkgs;
+            pi.importance = RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
+            res.add(pi);
+        }
+        return res;
+    }
+
+    // ContentResolver#query(Uri, String[], Bundle, CancellationSignal)
+    public static Cursor maybeModifyQueryResult(Uri uri,
+            @Nullable String[] projection, @Nullable Bundle queryArgs, @Nullable Cursor origCursor) {
+        String uriString = uri.toString();
+
+        Consumer<ArrayMap<String, String>> mutator = null;
+
+        if (GmsFlag.GSERVICES_URI.equals(uriString)) {
+            if (queryArgs == null) {
+                return null;
+            }
+            String[] selectionArgs = queryArgs.getStringArray(ContentResolver.QUERY_ARG_SQL_SELECTION_ARGS);
+            if (selectionArgs == null) {
+                return null;
+            }
+
+            ArrayMap<String, GmsFlag> flags = config().gservicesFlags;
+            if (flags == null) {
+                return null;
+            }
+
+            mutator = map -> {
+                for (GmsFlag f : flags.values()) {
+                    for (String sel : selectionArgs) {
+                        if (f.name.startsWith(sel)) {
+                            f.applyToGservicesMap(map);
+                            break;
+                        }
+                    }
+                }
+            };
+        } else if (uriString.startsWith(GmsFlag.PHENOTYPE_URI_PREFIX)) {
+            List<String> path = uri.getPathSegments();
+            if (path.size() != 1) {
+                Log.e(TAG, "unknown phenotype uri " + uriString, new Throwable());
+                return null;
+            }
+
+            String namespace = path.get(0);
+
+            GmsCompatConfig config = config();
+
+            ArrayList<String> forceDefaultFlagsRegexes = config.forceDefaultFlagsMap.get(namespace);
+
+            ArrayMap<String, GmsFlag> nsFlags = config.flags.get(namespace);
+
+            if (forceDefaultFlagsRegexes == null && nsFlags == null) {
+                return null;
+            }
+
+            mutator = map -> {
+                if (forceDefaultFlagsRegexes != null) {
+                    int patternCnt = forceDefaultFlagsRegexes.size();
+                    Pattern[] patterns = new Pattern[patternCnt];
+                    for (int i = 0; i < patternCnt; ++i) {
+                        patterns[i] = Pattern.compile(forceDefaultFlagsRegexes.get(i));
+                    }
+                    ArrayMap filteredMap = new ArrayMap<>(map.size());
+
+                    outer:
+                    for (int entryIdx = 0, entryCnt = map.size(); entryIdx < entryCnt; ++entryIdx) {
+                        String key = map.keyAt(entryIdx);
+                        for (int patternIdx = 0; patternIdx < patternCnt; ++patternIdx) {
+                            if (patterns[patternIdx].matcher(key).matches()) {
+                                continue outer;
+                            }
+                        }
+                        filteredMap.put(key, map.valueAt(entryIdx));
+                    }
+                    map.clear();
+                    map.putAll(filteredMap);
+                }
+                if (nsFlags != null) {
+                    for (GmsFlag f : nsFlags.values()) {
+                        f.applyToPhenotypeMap(map);
+                    }
+                }
+            };
+        }
+
+        if (mutator != null) {
+            return modifyKvCursor(origCursor, projection, mutator);
+        }
+
+        return null;
+    }
+
+    private static Cursor modifyKvCursor(@Nullable Cursor origCursor, @Nullable String[] projection,
+                                         Consumer<ArrayMap<String, String>> mutator) {
+        final int keyIndex = 0;
+        final int valueIndex = 1;
+        final int projectionLength = 2;
+
+        if (origCursor != null) {
+            projection = origCursor.getColumnNames();
+        }
+
+        boolean expectedProjection = projection != null && projection.length == projectionLength
+                && "key".equals(projection[keyIndex]) && "value".equals(projection[valueIndex]);
+
+        if (!expectedProjection) {
+            Log.e(TAG, "unexpected projection " + Arrays.toString(projection), new Throwable());
+            return null;
+        }
+
+        final ArrayMap<String, String> map;
+        if (origCursor == null) {
+            map = new ArrayMap<>();
+        } else {
+            map = new ArrayMap<>(origCursor.getColumnCount() + 10);
+            try (Cursor orig = origCursor) {
+                while (orig.moveToNext()) {
+                    String key = orig.getString(keyIndex);
+                    String value = orig.getString(valueIndex);
+
+                    map.put(key, value);
+                }
+            }
+        }
+
+        mutator.accept(map);
+
+        final int mapSize = map.size();
+        MatrixCursor result = new MatrixCursor(projection, mapSize);
+
+        for (int i = 0; i < mapSize; ++i) {
+            Object[] row = new Object[projectionLength];
+            row[keyIndex] = map.keyAt(i);
+            row[valueIndex] = map.valueAt(i);
+
+            result.addRow(row);
+        }
+
+        return result;
+    }
+
+    // SharedPreferencesImpl#getAll
+    public static void maybeModifySharedPreferencesValues(String name, HashMap<String, Object> map) {
+        // some PhenotypeFlags are stored in SharedPreferences instead of phenotype.db database
+        ArrayMap<String, GmsFlag> flags = GmsHooks.config().flags.get(name);
+        if (flags == null) {
+            return;
+        }
+
+        for (GmsFlag f : flags.values()) {
+            f.applyToPhenotypeMap(map);
+        }
+    }
+
+    // Instrumentation#execStartActivity(Context, IBinder, IBinder, Activity, Intent, int, Bundle)
+    public static void onActivityStart(int resultCode, Intent intent, int requestCode, Bundle options) {
+        if (resultCode != ActivityManager.START_ABORTED) {
+            return;
+        }
+
+        // handle background activity starts, which normally require a privileged permission
+
+        if (requestCode >= 0) {
+            Log.d(TAG, "attempt to call startActivityForResult() from the background " + intent, new Throwable());
+            return;
+        }
+
+        // needed to prevent invalid reuse of PendingIntents, see PendingIntent doc
+        intent.setIdentifier(UUID.randomUUID().toString());
+
+        Context ctx = GmsCompat.appContext();
+        PendingIntent pendingIntent = PendingIntent.getActivity(ctx, 0, intent,
+                PendingIntent.FLAG_IMMUTABLE, options);
+        try {
+            GmsCompatApp.iGms2Gca().startActivityFromTheBackground(ctx.getPackageName(), pendingIntent);
+        } catch (RemoteException e) {
+            GmsCompatApp.callFailed(e);
+        }
+    }
+
+    // Activity#onCreate(Bundle)
+    public static void activityOnCreate(Activity activity) {
+
+    }
+
+    // ContentResolver#insert(Uri, ContentValues, Bundle)
+    public static void filterContentValues(Uri url, ContentValues values) {
+        if (values != null && Downloads.Impl.CONTENT_URI.equals(url)) {
+            Integer otherUid = values.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID);
+            if (otherUid != null) {
+                if (otherUid.intValue() != Process.SYSTEM_UID) {
+                    throw new IllegalStateException("unexpected COLUMN_OTHER_UID " + otherUid);
+                }
+                // gated by the privileged ACCESS_DOWNLOAD_MANAGER_ADVANCED permission
+                values.remove(Downloads.Impl.COLUMN_OTHER_UID);
+            }
+        }
+    }
+
+    private static boolean hasNearbyDevicesPermission() {
+        // "Nearby devices" user-facing permission grants multiple underlying permissions,
+        // checking one is enough
+        return GmsCompat.hasPermission(Manifest.permission.BLUETOOTH_SCAN);
+    }
+
+    // NfcAdapter#enable()
+    public static void enableNfc() {
+        Activity activity = GmcActivityUtils.getMostRecentVisibleActivity();
+        if (activity != null) {
+            activity.runOnUiThread(() -> {
+                Intent i = new Intent(Settings.ACTION_NFC_SETTINGS);
+                activity.startActivity(i);
+            });
+        }
+    }
+
+    // ContextImpl#sendBroadcast
+    // ContextImpl#sendOrderedBroadcast
+    // ContextImpl#sendBroadcastAsUser
+    // ContextImpl#sendOrderedBroadcastAsUser
+    public static Bundle filterBroadcastOptions(Intent intent, Bundle options) {
+        if (options == null) {
+            return null;
+        }
+
+        String targetPkg = intent.getPackage();
+
+        if (targetPkg == null) {
+            ComponentName cn = intent.getComponent();
+            if (cn != null) {
+                targetPkg = cn.getPackageName();
+            }
+        }
+
+        if (targetPkg == null) {
+            return options;
+        }
+
+        return filterBroadcastOptions(options, targetPkg);
+    }
+
+    // PendingIntent#send
+    public static Bundle filterBroadcastOptions(Bundle options, String targetPkg) {
+        BroadcastOptions bo = new BroadcastOptions(options);
+
+        if (bo.getTemporaryAppAllowlistType() == PowerExemptionManager.TEMPORARY_ALLOW_LIST_TYPE_NONE) {
+            return options;
+        }
+        // handle privileged BroadcastOptions#setTemporaryAppAllowlist() that is used for
+        // high-priority FCM pushes, location updates via PendingIntent,
+        // geofencing and activity detection notifications etc
+
+        long duration = bo.getTemporaryAppAllowlistDuration();
+
+        if (duration <= 0) {
+            return options;
+        }
+
+        ClientPriorityManager.raiseToForeground(targetPkg, duration,
+                bo.getTemporaryAppAllowlistReason(), bo.getTemporaryAppAllowlistReasonCode());
+
+        bo.setTemporaryAppAllowlist(0, PowerExemptionManager.TEMPORARY_ALLOW_LIST_TYPE_NONE,
+                PowerExemptionManager.REASON_UNKNOWN, null);
+        return bo.toBundle();
+    }
+
+    // Parcel#readException
+    public static boolean interceptException(Exception e, Parcel p) {
+        if (!(e instanceof SecurityException)) {
+            return false;
+        }
+
+        if (p.dataAvail() != 0) {
+            Log.w(TAG, "malformed Parcel: dataAvail() " + p.dataAvail() + " after exception", e);
+            return false;
+        }
+
+        StubDef stub = StubDef.find(e.getStackTrace(), config(), StubDef.FIND_MODE_Parcel);
+
+        if (stub == null) {
+            return false;
+        }
+
+        boolean res = stub.stubOutMethod(p);
+
+        if (Build.isDebuggable()) {
+            Log.i(TAG, res ? "intercepted" : "stubOut failed", e);
+        }
+
+        return res;
+    }
+
+    public static void onSQLiteOpenHelperConstructed(SQLiteOpenHelper h, @Nullable Context context) {
+        if (context == null) {
+            return;
+        }
+
+        if (GmsCompat.isGmsCore()) {
+            if (inPersistentGmsCoreProcess) {
+                if ("phenotype.db".equals(h.getDatabaseName()) && !context.isDeviceProtectedStorage()) {
+                    if (phenotypeDb != null) {
+                        Log.w(TAG, "reassigning phenotypeDb", new Throwable());
+                    }
+                    phenotypeDb = h;
+                }
+            }
+        }
+    }
+
+    @Nullable
+    public static Service maybeInstantiateService(String className) {
+        if (GmsCompatClientService.class.getName().equals(className)) {
+            return new GmsCompatClientService();
+        }
+
+        if (GmsCompat.isEnabled()) {
+            if (GmsCompat.isGmsCore()) {
+                if (GmcMediaProjectionService.class.getName().equals(className)) {
+                    return new GmcMediaProjectionService();
+                }
+            }
+            if (GmsCompat.isGCarrierSettings()) {
+                if (TestCarrierConfigService.class.getName().equals(className)) {
+                    return new TestCarrierConfigService();
+                }
+            }
+        }
+
+        return null;
+    }
+
+    private static volatile SQLiteOpenHelper phenotypeDb;
+    public static SQLiteOpenHelper getPhenotypeDb() { return phenotypeDb; }
+
+    private static ThreadLocal<ArraySet<String>> tlPermissionsToSpoof;
+
+    public static boolean shouldSpoofSelfPermissionCheck(String perm) {
+        ArraySet<String> set = tlPermissionsToSpoof.get();
+        if (set == null) {
+            return false;
+        }
+
+        return set.contains(perm);
+    }
+
+    public static final String GMS_SERVICE_BROKER_INTERFACE_DESCRIPTOR =
+            "com.google.android.gms.common.internal.IGmsServiceBroker";
+
+    public static boolean onBeginGmsServiceBrokerCall(int transactionCode, Parcel data) {
+        if (transactionCode != 46) { // getService() method
+            return false;
+        }
+
+        try {
+            data.enforceInterface(GMS_SERVICE_BROKER_INTERFACE_DESCRIPTOR);
+            // IGmsCallbacks binder
+            data.readStrongBinder();
+
+            if (data.readInt() == 1) { // GetServiceRequest is present
+                // GetServiceRequest object header
+                data.readInt();
+                data.readInt();
+
+                // version
+                data.readInt();
+                data.readInt();
+
+                // id of serviceId property
+                data.readInt();
+
+                int serviceId = data.readInt();
+
+                ArraySet<String> permsToSpoof = config().gmsServiceBrokerPermissionBypasses.get(serviceId);
+                if (permsToSpoof != null) {
+                    Log.d(TAG, "start spoofing self permission checks for getService() call for API "
+                            + serviceId + ", perms: " + Arrays.toString(permsToSpoof.toArray()));
+                    tlPermissionsToSpoof.set(permsToSpoof);
+                    // there's a second layer of caching inside GmsCore, need to notify permission
+                    // change listener used by that cache
+                    GmcPackageManager.notifyPermissionsChangeListeners();
+                    return true;
+                }
+            }
+        } finally {
+            data.setDataPosition(0);
+        }
+
+        return false;
+    }
+
+    public static void onEndGmsServiceBrokerCall() {
+        Log.d(TAG, "end self permission check spoofing");
+        tlPermissionsToSpoof.set(null);
+        // invalidate the cache of permission state inside GmsCore
+        GmcPackageManager.notifyPermissionsChangeListeners();
+    }
+
+    public static IBinder maybeOverrideBinder(IBinder binder) {
+        boolean proceed = GmsCompat.isEnabled() || GmsCompat.isClientOfGmsCore();
+        if (!proceed) {
+            return null;
+        }
+
+        String ifaceName = null;
+        try {
+            ifaceName = binder.getInterfaceDescriptor();
+        } catch (RemoteException e) {
+            Log.d(TAG, "", e);
+        }
+
+        if (ifaceName == null) {
+            return null;
+        }
+
+        return GmcBinderDefs.maybeOverrideBinder(binder, ifaceName);
+    }
+
+    private GmsHooks() {}
+}
diff --git a/core/java/com/android/internal/gmscompat/GmsInfo.java b/core/java/com/android/internal/gmscompat/GmsInfo.java
new file mode 100644
index 000000000000..986e106b3778
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/GmsInfo.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat;
+
+import android.ext.PackageId;
+
+/** @hide */
+public final class GmsInfo {
+    // Package names for GMS apps
+    public static final String PACKAGE_GSF = PackageId.GSF_NAME; // "Google Services Framework"
+    public static final String PACKAGE_GMS_CORE = PackageId.GMS_CORE_NAME; // "Play services"
+    public static final String PACKAGE_PLAY_STORE = PackageId.PLAY_STORE_NAME;
+
+    // "Google" app. "GSA" (G Search App) is its internal name
+    public static final String PACKAGE_GSA = PackageId.G_SEARCH_APP_NAME;
+
+    // Used for restricting accessibility of exported components, reducing the scope of broadcasts, etc.
+    // Held by GSF, GmsCore, Play Store.
+    public static final String SIGNATURE_PROTECTED_PERMISSION = "com.google.android.providers.gsf.permission.WRITE_GSERVICES";
+}
diff --git a/core/java/com/android/internal/gmscompat/IClientOfGmsCore2Gca.aidl b/core/java/com/android/internal/gmscompat/IClientOfGmsCore2Gca.aidl
new file mode 100644
index 000000000000..5919f6ba579c
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/IClientOfGmsCore2Gca.aidl
@@ -0,0 +1,14 @@
+package com.android.internal.gmscompat;
+
+import android.os.BinderDef;
+
+import com.android.internal.gmscompat.dynamite.server.IFileProxyService;
+
+// calls from clients of GMS Core to GmsCompatApp
+interface IClientOfGmsCore2Gca {
+    @nullable BinderDef maybeGetBinderDef(String callerPkg, int processState, String ifaceName);
+
+    IFileProxyService getDynamiteFileProxyService();
+
+    oneway void showMissingAppNotification(String pkgName);
+}
diff --git a/core/java/com/android/internal/gmscompat/IGca2Gms.aidl b/core/java/com/android/internal/gmscompat/IGca2Gms.aidl
new file mode 100644
index 000000000000..455a638ab699
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/IGca2Gms.aidl
@@ -0,0 +1,16 @@
+package com.android.internal.gmscompat;
+
+import android.app.ApplicationErrorReport;
+import android.app.PendingIntent;
+import android.content.Intent;
+
+import com.android.internal.gmscompat.GmsCompatConfig;
+
+// calls from GmsCompatApp to GMS components
+interface IGca2Gms {
+    // intentionally not oneway to simplify code in GmsCompatApp
+    void updateConfig(in GmsCompatConfig newConfig);
+    void invalidateConfigCaches();
+
+    boolean startActivityIfVisible(in Intent intent);
+}
diff --git a/core/java/com/android/internal/gmscompat/IGms2Gca.aidl b/core/java/com/android/internal/gmscompat/IGms2Gca.aidl
new file mode 100644
index 000000000000..6fa24261a2d7
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/IGms2Gca.aidl
@@ -0,0 +1,46 @@
+package com.android.internal.gmscompat;
+
+import android.app.ApplicationErrorReport;
+import android.app.Notification;
+import android.app.PendingIntent;
+import android.content.Intent;
+import android.database.IContentObserver;
+import android.os.BinderDef;
+
+import com.android.internal.gmscompat.GmsCompatConfig;
+import com.android.internal.gmscompat.IGca2Gms;
+import com.android.internal.gmscompat.dynamite.server.IFileProxyService;
+
+// calls from GMS components to GmsCompatApp
+interface IGms2Gca {
+    GmsCompatConfig connectGmsCore(String processName, IGca2Gms iGca2Gms, @nullable IFileProxyService dynamiteFileProxyService);
+    GmsCompatConfig connect(String packageName, String processName, IGca2Gms iGca2Gms);
+
+    @nullable BinderDef maybeGetBinderDef(String callerPkg, int processState, String ifaceName);
+
+    oneway void onPlayStorePendingUserAction(in Intent actionIntent, @nullable String pkgName);
+    @nullable Intent maybeGetPlayStorePendingUserActionIntent();
+
+    oneway void showPlayStoreMissingObbPermissionNotification();
+
+    oneway void startActivityFromTheBackground(String callerPkg, in PendingIntent intent);
+
+    oneway void showGmsCoreMissingPermissionForNearbyShareNotification();
+
+    oneway void showGmsCoreMissingNearbyDevicesPermissionGeneric();
+
+    oneway void showMissingPostNotifsPermissionNotification(String callerPkg);
+
+    oneway void maybeShowContactsSyncNotification();
+
+    void onUncaughtException(in ApplicationErrorReport aer);
+    GmsCompatConfig requestConfigUpdate(String reason);
+
+    @nullable String privSettingsGetString(String ns, String key);
+    boolean privSettingsPutString(String ns, String key, @nullable String value);
+    boolean privSettingsPutStrings(String ns, in String[] keys, in String[] values);
+    void privSettingsRegisterObserver(String ns, String key, IContentObserver observer);
+    void privSettingsUnregisterObserver(IContentObserver observer);
+
+    Notification getMediaProjectionNotification();
+}
diff --git a/core/java/com/android/internal/gmscompat/PlayStoreHooks.java b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
new file mode 100644
index 000000000000..d557ee040aa1
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/PlayStoreHooks.java
@@ -0,0 +1,340 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat;
+
+import android.app.Activity;
+import android.app.PendingIntent;
+import android.app.compat.gms.GmsCompat;
+import android.app.usage.StorageStats;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.IntentSender;
+import android.content.pm.GosPackageState;
+import android.content.pm.IPackageDataObserver;
+import android.content.pm.IPackageDeleteObserver;
+import android.content.pm.PackageInstaller;
+import android.content.pm.PackageManager;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Environment;
+import android.os.RemoteException;
+import android.os.storage.StorageManager;
+import android.provider.Settings;
+import android.util.Log;
+
+import com.android.internal.gmscompat.util.GmcActivityUtils;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.Objects;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.BiConsumer;
+
+public final class PlayStoreHooks {
+    private static final String TAG = "GmsCompat/PlayStore";
+
+    static PackageManager packageManager;
+
+    public static void init() {
+        obbDir = Environment.getExternalStorageDirectory().getPath() + "/Android/obb";
+        playStoreObbDir = obbDir + '/' + GmsInfo.PACKAGE_PLAY_STORE;
+        File.mkdirsFailedHook = PlayStoreHooks::mkdirsFailed;
+        packageManager = GmsCompat.appContext().getPackageManager();
+    }
+
+    // PackageInstaller#createSession
+    public static void adjustSessionParams(PackageInstaller.SessionParams params) {
+        String pkg = Objects.requireNonNull(params.appPackageName);
+
+        switch (pkg) {
+            case GmsInfo.PACKAGE_GMS_CORE:
+            case GmsInfo.PACKAGE_PLAY_STORE:
+                String updateRequestReason = "Play Store created PackageInstaller SessionParams for " + pkg;
+                GmsCompatConfig config;
+                try {
+                    config = GmsCompatApp.iGms2Gca().requestConfigUpdate(updateRequestReason);
+                } catch (RemoteException e) {
+                    throw GmsCompatApp.callFailed(e);
+                }
+                if (GmsHooks.config().version != config.version) {
+                    GmsHooks.setConfig(config);
+                }
+                break;
+        }
+
+        switch (pkg) {
+            case GmsInfo.PACKAGE_GMS_CORE:
+                params.maxAllowedVersion = GmsHooks.config().maxGmsCoreVersion;
+                break;
+            case GmsInfo.PACKAGE_PLAY_STORE:
+                params.maxAllowedVersion = GmsHooks.config().maxPlayStoreVersion;
+                break;
+        }
+    }
+
+    // PackageInstaller.Session#commit(IntentSender)
+    public static IntentSender wrapCommitStatusReceiver(PackageInstaller.Session session, IntentSender statusReceiver) {
+        return PackageInstallerStatusForwarder.register((intent, extras) -> sendIntent(intent, statusReceiver))
+                .getIntentSender();
+    }
+
+    public static void onActivityResumed(Activity activity) {
+        Intent pendingActionIntent;
+        try {
+            pendingActionIntent = GmsCompatApp.iGms2Gca().maybeGetPlayStorePendingUserActionIntent();
+        } catch (RemoteException e) {
+            throw GmsCompatApp.callFailed(e);
+        }
+        if (pendingActionIntent != null) {
+            activity.startActivity(pendingActionIntent);
+        }
+    }
+
+    static class PackageInstallerStatusForwarder extends BroadcastReceiver {
+        private Context context;
+        private PendingIntent pendingIntent;
+        private BiConsumer<Intent, Bundle> target;
+
+        private static final AtomicLong lastId = new AtomicLong();
+
+        static PendingIntent register(BiConsumer<Intent, Bundle> target) {
+            PackageInstallerStatusForwarder sf = new PackageInstallerStatusForwarder();
+            Context context = GmsCompat.appContext();
+            sf.context = context;
+            sf.target = target;
+
+            String intentAction = context.getPackageName()
+                + "." + PackageInstallerStatusForwarder.class.getName() + "."
+                + lastId.getAndIncrement();
+
+            var intent = new Intent(intentAction);
+            intent.setPackage(context.getPackageName());
+
+            sf.pendingIntent = PendingIntent.getBroadcast(context, 0, intent,
+                    PendingIntent.FLAG_CANCEL_CURRENT |
+                        PendingIntent.FLAG_MUTABLE);
+
+            context.registerReceiver(sf, new IntentFilter(intentAction), Context.RECEIVER_NOT_EXPORTED);
+            return sf.pendingIntent;
+        }
+
+        public void onReceive(Context receiverContext, Intent intent) {
+            Bundle extras = intent.getExtras();
+            int status = getIntFromBundle(extras, PackageInstaller.EXTRA_STATUS);
+
+            if (status == PackageInstaller.STATUS_PENDING_USER_ACTION) {
+                Intent confirmationIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);
+
+                String packageName = null;
+
+                if (extras.containsKey(PackageInstaller.EXTRA_SESSION_ID)) {
+                    int sessionId = getIntFromBundle(extras, PackageInstaller.EXTRA_SESSION_ID);
+                    PackageInstaller pkgInstaller = packageManager.getPackageInstaller();
+                    PackageInstaller.SessionInfo si = pkgInstaller.getSessionInfo(sessionId);
+                    if (si != null) {
+                        packageName = si.getAppPackageName();
+                    }
+                }
+
+                try {
+                    GmsCompatApp.iGms2Gca().onPlayStorePendingUserAction(confirmationIntent, packageName);
+                } catch (RemoteException e) {
+                    GmsCompatApp.callFailed(e);
+                }
+
+                // confirmationIntent has a PendingIntent to this instance, don't unregister yet
+                return;
+            }
+            pendingIntent.cancel();
+            context.unregisterReceiver(this);
+
+            target.accept(intent, extras);
+        }
+    }
+
+    // Request user action to uninstall a package
+    public static void deletePackage(PackageManager pm, String packageName, IPackageDeleteObserver observer, int flags) {
+        if (flags != 0) {
+            throw new IllegalStateException("unexpected flags: " + flags);
+        }
+
+        // Play Store expects call to deletePackage() to always succeed, which almost always happens
+        // when it has the privileged DELETE_PACKAGES permission.
+        // This is not the case when Play Store has only the unprivileged REQUEST_DELETE_PACKAGES
+        // permission, which requires confirmation from the user.
+        // There are two difficulties:
+        // - user may reject the confirmation prompt, which produces DELETE_FAILED_ABORTED error code,
+        // which Play Store ignores
+        // - user may dismiss the confirmation prompt without making a choice, which doesn't make
+        // any callback at all
+        // In both cases, Play Store remains stuck in "Uninstalling..." state for that package.
+        // This state is written to persistent storage, it remains stuck even after device reboot.
+        //
+        // To work-around all these issues, pretend that the package was uninstalled and then installed
+        // again, which moves the package state from "Uninstalling..." to "Installed" state, and
+        // launch the uninstall request separately.
+
+        PendingIntent pi = PackageInstallerStatusForwarder.register((BiConsumer<Intent, Bundle>) (intent, extras) -> {
+            Log.d(TAG, "uninstall status " + extras.getString(PackageInstaller.EXTRA_STATUS_MESSAGE));
+        });
+        pm.getPackageInstaller().uninstall(packageName, pi.getIntentSender());
+
+        GmsCompat.appContext().getMainThreadHandler().postDelayed(() -> {
+            try {
+                // Play Store ignores this callback as of version 33.6.13, but provide it anyway
+                // in case it's fixed
+                observer.packageDeleted(packageName, PackageManager.DELETE_FAILED_ABORTED);
+            } catch (RemoteException e) {
+                throw e.rethrowAsRuntimeException();
+            }
+
+            resetPackageState(packageName);
+        }, 100L); // delay the callback for to workaround a race condition in Play Store
+    }
+
+    // If state transition that is expected to never fail by Play Store does fail, it may get stuck
+    // in the old state. This happens, for example, when package uninstall fails.
+    // To work-around this, pretend that the package was removed and installed again
+    public static void resetPackageState(String packageName) {
+        updatePackageState(packageName, Intent.ACTION_PACKAGE_REMOVED, Intent.ACTION_PACKAGE_ADDED);
+    }
+
+    public static void updatePackageState(String packageName, String... broadcasts) {
+        Context context = GmsCompat.appContext();
+
+        // default ClassLoader fails to load the needed class
+        ClassLoader cl = context.getClassLoader();
+
+        // Depending on Play Store version, target class can be in packagemonitor or in
+        // packagemanager package, support both
+        String[] classNames = {
+            "com.google.android.finsky.packagemonitor.impl.PackageMonitorReceiverImpl$RegisteredReceiver",
+            "com.google.android.finsky.packagemanager.impl.PackageMonitorReceiverImpl$RegisteredReceiver",
+        };
+
+        for (String className : classNames) {
+            try {
+                Class cls = Class.forName(className, true, cl);
+
+                for (String action : broadcasts) {
+                    // don't reuse BroadcastReceiver, it's expected that a new instance is made each time
+                    BroadcastReceiver br = (BroadcastReceiver) cls.newInstance();
+                    br.onReceive(context, new Intent(action, packageUri(packageName)));
+                }
+            } catch (ReflectiveOperationException e) {
+                Log.d(TAG, "", e);
+                continue;
+            }
+            break;
+        }
+    }
+
+    // Called during self-update sequence because PackageManager requires
+    // the restricted CLEAR_APP_CACHE permission
+    public static void freeStorageAndNotify(String volumeUuid, long idealStorageSize,
+            IPackageDataObserver observer) {
+        if (volumeUuid != null) {
+            throw new IllegalStateException("unexpected volumeUuid " + volumeUuid);
+        }
+        StorageManager sm = GmsCompat.appContext().getSystemService(StorageManager.class);
+        boolean success = false;
+        try {
+            sm.allocateBytes(StorageManager.UUID_DEFAULT, idealStorageSize);
+            success = true;
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        try {
+            // same behavior as PackageManagerService#freeStorageAndNotify()
+            String packageName = null;
+            observer.onRemoveCompleted(packageName, success);
+        } catch (RemoteException e) {
+            throw e.rethrowAsRuntimeException();
+        }
+    }
+
+    // StorageStatsManager#queryStatsForPackage(UUID, String, UserHandle)
+    public static StorageStats queryStatsForPackage(String packageName) throws PackageManager.NameNotFoundException {
+        String apkPath = packageManager.getApplicationInfo(packageName, 0).sourceDir;
+
+        StorageStats stats = new StorageStats();
+        stats.codeBytes = new File(apkPath).length();
+        // leave dataBytes, cacheBytes, externalCacheBytes at 0
+        return stats;
+    }
+
+    // ApplicationPackageManager#setApplicationEnabledSetting
+    public static void setApplicationEnabledSetting(String packageName, int newState) {
+        if (newState == PackageManager.COMPONENT_ENABLED_STATE_ENABLED
+                    && GmcActivityUtils.getMostRecentVisibleActivity() != null)
+        {
+            openAppSettings(packageName);
+        }
+    }
+
+    private static String obbDir;
+    private static String playStoreObbDir;
+
+    // File#mkdirs()
+    public static void mkdirsFailed(File file) {
+        String path = file.getPath();
+
+        if (path.startsWith(obbDir) && !path.startsWith(playStoreObbDir)) {
+            GosPackageState ps = GosPackageState.get(GmsCompat.appContext().getPackageName());
+            boolean hasObbAccess = ps != null && ps.hasFlag(GosPackageState.FLAG_ALLOW_ACCESS_TO_OBB_DIRECTORY);
+
+            if (!hasObbAccess) {
+                try {
+                    GmsCompatApp.iGms2Gca().showPlayStoreMissingObbPermissionNotification();
+                } catch (RemoteException e) {
+                    GmsCompatApp.callFailed(e);
+                }
+            }
+        }
+    }
+
+    static Uri packageUri(String packageName) {
+        return Uri.fromParts("package", packageName, null);
+    }
+
+    // Unfortunately, there's no other way to ensure that the value is present and is of the right type.
+    // Note that Intent.getExtras() makes a copy of the Bundle each time, so reuse its result
+    static int getIntFromBundle(Bundle b, String key) {
+        return ((Integer) b.get(key)).intValue();
+    }
+
+    static void openAppSettings(String packageName) {
+        Intent i = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
+        i.setData(packageUri(packageName));
+        // FLAG_ACTIVITY_CLEAR_TASK is needed to ensure that the right screen is shown (it's a bug in the Settings app)
+        i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
+        GmsCompat.appContext().startActivity(i);
+    }
+
+    static void sendIntent(Intent intent, IntentSender target) {
+        try {
+            target.sendIntent(GmsCompat.appContext(), 0, intent, null, null);
+        } catch (IntentSender.SendIntentException e) {
+            Log.d(TAG, "", e);
+        }
+    }
+
+    private PlayStoreHooks() {}
+}
diff --git a/core/java/com/android/internal/gmscompat/StubDef.java b/core/java/com/android/internal/gmscompat/StubDef.java
new file mode 100644
index 000000000000..c4ea421bb498
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/StubDef.java
@@ -0,0 +1,293 @@
+/*
+ * Copyright (C) 2022 GrapheneOS
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package com.android.internal.gmscompat;
+
+import android.annotation.Nullable;
+import android.app.compat.gms.GmsCompat;
+import android.content.pm.ParceledListSlice;
+import android.content.pm.StringParceledListSlice;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.ArrayMap;
+import android.util.Log;
+
+import java.lang.reflect.Method;
+import java.util.Collections;
+import java.util.List;
+
+import libcore.util.SneakyThrow;
+
+public class StubDef implements Parcelable {
+    private static final String TAG = "StubDef";
+
+    public int type;
+    public long integerVal;
+    public double doubleVal;
+    public String stringVal;
+    private volatile Class parcelListType;
+
+    public static final int VOID = 0;
+    public static final int NULL = 1; // only for types that implement Parcelable
+    public static final int NULL_STRING = 2;
+    public static final int NULL_ARRAY = 3;
+    public static final int EMPTY_BYTE_ARRAY = 4;
+    public static final int EMPTY_INT_ARRAY = 5;
+    public static final int EMPTY_LONG_ARRAY = 6;
+    public static final int EMPTY_STRING = 7;
+    public static final int EMPTY_LIST = 8;
+    public static final int EMPTY_MAP = 9;
+
+    public static final int BOOLEAN = 10;
+    public static final int BYTE = 11;
+    public static final int INT = 12;
+    public static final int LONG = 13;
+    public static final int FLOAT = 14;
+    public static final int DOUBLE = 15;
+    public static final int STRING = 16;
+
+    public static final int THROW = 17;
+
+    // see com.android.modules.utils.SynchronousResultReceiver.Result#getValue()
+    public static final int DEFAULT = 18;
+
+    public static final int FIND_MODE_Parcel = 0;
+    public static final int FIND_MODE_SynchronousResultReceiver = 1;
+
+    @Nullable
+    public static StubDef find(StackTraceElement[] stackTrace, GmsCompatConfig config, int mode) {
+        int firstIndex;
+        if (mode == FIND_MODE_Parcel) {
+            // first four stack trace entries are known:
+            // android.os.Parcel.createExceptionOrNull
+            // android.os.Parcel.createException
+            // android.os.Parcel.readException
+            // android.os.Parcel.readException
+            firstIndex = 4;
+        } else if (mode == FIND_MODE_SynchronousResultReceiver) {
+            // first entry is from GmsModuleHooks method
+            firstIndex = 1;
+        } else {
+            return null;
+        }
+
+        ClassLoader defaultClassLoader = GmsCompat.appContext().getClassLoader();
+
+        StackTraceElement targetMethod = null;
+        Class stubProxyClass = null;
+        String stubProxyMethodName = null;
+
+        // Iterate through the stack trace to find out which API call caused the exception
+        for (int i = firstIndex; i < stackTrace.length; ++i) {
+            StackTraceElement ste = stackTrace[i];
+            String className = ste.getClassName();
+            Class class_;
+            try {
+                class_ = Class.forName(className, false, defaultClassLoader);
+            } catch (ClassNotFoundException cnfe) {
+                class_ = null;
+            }
+
+            if (class_ != null) {
+                ClassLoader classLoader = class_.getClassLoader();
+                if (classLoader == null) {
+                    return null;
+                }
+
+                String loaderName = classLoader.getClass().getName();
+
+                if ("java.lang.BootClassLoader".equals(loaderName)) {
+                    if (stubProxyClass == null && className.endsWith("$Stub$Proxy")) {
+                        stubProxyClass = class_;
+                        stubProxyMethodName = ste.getMethodName();
+                    }
+                    if (!className.startsWith("java.lang.reflect.")) {
+                        // app classes are never loaded with BootClassLoader
+                        continue;
+                    } // else target method is the previous entry that was invoked via reflection
+                }
+            }
+
+            if (mode == FIND_MODE_Parcel && stubProxyClass == null) {
+                return null;
+            }
+
+            if (i == firstIndex) {
+                return null;
+            }
+
+            targetMethod = stackTrace[i - 1];
+            break;
+        }
+
+        if (targetMethod == null) {
+            return null;
+        }
+
+        ArrayMap<String, StubDef> classStubs = config.stubs.get(targetMethod.getClassName());
+
+        if (classStubs == null) {
+            return null;
+        }
+
+        StubDef stub = classStubs.get(targetMethod.getMethodName());
+
+        if (stub == null) {
+            return null;
+        }
+
+        if (stub.type == EMPTY_LIST && stub.parcelListType == null) {
+            if (stubProxyClass == null) {
+                Log.d(TAG, "stub proxy class not found for " + targetMethod);
+                return null;
+            }
+
+            for (Method m : stubProxyClass.getDeclaredMethods()) {
+                if (stubProxyMethodName.equals(m.getName())) {
+                    stub.parcelListType = m.getReturnType();
+                    break;
+                }
+            }
+
+            if (stub.parcelListType == null) {
+                Log.d(TAG, "stub proxy method not found for " + targetMethod);
+                return null;
+            }
+        }
+
+        return stub;
+    }
+
+    public boolean stubOutMethod(Parcel p) {
+        p.setDataPosition(0);
+        p.setDataSize(0);
+
+        final long integer = integerVal;
+
+        switch (type) {
+            case VOID:
+                break;
+            case NULL:
+                p.writeTypedObject((Parcelable) null, 0);
+                break;
+            case NULL_STRING:
+                p.writeString(null);
+                break;
+            case NULL_ARRAY:
+                p.writeInt(-1);
+                break;
+            case EMPTY_BYTE_ARRAY:
+                p.writeByteArray(new byte[0]);
+                break;
+            case EMPTY_INT_ARRAY:
+                p.writeIntArray(new int[0]);
+                break;
+            case EMPTY_LONG_ARRAY:
+                p.writeLongArray(new long[0]);
+                break;
+            case EMPTY_STRING:
+                p.writeString("");
+                break;
+            case EMPTY_LIST: {
+                Class t = parcelListType;
+                if (t == List.class) {
+                    p.writeList(Collections.emptyList());
+                } else {
+                    String listTypeName = t.getName();
+                    // There is android.content.pm.ParceledListSlice and
+                    // com.android.modules.utils.ParceledListSlice.
+                    // Moreover, when the latter is used in an APEX, it's prefixed like this:
+                    // com.android.wifi.x.com.android.modules.utils.ParceledListSlice
+
+                    // Same applies to StringParceledListSlice.
+
+                    if (listTypeName.endsWith(".ParceledListSlice")) {
+                        p.writeTypedObject(ParceledListSlice.emptyList(), 0);
+                    } else if (listTypeName.endsWith(".StringParceledListSlice")) {
+                        p.writeTypedObject(StringParceledListSlice.emptyList(), 0);
+                    } else {
+                        Log.d(TAG, "unknown parcel list type " + listTypeName);
+                        return false;
+                    }
+                }
+                break;
+            }
+            case EMPTY_MAP:
+                p.writeMap(Collections.emptyMap());
+                break;
+            case BOOLEAN:
+                p.writeBoolean(integer != 0);
+                break;
+            case BYTE:
+                p.writeByte((byte) integer);
+                break;
+            case INT:
+                p.writeInt((int) integer);
+                break;
+            case LONG:
+                p.writeLong(integer);
+                break;
+            case FLOAT:
+                p.writeFloat((float) doubleVal);
+                break;
+            case DOUBLE:
+                p.writeDouble(doubleVal);
+                break;
+            case STRING:
+                p.writeString(stringVal);
+                break;
+            case THROW: {
+                Throwable t;
+                try {
+                    Class class_ = Class.forName(stringVal);
+                    t = (Throwable) class_.newInstance();
+                } catch (ReflectiveOperationException e) {
+                    Log.e(TAG, "", e);
+                    return false;
+                }
+                SneakyThrow.sneakyThrow(t);
+                break;
+            }
+            default:
+                Log.i(TAG, "unknown type " + type);
+                // it's fine that Parcel is reset at this point, it won't be read:
+                // a pending exception will be thrown when this method returns false
+                return false;
+        }
+
+        p.setDataPosition(0);
+        return true;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel p, int flags) {
+        p.writeInt(type);
+        p.writeLong(integerVal);
+        p.writeDouble(doubleVal);
+        p.writeString(stringVal);
+    }
+
+    public static final Parcelable.Creator<StubDef> CREATOR = new Creator<>() {
+        @Override
+        public StubDef createFromParcel(Parcel p) {
+            StubDef d = new StubDef();
+            d.type = p.readInt();
+            d.integerVal = p.readLong();
+            d.doubleVal = p.readDouble();
+            d.stringVal = p.readString();
+            return d;
+        }
+
+        @Override
+        public StubDef[] newArray(int size) {
+            return new StubDef[size];
+        }
+    };
+}
diff --git a/core/java/com/android/internal/gmscompat/client/ClientPriorityManager.java b/core/java/com/android/internal/gmscompat/client/ClientPriorityManager.java
new file mode 100644
index 000000000000..361a396de2da
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/client/ClientPriorityManager.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.client;
+
+import android.annotation.Nullable;
+import android.app.compat.gms.GmsCompat;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.os.PowerExemptionManager;
+import android.util.Log;
+
+import com.android.internal.gmscompat.GmsInfo;
+
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+
+// See GmsCompatClientService for an explanation
+public class ClientPriorityManager implements ServiceConnection, Runnable {
+    private static final String TAG = "ClientPriorityManager";
+    private static final boolean LOGV = false;
+
+    private static final ScheduledExecutorService unbindExecutor = Executors.newSingleThreadScheduledExecutor();
+
+    private boolean unbound;
+
+    private ClientPriorityManager() {}
+
+    public static void raiseToForeground(String targetPkg, long durationMs, @Nullable String reason, int reasonCode) {
+        if (durationMs <= 0) {
+            return;
+        }
+
+        if (targetPkg.equals(GmsInfo.PACKAGE_GMS_CORE)) {
+            // always foreground, and doesn't have the GmsCompatClientService
+            return;
+        }
+
+        Log.d(TAG, "emulating temporary PowerExemptionManager allowlist for " + targetPkg
+            + ", duration: " + durationMs
+            + ", reason: " + reason
+            + ", reasonCode: " + PowerExemptionManager.reasonCodeToString(reasonCode));
+
+        raiseToForeground(targetPkg, durationMs);
+    }
+
+    public static void raiseToForeground(String targetPkg, long durationMs) {
+        Intent intent = new Intent();
+        intent.setClassName(targetPkg, GmsCompatClientService.class.getName());
+
+        ClientPriorityManager csc = new ClientPriorityManager();
+
+        if (GmsCompat.appContext().bindService(intent, csc, Context.BIND_AUTO_CREATE)) {
+            unbindExecutor.schedule(csc, durationMs, TimeUnit.MILLISECONDS);
+
+            if (LOGV) {
+                Log.d(TAG, "bound to " + targetPkg);
+            }
+        } else {
+            Log.e(TAG, "unable to bind to " + targetPkg, new Exception());
+        }
+    }
+
+    @Override
+    public void run() {
+        if (LOGV) {
+            Log.d(TAG, "timeout expired, unbinding");
+        }
+        unbind();
+    }
+
+    private void unbind() {
+        synchronized (this) {
+            if (!unbound) {
+                GmsCompat.appContext().unbindService(this);
+                unbound = true;
+            }
+        }
+    }
+
+    @Override
+    public void onServiceConnected(ComponentName name, IBinder service) {
+        if (LOGV) {
+            Log.d(TAG, "onServiceConnected " + name);
+        }
+    }
+
+    @Override
+    public void onServiceDisconnected(ComponentName name) {
+        Log.e(TAG, "onServiceDisconnected " + name);
+    }
+
+    @Override
+    public void onBindingDied(ComponentName name) {
+        Log.d(TAG, "onBindingDied " + name);
+        unbind();
+    }
+
+    @Override
+    public void onNullBinding(ComponentName name) {
+        Log.e(TAG, "onNullBinding " + name);
+        unbind();
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/client/GmsCompatClientService.java b/core/java/com/android/internal/gmscompat/client/GmsCompatClientService.java
new file mode 100644
index 000000000000..0bb4c73b6399
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/client/GmsCompatClientService.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.client;
+
+import android.app.Service;
+import android.content.Intent;
+import android.os.Binder;
+import android.os.IBinder;
+
+/*
+The sole purpose of this service is to provide a way to move a client of GMS Core
+out of the background state by binding to it from a foreground process.
+
+Privileged GMS Core achieves this by sending a privileged broadcast with
+BroadcastOptions#setTemporaryAppAllowlist() option set.
+
+A declaration of this service is added to all clients of GMS Core during package parsing,
+see GmsClientHooks#maybeAddServiceDuringParsing()
+ */
+public class GmsCompatClientService extends Service {
+    private static final Binder dummyBinder = new Binder();
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return dummyBinder;
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteClientHooks.java b/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteClientHooks.java
new file mode 100644
index 000000000000..099adab2357e
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/dynamite/GmsDynamiteClientHooks.java
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.dynamite;
+
+import android.app.compat.gms.GmsCompat;
+import android.content.Context;
+import android.content.res.ApkAssets;
+import android.content.res.loader.AssetsProvider;
+import android.os.Environment;
+import android.os.IBinder;
+import android.os.ParcelFileDescriptor;
+import android.os.RemoteException;
+import android.util.ArrayMap;
+import android.util.Log;
+
+import com.android.internal.gmscompat.GmsCompatApp;
+import com.android.internal.gmscompat.GmsInfo;
+import com.android.internal.gmscompat.dynamite.server.IFileProxyService;
+
+import java.io.File;
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.util.regex.Pattern;
+
+import dalvik.system.DelegateLastClassLoader;
+
+public final class GmsDynamiteClientHooks {
+    static final String TAG = "GmsCompat/DynamiteClient";
+    private static final boolean DEBUG = false;
+
+    // written last in the init sequence, "volatile" to publish all the preceding writes
+    private static volatile boolean enabled;
+    private static String gmsCoreDataPrefix;
+    private static ArrayMap<String, ParcelFileDescriptor> pfdCache;
+    private static IFileProxyService fileProxyService;
+
+    public static boolean enabled() {
+        return enabled;
+    }
+
+    // ContentResolver#acquireProvider(Uri)
+    public static void maybeInit(String auth) {
+        if (!"com.google.android.gms.chimera".equals(auth)) {
+            return;
+        }
+        synchronized (GmsDynamiteClientHooks.class) {
+            if (enabled()) {
+                return;
+            }
+            if (!GmsCompat.isClientOfGmsCore()) {
+                return;
+            }
+            // faster than ctx.createPackageContext().createDeviceProtectedStorageContext().getDataDir()
+            int userId = GmsCompat.appContext().getUserId();
+            String deDataDirectory = Environment.getDataUserDeDirectory(null, userId).getPath();
+            gmsCoreDataPrefix = deDataDirectory + '/' + GmsInfo.PACKAGE_GMS_CORE + '/';
+            pfdCache = new ArrayMap<>(20);
+
+            try {
+                IFileProxyService service = GmsCompatApp.iClientOfGmsCore2Gca().getDynamiteFileProxyService();
+                service.asBinder().linkToDeath(() -> {
+                    // When GMS Core gets terminated (including package updates and crashes),
+                    // processes of Dynamite clients get terminated too (same behavior on stock OS,
+                    // likely to avoid hard-to-resolve situation when client starts to load
+                    // modules from one GMS Core version and then GMS Core gets updated before the rest of the
+                    // modules are loaded).
+                    // This ensures that pfdCache never returns stale file descriptors,
+                    // because there's only two types of Dynamite modules:
+                    // - "core", included with the GMS Core package and always extracted
+                    // to the app_chimera/m directory, may have the same name on different GMS Core versions
+                    // - on-demand, downloaded on first use, each version has a unique file name
+
+                    Log.d(TAG, "FileProxyService died");
+                    // isn't reached in practice, at least on current versions (2022 Q1)
+                    System.exit(0);
+                }, 0);
+
+                fileProxyService = service;
+            } catch (Throwable e) {
+                // linkToDeath() failed,
+                // most likely because GMS Core crashed very shortly before getDynamiteFileProxyService(),
+                // which should be very rare in practice.
+                // Waiting for GMS Core to respawn is hard to do correctly, not worth the complexity increase
+                Log.e(TAG, "unable to obtain the FileProxyService", e);
+                System.exit(1);
+            }
+
+            File.lastModifiedHook = GmsDynamiteClientHooks::getFileLastModified;
+            DelegateLastClassLoader.modifyClassLoaderPathHook = GmsDynamiteClientHooks::maybeModifyClassLoaderPath;
+            enabled = true;
+        }
+    }
+
+    // ApkAssets#loadFromPath(String, int, AssetsProvider)
+    public static ApkAssets loadAssetsFromPath(String path, int flags, AssetsProvider assets) throws IOException {
+        if (!path.startsWith(gmsCoreDataPrefix)) {
+            return null;
+        }
+        FileDescriptor fd = modulePathToFd(path);
+        // no need to dup the fd, ApkAssets does it itself
+        return ApkAssets.loadFromFd(fd, path, flags, assets);
+    }
+
+    // To fix false-positive "Module APK has been modified" check
+    // File#lastModified()
+    public static long getFileLastModified(File file) {
+        final String path = file.getPath();
+
+        if (enabled && path.startsWith(gmsCoreDataPrefix)) {
+            String fdPath = "/proc/self/fd/" + modulePathToFd(path).getInt$();
+            return new File(fdPath).lastModified();
+        }
+        return 0L;
+    }
+
+    // Replaces file paths of Dynamite modules with "/proc/self/fd" file descriptor references
+    // DelegateLastClassLoader#maybeModifyClassLoaderPath(String, Boolean)
+    public static String maybeModifyClassLoaderPath(String path, Boolean nativeLibsPathB) {
+        if (path == null) {
+            return null;
+        }
+        if (!enabled) { // libcore code doesn't have access to this field
+            return path;
+        }
+        boolean nativeLibsPath = nativeLibsPathB.booleanValue();
+        String[] pathParts = path.split(Pattern.quote(File.pathSeparator));
+        boolean modified = false;
+
+        for (int i = 0; i < pathParts.length; ++i) {
+            String pathPart = pathParts[i];
+            if (!pathPart.startsWith(gmsCoreDataPrefix)) {
+                continue;
+            }
+            // defined in bionic/linker/linker_utils.cpp kZipFileSeparator
+            final String zipFileSeparator = "!/";
+
+            String filePath;
+            String nativeLibRelPath;
+            if (nativeLibsPath) {
+                int idx = pathPart.indexOf(zipFileSeparator);
+                filePath = pathPart.substring(0, idx);
+                nativeLibRelPath = pathPart.substring(idx + zipFileSeparator.length());
+            } else {
+                filePath = pathPart;
+                nativeLibRelPath = null;
+            }
+            String fdFilePath = "/gmscompat_fd_" + modulePathToFd(filePath).getInt$();
+
+            pathParts[i] = nativeLibsPath ?
+                fdFilePath + zipFileSeparator + nativeLibRelPath :
+                fdFilePath;
+
+            modified = true;
+        }
+        if (!modified) {
+            return path;
+        }
+        return String.join(File.pathSeparator, pathParts);
+    }
+
+    // Returned file descriptor should never be closed, because it may be dup()-ed at any time by the native code
+    private static FileDescriptor modulePathToFd(String path) {
+        if (DEBUG) {
+            new Exception("path " + path).printStackTrace();
+        }
+        try {
+            ArrayMap<String, ParcelFileDescriptor> cache = pfdCache;
+            // this lock isn't contended, favor simplicity, not making the critical section shorter
+            synchronized (cache) {
+                ParcelFileDescriptor pfd = cache.get(path);
+                if (pfd == null) {
+                    pfd = fileProxyService.openFile(path);
+                    if (pfd == null) {
+                        throw new IllegalStateException("unable to open " + path);
+                    }
+                    // ParcelFileDescriptor owns the underlying file descriptor
+                    cache.put(path, pfd);
+                }
+                return pfd.getFileDescriptor();
+            }
+        } catch (RemoteException e) {
+            // FileProxyService never forwards exceptions to minimize the information leaks,
+            // this is a very rare "binder died" exception
+            throw e.rethrowAsRuntimeException();
+        }
+    }
+
+    private GmsDynamiteClientHooks() {}
+}
diff --git a/core/java/com/android/internal/gmscompat/dynamite/server/FileProxyService.java b/core/java/com/android/internal/gmscompat/dynamite/server/FileProxyService.java
new file mode 100644
index 000000000000..d626f4de2934
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/dynamite/server/FileProxyService.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.dynamite.server;
+
+import android.content.Context;
+import android.os.ParcelFileDescriptor;
+import android.system.ErrnoException;
+import android.system.Os;
+import android.system.OsConstants;
+import android.util.Log;
+
+import java.io.File;
+import java.io.FileDescriptor;
+import java.io.IOException;
+
+public final class FileProxyService extends IFileProxyService.Stub {
+    public static final String TAG = "GmsCompat/DynamiteServer";
+    private static final String CHIMERA_REL_PATH = "app_chimera/m/";
+
+    private final String chimeraRoot;
+
+    public FileProxyService(Context context) {
+        File deDataRoot = context.createDeviceProtectedStorageContext().getDataDir();
+        chimeraRoot = deDataRoot.getPath() + "/" + CHIMERA_REL_PATH;
+    }
+
+    @Override
+    public ParcelFileDescriptor openFile(String rawPath) {
+        try {
+            String path = sanitizeModulePath(rawPath);
+            if (path != null) {
+                FileDescriptor fd = Os.open(path, OsConstants.O_RDONLY | OsConstants.O_CLOEXEC, 0);
+//                Log.d(TAG, "Opened " + rawPath + " for remote, fd " + fd.getInt$());
+                return new ParcelFileDescriptor(fd);
+            }
+        } catch (IOException | ErrnoException e) {
+            Log.d(TAG, "failed security check", e);
+        } catch (Throwable t) {
+            Log.d(TAG, "unexpected error", t);
+        }
+        // don't forward exceptions to the untrusted caller to minimize the information leaks
+        return null;
+    }
+
+    private String sanitizeModulePath(String rawPath) throws IOException, ErrnoException {
+        // Normalize path for security checks
+        String path = new File(rawPath).getCanonicalPath();
+
+        // Modules can only be in DE Chimera storage
+        if (!path.startsWith(chimeraRoot)) {
+            Log.d(TAG, "Path " + rawPath + " is not in " + chimeraRoot);
+            return null;
+        }
+
+        if (!path.endsWith(".apk")) {
+            Log.d(TAG, "Path " + rawPath + " is not an APK file");
+            return null;
+        }
+        // Make sure that all path components below chimeraRoot are world-accessible
+        {
+            // Check full path first to simplify checks of its parents
+            int mode = Os.stat(path).st_mode;
+
+            boolean valid = OsConstants.S_ISREG(mode) && (mode & OsConstants.S_IROTH) != 0;
+            if (!valid) {
+                Log.d(TAG, "Path " + path + " is not a world-readable regular file");
+                return null;
+            }
+        }
+        for (int i = chimeraRoot.length(), m = path.length(); i < m; ++i) {
+            if (path.charAt(i) != '/') {
+                continue;
+            }
+            String dirPath = path.substring(0, i);
+            int mode = Os.stat(dirPath).st_mode;
+
+            boolean valid = OsConstants.S_ISDIR(mode) && (mode & OsConstants.S_IXOTH) != 0;
+            if (!valid) {
+                Log.d(TAG, "Node " + dirPath + " in path " + path + " is not a world-readable directory");
+                return null;
+            }
+        }
+        return path;
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/dynamite/server/IFileProxyService.aidl b/core/java/com/android/internal/gmscompat/dynamite/server/IFileProxyService.aidl
new file mode 100644
index 000000000000..678d21f8fe4f
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/dynamite/server/IFileProxyService.aidl
@@ -0,0 +1,5 @@
+package com.android.internal.gmscompat.dynamite.server;
+
+interface IFileProxyService {
+    ParcelFileDescriptor openFile(String path);
+}
diff --git a/core/java/com/android/internal/gmscompat/flags/GmsFlag.java b/core/java/com/android/internal/gmscompat/flags/GmsFlag.java
new file mode 100644
index 000000000000..b1e0be535ec3
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/flags/GmsFlag.java
@@ -0,0 +1,300 @@
+/*
+ * Copyright (C) 2022 GrapheneOS
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+package com.android.internal.gmscompat.flags;
+
+import android.annotation.Nullable;
+import android.app.compat.gms.GmsCompat;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.ArrayMap;
+import android.util.Base64;
+import android.util.Log;
+
+import com.android.internal.gmscompat.GmsInfo;
+
+import java.util.Map;
+import java.util.function.Supplier;
+
+public class GmsFlag implements Parcelable {
+    private static final String TAG = "GmsFlag";
+
+    public String name;
+
+    public static final int TYPE_BOOL = 0;
+    public static final int TYPE_INT = 1;
+    public static final int TYPE_FLOAT = 2;
+    public static final int TYPE_STRING = 3;
+    public static final int TYPE_BYTES = 4;
+    public byte type;
+
+    public static final int ACTION_SET = 0;
+    public static final int ACTION_APPEND = 1; // only for TYPE_STRING
+    public byte action;
+
+    public boolean boolArg;
+    public long integerArg;
+    public double floatArg;
+    public String stringArg;
+    public byte[] bytesArg;
+
+    public @Nullable Supplier valueSupplier;
+
+    public byte permissionCheckMode;
+    public static final int PERMISSION_CHECK_MODE_NONE_OF = 0;
+    public static final int PERMISSION_CHECK_MODE_NOT_ALL_OF = 1;
+    public static final int PERMISSION_CHECK_MODE_ALL_OF = 2;
+    public @Nullable String[] permissions;
+
+    public static final String NAMESPACE_GSERVICES = "gservices";
+
+    public static final String GSERVICES_URI = "content://"
+            + GmsInfo.PACKAGE_GSF + '.' + NAMESPACE_GSERVICES + "/prefix";
+
+    public static final String PHENOTYPE_URI_PREFIX = "content://"
+            + GmsInfo.PACKAGE_GMS_CORE + ".phenotype/";
+
+    public GmsFlag() {}
+
+    public GmsFlag(String name) {
+        this.name = name;
+    }
+
+    private boolean permissionsMatch() {
+        String[] perms = permissions;
+        if (perms == null) {
+            return true;
+        }
+
+        int numOfGrantedPermissions = 0;
+
+        for (String perm : perms) {
+            if (GmsCompat.hasPermission(perm)) {
+                ++numOfGrantedPermissions;
+            }
+        }
+
+        switch (permissionCheckMode) {
+            case PERMISSION_CHECK_MODE_NONE_OF:
+                return numOfGrantedPermissions == 0;
+            case PERMISSION_CHECK_MODE_NOT_ALL_OF:
+                return numOfGrantedPermissions != perms.length;
+            case PERMISSION_CHECK_MODE_ALL_OF:
+                return numOfGrantedPermissions == perms.length;
+            default:
+                return false;
+        }
+    }
+
+    public void applyToGservicesMap(ArrayMap<String, String> map) {
+        if (!shouldOverride()) {
+            return;
+        }
+
+        if (type != TYPE_STRING) {
+            // all Gservices flags are Strings
+            throw new IllegalStateException();
+        }
+
+        maybeOverrideString(map);
+    }
+
+    private static final int PHENOTYPE_BASE64_FLAGS = Base64.NO_PADDING | Base64.NO_WRAP;
+
+    public void applyToPhenotypeMap(Map map) {
+        if (!shouldOverride()) {
+            return;
+        }
+
+        if (valueSupplier != null) {
+            Object val = valueSupplier.get();
+
+            String s;
+            if (type == TYPE_BYTES) {
+                s = Base64.encodeToString((byte[]) val, PHENOTYPE_BASE64_FLAGS);
+            } else {
+                s = val.toString();
+            }
+
+            map.put(name, s);
+            return;
+        }
+
+        String s;
+        switch (type) {
+            case TYPE_BOOL:
+                s = boolArg ? "1" : "0";
+                break;
+            case TYPE_INT:
+                s = Long.toString(integerArg);
+                break;
+            case TYPE_FLOAT:
+                s = Double.toString(floatArg);
+                break;
+            case TYPE_STRING:
+                maybeOverrideString(map);
+                return;
+            case TYPE_BYTES:
+                s = Base64.encodeToString(bytesArg, PHENOTYPE_BASE64_FLAGS);
+                break;
+            default:
+                return;
+        }
+
+        map.put(name, s);
+    }
+
+    public boolean shouldOverride() {
+        if (!permissionsMatch()) {
+            return false;
+        }
+
+        return true;
+    }
+
+    // method names and types match columns in phenotype.db database, tables Flags and FlagOverrides
+
+    public int boolVal(int orig) {
+        if (type != TYPE_BOOL) {
+            logTypeMismatch();
+            return orig;
+        }
+        if (valueSupplier != null) {
+            boolean v = ((Boolean) valueSupplier.get()).booleanValue();
+            return v ? 1 : 0;
+        }
+        return boolArg ? 1 : 0;
+    }
+
+    public long intVal(long orig) {
+        if (type != TYPE_INT) {
+            logTypeMismatch();
+            return orig;
+        }
+        if (valueSupplier != null) {
+            return ((Long) valueSupplier.get()).longValue();
+        }
+        return integerArg;
+    }
+
+    public double floatVal(double orig) {
+        if (type != TYPE_FLOAT) {
+            logTypeMismatch();
+            return orig;
+        }
+        if (valueSupplier != null) {
+            return ((Double) valueSupplier.get()).doubleValue();
+        }
+        return floatArg;
+    }
+
+    public void maybeOverrideString(Map map) {
+        if (type != TYPE_STRING) {
+            logTypeMismatch();
+            return;
+        }
+        if (valueSupplier != null) {
+            map.put(name, valueSupplier.get());
+            return;
+        }
+
+        if (action == ACTION_SET) {
+            map.put(name, stringArg);
+            return;
+        }
+
+        if (action == ACTION_APPEND) {
+            if (!map.containsKey(name)) {
+                Log.d(TAG, name + " is not present in the map, skipping ACTION_APPEND");
+                return;
+            }
+
+            Object orig = map.get(name);
+
+            if (!(orig instanceof String)) {
+                Log.w(TAG, "original value of " +  name + " is not a string, skipping ACTION_APPEND. Value: " + orig);
+                return;
+            }
+
+            map.put(name, (String) orig + stringArg);
+            return;
+        }
+
+        Log.d(TAG, "unknown action " + action + " for " + name);
+    }
+
+    public byte[] extensionVal(byte[] orig) {
+        if (type != TYPE_BYTES) {
+            logTypeMismatch();
+            return orig;
+        }
+        if (valueSupplier != null) {
+            return (byte[]) valueSupplier.get();
+        }
+        return bytesArg;
+    }
+
+    public void initAsSetString(String v) {
+        type = GmsFlag.TYPE_STRING;
+        action = GmsFlag.ACTION_SET;
+        stringArg = v;
+    }
+
+    private void logTypeMismatch() {
+        Log.e(TAG, "type mismatch for key " + name, new Throwable());
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel p, int flags) {
+        p.writeString(name);
+        p.writeByte(type);
+        p.writeByte(permissionCheckMode);
+        p.writeStringArray(permissions);
+        p.writeByte(action);
+        p.writeBoolean(boolArg);
+        p.writeLong(integerArg);
+        p.writeDouble(floatArg);
+        p.writeString(stringArg);
+        p.writeByteArray(bytesArg);
+    }
+
+    public static final Parcelable.Creator<GmsFlag> CREATOR = new Creator<>() {
+        @Override
+        public GmsFlag createFromParcel(Parcel p) {
+            GmsFlag f = new GmsFlag();
+            f.name = p.readString();
+            f.type = p.readByte();
+            f.permissionCheckMode = p.readByte();
+            f.permissions = p.readStringArray();
+            f.action = p.readByte();
+            f.boolArg = p.readBoolean();
+            f.integerArg = p.readLong();
+            f.floatArg = p.readDouble();
+            f.stringArg = p.readString();
+            f.bytesArg = p.createByteArray();
+            return f;
+        }
+
+        @Override
+        public GmsFlag[] newArray(int size) {
+            return new GmsFlag[size];
+        }
+    };
+
+    public static void writeMapEntry(ArrayMap<String, GmsFlag> map, int idx, Parcel dst) {
+        // map key is GmsFlag.name, do not write it twice
+        map.valueAt(idx).writeToParcel(dst, 0);
+    }
+
+    public static void readMapEntry(Parcel p, ArrayMap<String, GmsFlag> dst) {
+        GmsFlag f = GmsFlag.CREATOR.createFromParcel(p);
+        dst.append(f.name, f);
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/gcarriersettings/GCarrierSettingsApp.java b/core/java/com/android/internal/gmscompat/gcarriersettings/GCarrierSettingsApp.java
new file mode 100644
index 000000000000..9c69cbaf1d64
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/gcarriersettings/GCarrierSettingsApp.java
@@ -0,0 +1,83 @@
+package com.android.internal.gmscompat.gcarriersettings;
+
+import android.content.Context;
+import android.service.carrier.CarrierIdentifier;
+import android.telephony.TelephonyManager;
+
+import com.android.internal.util.PackageSpec;
+
+import java.util.Objects;
+
+// A set of hooks that are needed to obtain output of Google's CarrierSettings app for arbitrary
+// CarrierIds. That output is used for testing CarrierConfig2 app.
+public class GCarrierSettingsApp {
+    public static final String PKG_NAME = "com.google.android.carrier";
+
+    public static final int PHONE_SLOT_IDX_FOR_CARRIER_ID_OVERRIDE = 50;
+    public static final int SUB_ID_FOR_CARRIER_ID_OVERRIDE = 90;
+    // a separate value is need to prevent caching inside GCarrierSettings from interfering with
+    // the results
+    public static final int SUB_ID_FOR_CARRIER_SERVICE_CALL = 91;
+
+    private static int isTestingModeEnabled;
+
+    static ThreadLocal<CarrierIdentifier> carrierIdOverride;
+
+    public static void init() {
+        carrierIdOverride = new ThreadLocal<>();
+    }
+
+    public static PackageSpec getPackageSpec() {
+        return new PackageSpec(PKG_NAME, 37L,
+                new String[] { "c00409b6524658c2e8eb48975a5952959ea3707dd57bc50fd74d6249262f0e82" });
+    }
+
+    public static int maybeOverrideSlotIndex(int subId) {
+        if (subId == SUB_ID_FOR_CARRIER_ID_OVERRIDE) {
+            return PHONE_SLOT_IDX_FOR_CARRIER_ID_OVERRIDE;
+        }
+        return -1;
+    }
+
+    public static int[] maybeOverrideSubIds(int slotIndex) {
+        if (slotIndex == PHONE_SLOT_IDX_FOR_CARRIER_ID_OVERRIDE) {
+            return new int[] { SUB_ID_FOR_CARRIER_ID_OVERRIDE };
+        }
+        return null;
+    }
+
+    public static TelephonyManager maybeOverrideCreateTelephonyManager(Context ctx, int subId) {
+        if (subId == SUB_ID_FOR_CARRIER_ID_OVERRIDE) {
+            CarrierIdentifier override = carrierIdOverride.get();
+            Objects.requireNonNull(override);
+            return new GCSTelephonyManager(ctx, SUB_ID_FOR_CARRIER_ID_OVERRIDE, override);
+        }
+
+        return null;
+    }
+
+    public static class GCSTelephonyManager extends TelephonyManager {
+        private final CarrierIdentifier carrierIdOverride;
+
+        public GCSTelephonyManager(Context context, int subId, CarrierIdentifier carrierIdOverride) {
+            super(context, subId);
+            this.carrierIdOverride = carrierIdOverride;
+        }
+
+        @Override public String getSimOperator() {
+            return carrierIdOverride.getMcc() + carrierIdOverride.getMnc();
+        }
+
+        @Override public String getSimOperatorName() {
+            return carrierIdOverride.getSpn();
+        }
+
+        @Override public String getSubscriberId() {
+            return carrierIdOverride.getImsi();
+        }
+
+        @Override public String getGroupIdLevel1() {
+            return carrierIdOverride.getGid1();
+        }
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/gcarriersettings/ICarrierConfigsLoader.aidl b/core/java/com/android/internal/gmscompat/gcarriersettings/ICarrierConfigsLoader.aidl
new file mode 100644
index 000000000000..c28bde2351c5
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/gcarriersettings/ICarrierConfigsLoader.aidl
@@ -0,0 +1,8 @@
+package com.android.internal.gmscompat.gcarriersettings;
+
+import android.os.Bundle;
+import android.service.carrier.CarrierIdentifier;
+
+interface ICarrierConfigsLoader {
+    Bundle getConfigs(in CarrierIdentifier carrierId);
+}
diff --git a/core/java/com/android/internal/gmscompat/gcarriersettings/TestCarrierConfigService.java b/core/java/com/android/internal/gmscompat/gcarriersettings/TestCarrierConfigService.java
new file mode 100644
index 000000000000..7b4431232a70
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/gcarriersettings/TestCarrierConfigService.java
@@ -0,0 +1,160 @@
+package com.android.internal.gmscompat.gcarriersettings;
+
+import android.annotation.Nullable;
+import android.app.Service;
+import android.content.ComponentName;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.PersistableBundle;
+import android.os.RemoteException;
+import android.os.ResultReceiver;
+import android.service.carrier.CarrierIdentifier;
+import android.service.carrier.CarrierService;
+import android.service.carrier.CarrierService.ICarrierServiceWrapper;
+import android.service.carrier.IApnSourceService;
+import android.service.carrier.ICarrierService;
+import android.util.Log;
+
+import com.android.internal.util.Preconditions;
+
+import java.util.ArrayList;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+
+// This service is only used for testing the CarrierConfig2 app.
+// It allows CarrierConfig2 to get carrier configs from Google's CarrierSettings app for arbitrary
+// CarrierIds.
+public class TestCarrierConfigService extends Service {
+
+    private final Executor bgExecutor = Executors.newSingleThreadExecutor();
+
+    private Future<IBinder> carrierServiceF;
+    private Future<IBinder> apnServiceF;
+
+    private final ArrayList<ServiceConnection> serviceConnections = new ArrayList<>();
+
+    public static final String KEY_CARRIER_SERVICE_RESULT = "carrier_service_result";
+    public static final String KEY_APN_SERVICE_RESULT = "apn_service_result";
+
+    private final Binder binder = new ICarrierConfigsLoader.Stub() {
+        private ICarrierService carrierService;
+        private IApnSourceService apnService;
+
+        private void maybeWaitForServices() {
+            synchronized (this) {
+                if (carrierService == null) {
+                    try {
+                        carrierService = ICarrierService.Stub.asInterface(carrierServiceF.get());
+                        apnService = IApnSourceService.Stub.asInterface(apnServiceF.get());
+                    } catch (ExecutionException|InterruptedException e) {
+                        throw new IllegalStateException(e);
+                    }
+                }
+            }
+        }
+
+        @Override
+        public Bundle getConfigs(CarrierIdentifier carrierId) throws RemoteException {
+            maybeWaitForServices();
+
+            var carrierServiceResultF = new CompletableFuture<Bundle>();
+            var resultReceiver = new ResultReceiver(null) {
+                @Override
+                protected void onReceiveResult(int resultCode, Bundle resultData) {
+                    Preconditions.checkArgument(resultCode == ICarrierServiceWrapper.RESULT_OK);
+                    carrierServiceResultF.complete(resultData);
+                }
+            };
+            carrierService.getCarrierConfig(GCarrierSettingsApp.SUB_ID_FOR_CARRIER_SERVICE_CALL, carrierId, resultReceiver);
+
+            GCarrierSettingsApp.carrierIdOverride.set(carrierId);
+            ContentValues[] apns = apnService.getApns(GCarrierSettingsApp.SUB_ID_FOR_CARRIER_ID_OVERRIDE);
+
+            var result = new Bundle();
+            result.putParcelableArray(KEY_APN_SERVICE_RESULT, apns);
+
+            try {
+                Bundle b = carrierServiceResultF.get();
+                PersistableBundle pb = b.getParcelable(ICarrierServiceWrapper.KEY_CONFIG_BUNDLE);
+                result.putParcelable(KEY_CARRIER_SERVICE_RESULT, pb);
+            } catch (InterruptedException|ExecutionException e) {
+                throw new IllegalStateException(e);
+            }
+
+            return result;
+        }
+    };
+
+    @Override
+    public void onCreate() {
+        var csIntent = new Intent(CarrierService.CARRIER_SERVICE_INTERFACE);
+        csIntent.setPackage(GCarrierSettingsApp.PKG_NAME);
+        carrierServiceF = bind(csIntent);
+
+        var apnServiceIntent = new Intent();
+        apnServiceIntent.setComponent(ComponentName.createRelative(GCarrierSettingsApp.PKG_NAME, ".ApnSourceService"));
+        apnServiceF = bind(apnServiceIntent);
+    }
+
+    @Nullable
+    @Override
+    public IBinder onBind(Intent intent) {
+        return binder;
+    }
+
+    CompletableFuture<IBinder> bind(Intent intent) {
+        String TAG = "TestCConfigService.bind";
+
+        var future = new CompletableFuture<IBinder>();
+
+        var sc = new ServiceConnection() {
+            @Override
+            public void onServiceConnected(ComponentName name, IBinder service) {
+                Log.d(TAG, "onServiceConnected " + name);
+                future.complete(service);
+            }
+
+            @Override
+            public void onServiceDisconnected(ComponentName name) {
+                Log.d(TAG, "onServiceDisconnected " + name);
+            }
+
+            @Override
+            public void onBindingDied(ComponentName name) {
+                throw new IllegalStateException("onBindingDied " + name);
+            }
+
+            @Override
+            public void onNullBinding(ComponentName name) {
+                throw new IllegalStateException("onNullBinding " + name);
+            }
+        };
+
+        int bindFlags = Context.BIND_AUTO_CREATE | Context.BIND_ABOVE_CLIENT;
+        boolean res = bindService(intent, bindFlags, bgExecutor, sc);
+        serviceConnections.add(sc);
+
+        if (!res) {
+            throw new IllegalStateException("unable to bind to " + intent);
+        }
+
+        return future;
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+
+        for (ServiceConnection c : serviceConnections) {
+            unbindService(c);
+        }
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/sysservice/GmcPackageManager.java b/core/java/com/android/internal/gmscompat/sysservice/GmcPackageManager.java
new file mode 100644
index 000000000000..c931aa1b1f40
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/sysservice/GmcPackageManager.java
@@ -0,0 +1,603 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.sysservice;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.annotation.SuppressLint;
+import android.app.ActivityThread;
+import android.app.Application;
+import android.app.ApplicationPackageManager;
+import android.app.compat.gms.GmsCompat;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.IPackageDataObserver;
+import android.content.pm.IPackageDeleteObserver;
+import android.content.pm.IPackageManager;
+import android.content.pm.InstallSourceInfo;
+import android.content.pm.PackageInfo;
+import android.content.pm.SharedLibraryInfo;
+import android.content.pm.VersionedPackage;
+import android.ext.PackageId;
+import android.os.Build;
+import android.os.Process;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.util.ArrayMap;
+import android.util.ArraySet;
+import android.util.Log;
+import android.util.PackageUtils;
+
+import com.android.internal.gmscompat.GmsHooks;
+import com.android.internal.gmscompat.GmsInfo;
+import com.android.internal.gmscompat.PlayStoreHooks;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+
+@SuppressLint("WrongConstant") // lint doesn't like "flags & ~" expressions
+public class GmcPackageManager extends ApplicationPackageManager {
+    private static final String TAG = GmcPackageManager.class.getSimpleName();
+
+    public GmcPackageManager(Context context, IPackageManager pm) {
+        super(context, pm);
+    }
+
+    public static void init(Context ctx) {
+        initPseudoDisabledPackages();
+        initForceDisabledComponents(ctx);
+        if (GmsCompat.isPlayStore()) {
+            ArraySet<String> hiddenPkgs = HIDDEN_PACKAGES;
+        }
+    }
+
+    public static void maybeAdjustPackageInfo(PackageInfo pi) {
+        ApplicationInfo ai = pi.applicationInfo;
+        if (ai != null) {
+            maybeAdjustApplicationInfo(ai);
+        }
+    }
+
+    public static void maybeAdjustApplicationInfo(ApplicationInfo ai) {
+        String packageName = ai.packageName;
+
+        if (GmsInfo.PACKAGE_GMS_CORE.equals(packageName)) {
+            // Checked before accessing com.google.android.gms.phenotype content provider
+            // in com.google.android.libraries.phenotype.client
+            // .PhenotypeClientHelper#validateContentProvider() -> isGmsCorePreinstalled()
+            // PhenotypeFlags will always return their default values if these flags aren't set.
+            //
+            // Also need to be set to allow updates of GmsCore through Play Store without a
+            // logged-in Google account
+            if (GmsCompat.isGmsCore() || GmsCompat.isClientOfGmsCore(ai)) {
+                ai.flags |= ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
+            }
+        }
+
+        if (!ai.enabled) {
+            if (shouldHideDisabledState(packageName)) {
+                ai.enabled = true;
+            }
+        }
+    }
+
+    @Override
+    public void deletePackage(String packageName, IPackageDeleteObserver observer, int flags) {
+        if (GmsCompat.isPlayStore()) {
+            PlayStoreHooks.deletePackage(this, packageName, observer, flags);
+            return;
+        }
+
+        super.deletePackage(packageName, observer, flags);
+    }
+
+    @Override
+    public void freeStorageAndNotify(String volumeUuid, long idealStorageSize, IPackageDataObserver observer) {
+        if (GmsCompat.isPlayStore()) {
+            PlayStoreHooks.freeStorageAndNotify(volumeUuid, idealStorageSize, observer);
+            return;
+        }
+
+        super.freeStorageAndNotify(volumeUuid, idealStorageSize, observer);
+    }
+
+    @Override
+    public void setApplicationEnabledSetting(String packageName, int newState, int flags) {
+        if (GmsCompat.isPlayStore()) {
+            if (isPseudoDisabledPackage(packageName)) {
+                try {
+                    // check whether this package is actually absent
+                    super.getApplicationInfoAsUser(packageName, ApplicationInfoFlags.of(0L), getUserId());
+                } catch (NameNotFoundException e) {
+                    // package state tracking happens in the same process that tries to enable
+                    // the package, no need to sync this across all processes, at least for now
+                    removePseudoDisabledPackage(packageName);
+                    GmsCompat.appContext().getMainThreadHandler().post(() ->
+                            PlayStoreHooks.updatePackageState(packageName, Intent.ACTION_PACKAGE_REMOVED));
+                    return;
+                }
+            }
+            PlayStoreHooks.setApplicationEnabledSetting(packageName, newState);
+            return;
+        }
+
+        try {
+            super.setApplicationEnabledSetting(packageName, newState, flags);
+        } catch (SecurityException e) {
+            Log.d(TAG, "", e);
+        }
+    }
+
+    @Override
+    public boolean hasSystemFeature(String name) {
+        switch (name) {
+            // checked before accessing privileged UwbManager
+            case "android.hardware.uwb":
+                return false;
+        }
+
+        return super.hasSystemFeature(name);
+    }
+
+    // requires privileged OBSERVE_GRANT_REVOKE_PERMISSIONS permission
+    @Override
+    public void addOnPermissionsChangeListener(OnPermissionsChangedListener listener) {
+        synchronized (onPermissionsChangedListeners) {
+            onPermissionsChangedListeners.add(listener);
+        }
+    }
+
+    @Override
+    public void removeOnPermissionsChangeListener(OnPermissionsChangedListener listener) {
+        synchronized (onPermissionsChangedListeners) {
+            onPermissionsChangedListeners.remove(listener);
+        }
+    }
+
+    public static void notifyPermissionsChangeListeners() {
+        Log.d("GmcPackageManager", "notifyPermissionsChangeListeners");
+        int myUid = Process.myUid();
+        synchronized (onPermissionsChangedListeners) {
+            for (OnPermissionsChangedListener l : onPermissionsChangedListeners) {
+                l.onPermissionsChanged(myUid);
+            }
+        }
+    }
+
+    private static final ArrayList<OnPermissionsChangedListener> onPermissionsChangedListeners =
+            new ArrayList<>();
+
+    // MATCH_ANY_USER flag requires privileged INTERACT_ACROSS_USERS permission
+
+    private static PackageInfoFlags filterFlags(PackageInfoFlags flags) {
+        long v = flags.getValue();
+
+        if ((v & MATCH_ANY_USER) != 0) {
+            return PackageInfoFlags.of(v & ~MATCH_ANY_USER);
+        }
+
+        return flags;
+    }
+
+    @Override
+    public @NonNull List<SharedLibraryInfo> getSharedLibraries(PackageInfoFlags flags) {
+        return super.getSharedLibraries(filterFlags(flags));
+    }
+
+    private static final ArraySet<String> HIDDEN_PACKAGES = new ArraySet<>(new String[] {
+            "app.attestation.auditor",
+    });
+
+    private static void throwIfHidden(String pkgName) throws NameNotFoundException {
+        if (HIDDEN_PACKAGES.contains(pkgName)) {
+            throw new NameNotFoundException();
+        }
+    }
+
+    @Override
+    public PackageInfo getPackageInfo(VersionedPackage versionedPackage, PackageInfoFlags flags) throws NameNotFoundException {
+        throwIfHidden(versionedPackage.getPackageName());
+        flags = filterFlags(flags);
+        try {
+            PackageInfo pi = super.getPackageInfo(versionedPackage, flags);
+            maybeAdjustPackageInfo(pi);
+            return pi;
+        } catch (NameNotFoundException e) {
+            return makePseudoDisabledPackageInfoOrThrow(versionedPackage.getPackageName(), flags);
+        }
+    }
+
+    @Override
+    public PackageInfo getPackageInfoAsUser(String packageName, PackageInfoFlags flags, int userId) throws NameNotFoundException {
+        throwIfHidden(packageName);
+        flags = filterFlags(flags);
+        try {
+            PackageInfo pi = super.getPackageInfoAsUser(packageName, flags, userId);
+            maybeAdjustPackageInfo(pi);
+            return pi;
+        } catch (NameNotFoundException e) {
+            return makePseudoDisabledPackageInfoOrThrow(packageName, flags);
+        }
+    }
+
+    @Override
+    public ApplicationInfo getApplicationInfoAsUser(String packageName, ApplicationInfoFlags flags, int userId) throws NameNotFoundException {
+        try {
+            ApplicationInfo ai = super.getApplicationInfoAsUser(packageName, flags, userId);
+            maybeAdjustApplicationInfo(ai);
+            return ai;
+        } catch (NameNotFoundException e) {
+            return makePseudoDisabledApplicationInfoOrThrow(packageName, flags);
+        }
+    }
+
+    @Override
+    public List<ApplicationInfo> getInstalledApplicationsAsUser(ApplicationInfoFlags flags, int userId) {
+        List<ApplicationInfo> ret = super.getInstalledApplicationsAsUser(flags, userId);
+        List<ApplicationInfo> res = new ArrayList<>(ret.size());
+
+        ArraySet<String> pseudoDisabledPackages = clonePseudoDisabledPackages();
+
+        for (ApplicationInfo ai : ret) {
+            String pkgName = ai.packageName;
+            if (HIDDEN_PACKAGES.contains(pkgName)) {
+                continue;
+            }
+            pseudoDisabledPackages.remove(pkgName);
+            maybeAdjustApplicationInfo(ai);
+            res.add(ai);
+        }
+
+        for (String pkg : pseudoDisabledPackages) {
+            ApplicationInfo ai = maybeMakePseudoDisabledApplicationInfo(pkg, flags);
+            if (ai != null) {
+                res.add(ai);
+            }
+        }
+
+        return res;
+    }
+
+    @Override
+    public List<PackageInfo> getInstalledPackagesAsUser(PackageInfoFlags flags, int userId) {
+        flags = filterFlags(flags);
+        List<PackageInfo> ret = super.getInstalledPackagesAsUser(flags, userId);
+        List<PackageInfo> res = new ArrayList<>(ret.size());
+
+        ArraySet<String> pseudoDisabledPackages = clonePseudoDisabledPackages();
+
+        for (PackageInfo pi : ret) {
+            String pkgName = pi.packageName;
+            if (HIDDEN_PACKAGES.contains(pkgName)) {
+                continue;
+            }
+            pseudoDisabledPackages.remove(pkgName);
+            maybeAdjustPackageInfo(pi);
+            res.add(pi);
+        }
+
+        for (String pkg : pseudoDisabledPackages) {
+            PackageInfo pi = maybeMakePseudoDisabledPackageInfo(pkg, flags);
+            if (pi != null) {
+                res.add(pi);
+            }
+        }
+
+        return res;
+    }
+
+    @Override
+    public String[] getPackagesForUid(int uid) {
+        int userId = UserHandle.getUserId(uid);
+        int myUserId = UserHandle.myUserId();
+
+        if (userId != myUserId) {
+            if (userId != 0) {
+                throw new IllegalArgumentException("uid from unexpected userId: " + uid);
+            }
+            // querying uids from other userIds requires a privileged permission
+            uid = UserHandle.getUid(myUserId, UserHandle.getAppId(uid));
+        }
+
+        return super.getPackagesForUid(uid);
+    }
+
+    @SuppressLint("SwitchIntDef")
+    @Override
+    public int getApplicationEnabledSetting(String packageName) {
+        try {
+            int res = super.getApplicationEnabledSetting(packageName);
+
+            switch (res) {
+                case COMPONENT_ENABLED_STATE_DISABLED:
+                case COMPONENT_ENABLED_STATE_DISABLED_USER:
+                case COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED:
+                    if (shouldHideDisabledState(packageName)) {
+                        res = COMPONENT_ENABLED_STATE_DEFAULT;
+                    }
+            }
+
+            return res;
+        } catch (Exception e) {
+            if (isPseudoDisabledPackage(packageName)) {
+                return COMPONENT_ENABLED_STATE_DISABLED_USER;
+            }
+            throw e;
+        }
+    }
+
+    @Override
+    public String getInstallerPackageName(String packageName) {
+        try {
+            return super.getInstallerPackageName(packageName);
+        } catch (Exception e) {
+            if (isPseudoDisabledPackage(packageName)) {
+                return PackageId.PLAY_STORE_NAME;
+            }
+            throw e;
+        }
+    }
+
+    @NonNull
+    @Override
+    public InstallSourceInfo getInstallSourceInfo(String packageName) throws NameNotFoundException {
+        InstallSourceInfo res;
+        try {
+            res = super.getInstallSourceInfo(packageName);
+        } catch (NameNotFoundException e) {
+            if (isPseudoDisabledPackage(packageName)) {
+                String installer = PackageId.PLAY_STORE_NAME;
+                var isi = new InstallSourceInfo(installer, null, null, installer);
+                return isi;
+            }
+            throw e;
+        }
+
+        if (PackageId.ANDROID_AUTO_NAME.equals(packageName) && isUpdateOwnershipOverrideEnabled()) {
+            // Android Auto needs to be exempted from updates via Play Store to prevent breaking the
+            // compatibility layer support for Android Auto.
+            //
+            // Play Store respects the value of InstallSourceInfo#getUpdateOwnerPackageName():
+            // packages that have non-Play Store update owners are not updated by Play Store
+            String updateOwnerPackage = PackageUtils.getFirstPartyAppSourcePackageName(GmsCompat.appContext());
+            res = new InstallSourceInfo(
+                    res.getInitiatingPackageName(),
+                    res.getInitiatingPackageSigningInfo(),
+                    res.getOriginatingPackageName(),
+                    res.getInstallingPackageName(),
+                    updateOwnerPackage,
+                    res.getPackageSource()
+            );
+        }
+
+        return res;
+    }
+
+    private static boolean isUpdateOwnershipOverrideEnabled() {
+        if (!Build.isDebuggable()) {
+            return true;
+        }
+
+        ContentResolver cr = GmsCompat.appContext().getContentResolver();
+        return Settings.Global.getInt(cr, "gmscompat_allow_unknown_updates", 0) == 0;
+    }
+
+    private PackageInfo makePseudoDisabledPackageInfoOrThrow(String pkgName, PackageInfoFlags flags) throws NameNotFoundException {
+        if (!isPseudoDisabledPackage(pkgName)) {
+            throw new NameNotFoundException();
+        }
+        PackageInfo pi = maybeMakePseudoDisabledPackageInfo(pkgName, flags);
+        if (pi == null) {
+            throw new NameNotFoundException();
+        }
+        return pi;
+    }
+
+    private ApplicationInfo makePseudoDisabledApplicationInfoOrThrow(String pkgName, ApplicationInfoFlags flags) throws NameNotFoundException {
+        if (!isPseudoDisabledPackage(pkgName)) {
+            throw new NameNotFoundException();
+        }
+        ApplicationInfo ai = maybeMakePseudoDisabledApplicationInfo(pkgName, flags);
+        if (ai == null) {
+            throw new NameNotFoundException();
+        }
+        return ai;
+    }
+
+    @Nullable
+    private PackageInfo maybeMakePseudoDisabledPackageInfo(String pkgName, PackageInfoFlags flags) {
+        PackageInfo pi;
+        try {
+            pi = super.getPackageInfoAsUser(selfPkgName(), flags, getUserId());
+        } catch (NameNotFoundException e) {
+            return null;
+        }
+        pi.packageName = pkgName;
+        pi.applicationInfo.packageName = pkgName;
+        pi.applicationInfo.enabled = false;
+        pi.setLongVersionCode(Integer.MAX_VALUE);
+        return pi;
+    }
+
+    @Nullable
+    private ApplicationInfo maybeMakePseudoDisabledApplicationInfo(String pkgName, ApplicationInfoFlags flags) {
+        ApplicationInfo ai;
+        try {
+            ai = super.getApplicationInfoAsUser(selfPkgName(), flags, getUserId());
+        } catch (NameNotFoundException e) {
+            return null;
+        }
+        ai.packageName = pkgName;
+        ai.enabled = false;
+        ai.longVersionCode = Integer.MAX_VALUE;
+        ai.versionCode = Integer.MAX_VALUE;
+        return ai;
+    }
+
+    private static String selfPkgName() {
+        return GmsCompat.appContext().getPackageName();
+    }
+
+    // Pseudo-disabled PackageInfo/ApplicationInfo is used to prevent Play Store from auto-installing
+    // optional packages, such as "Play Services for AR". It's returned only when the package is
+    // not installed.
+    // When Play Store tries to enable a pseudo-disabled package, it receives a callback that
+    // the package was uninstalled. This allows the user to install a pseudo-disabled package
+    // by pressing the "Enable" button, which reveals the "Install" button.
+
+    // important to have it static: there are multiple instances of enclosing class in the same process
+    private static final ArraySet<String> pseudoDisabledPackages = new ArraySet<>();
+
+    private static void initPseudoDisabledPackages() {
+        if (GmsCompat.isPlayStore()) {
+            // "Play Services for AR"
+            pseudoDisabledPackages.add("com.google.ar.core");
+        }
+
+        if (GmsCompat.isAndroidAuto()) {
+            pseudoDisabledPackages.add(PackageId.G_SEARCH_APP_NAME);
+            pseudoDisabledPackages.add("com.google.android.apps.maps");
+            pseudoDisabledPackages.add("com.google.android.tts");
+        }
+    }
+
+    private static boolean isPseudoDisabledPackage(String pkgName) {
+        synchronized (pseudoDisabledPackages) {
+            return pseudoDisabledPackages.contains(pkgName);
+        }
+    }
+
+    private static ArraySet<String> clonePseudoDisabledPackages() {
+        synchronized (pseudoDisabledPackages) {
+            return new ArraySet<>(pseudoDisabledPackages);
+        }
+    }
+
+    private static boolean removePseudoDisabledPackage(String pkgName) {
+        synchronized (pseudoDisabledPackages) {
+            return pseudoDisabledPackages.remove(pkgName);
+        }
+    }
+
+    private static boolean shouldHideDisabledState(String pkgName) {
+        if (!GmsCompat.isPlayStore()) {
+            return false;
+        }
+
+        switch (pkgName) {
+            case GmsInfo.PACKAGE_GSF:
+            case GmsInfo.PACKAGE_GMS_CORE:
+                return false;
+            default:
+                return true;
+        }
+    }
+
+    private static ArraySet<ComponentName> componentsWithForcedEnabledSetting;
+
+    private static void initForceDisabledComponents(Context ctx) {
+        final String pkgName = ctx.getPackageName();
+        ArrayMap<String, Integer> forcedCes = GmsHooks.config().forceComponentEnabledSettingsMap.get(pkgName);
+
+        if (forcedCes == null) {
+            return;
+        }
+
+        final int cnt = forcedCes.size();
+
+        var components = new ArraySet<ComponentName>(cnt);
+        var settings = new ArrayList<ComponentEnabledSetting>(cnt);
+        for (int i = 0; i < cnt; ++i) {
+            var name = new ComponentName(ctx, forcedCes.keyAt(i));
+            components.add(name);
+            int state = forcedCes.valueAt(i).intValue();
+            var ces = new ComponentEnabledSetting(name, state, DONT_KILL_APP | SKIP_IF_MISSING);
+            settings.add(ces);
+        }
+
+        componentsWithForcedEnabledSetting = components;
+
+        // Don't repeat setComponentEnabledSettings() in all processes
+        boolean shouldUpdate;
+        if (GmsCompat.isGmsCore()) {
+            shouldUpdate = GmsHooks.inPersistentGmsCoreProcess;
+        } else if (GmsCompat.isPlayStore()) {
+            shouldUpdate = GmsInfo.PACKAGE_PLAY_STORE.equals(Application.getProcessName());
+        } else {
+            shouldUpdate = true;
+        }
+
+        if (shouldUpdate) {
+            try {
+                ActivityThread.getPackageManager().setComponentEnabledSettings(settings, ctx.getUserId(), pkgName);
+            } catch (Exception e) {
+                Log.d(TAG, "", e);
+            }
+        }
+    }
+
+    private static boolean isSetComponentEnabledSettingAllowed(@Nullable ComponentName cn, int newState, int flags) {
+        if (cn == null) {
+            return true;
+        }
+
+        ArraySet<ComponentName> set = componentsWithForcedEnabledSetting;
+        if (set != null && set.contains(cn)) {
+            Log.d(TAG, "skipped setComponentEnabledSetting for " + cn + ", newState " + newState
+                    + ", flags " + flags);
+            return false;
+        }
+
+        return true;
+    }
+
+    @Override
+    public void setComponentEnabledSetting(ComponentName componentName,
+                                           int newState, int flags) {
+        if (!isSetComponentEnabledSettingAllowed(componentName, newState, flags)) {
+            return;
+        }
+
+        try {
+            super.setComponentEnabledSetting(componentName, newState, flags);
+        } catch (SecurityException e) {
+            Log.d(TAG, "", e);
+        }
+    }
+
+    @Override
+    public void setComponentEnabledSettings(List<ComponentEnabledSetting> settings) {
+        settings = settings.stream()
+                .filter(s -> isSetComponentEnabledSettingAllowed(s.getComponentName(),
+                        s.getEnabledState(), s.getEnabledFlags()))
+                .collect(Collectors.toUnmodifiableList());
+        if (settings.isEmpty()) {
+            return;
+        }
+
+        try {
+            super.setComponentEnabledSettings(settings);
+        } catch (SecurityException e) {
+            Log.d(TAG, "", e);
+        }
+    }
+
+}
diff --git a/core/java/com/android/internal/gmscompat/sysservice/GmcTelephonyManager.java b/core/java/com/android/internal/gmscompat/sysservice/GmcTelephonyManager.java
new file mode 100644
index 000000000000..0fc7d81ca810
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/sysservice/GmcTelephonyManager.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.sysservice;
+
+import android.Manifest;
+import android.annotation.CallbackExecutor;
+import android.annotation.Nullable;
+import android.app.compat.gms.GmsCompat;
+import android.content.Context;
+import android.os.WorkSource;
+import android.telephony.CellInfo;
+import android.telephony.ServiceState;
+import android.telephony.TelephonyCallback;
+import android.telephony.TelephonyManager;
+import android.telephony.UiccSlotInfo;
+import android.util.Log;
+
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.Executor;
+import java.util.stream.Collectors;
+
+@SuppressWarnings("AutoBoxing")
+public class GmcTelephonyManager {
+
+    private static final String TAG = "GmcTelephonyManager";
+
+    public static int[] filterTelephonyCallbackEvents(int[] eventsArray) {
+        Set<Integer> events = Arrays.stream(eventsArray).boxed().collect(Collectors.toSet());
+
+        var sb = new StringBuilder();
+
+        if (!GmsCompat.hasPermission(Manifest.permission.READ_PHONE_STATE)) {
+            removeEvents(events, EVENTS_PROT_READ_PHONE_STATE, "READ_PHONE_STATE", sb);
+        }
+
+        if (!GmsCompat.hasPermission(Manifest.permission.ACCESS_FINE_LOCATION)) {
+            removeEvents(events, EVENTS_PROT_ACCESS_FINE_LOCATION,
+                    "ACCESS_FINE_LOCATION", sb);
+        }
+
+        if (!GmsCompat.hasPermission(Manifest.permission.READ_ACTIVE_EMERGENCY_SESSION)) {
+            removeEvents(events, EVENTS_PROT_READ_ACTIVE_EMERGENCY_SESSION,
+                    "READ_ACTIVE_EMERGENCY_SESSION", sb);
+        }
+
+        if (!GmsCompat.hasPermission(Manifest.permission.READ_PRIVILEGED_PHONE_STATE)) {
+            removeEvents(events, EVENTS_PROT_READ_PRIVILEGED_PHONE_STATE,
+                    "READ_PRIVILEGED_PHONE_STATE", sb);
+        }
+
+        if (!GmsCompat.hasPermission(Manifest.permission.READ_PRECISE_PHONE_STATE)) {
+            removeEvents(events, EVENTS_PROT_READ_PRECISE_PHONE_STATE,
+                    "READ_PRECISE_PHONE_STATE", sb);
+        }
+
+        int[] res = events.stream().mapToInt(Integer::intValue).toArray();
+
+        Log.d(TAG, "registering listener, events: " + Arrays.toString(res) +
+                (sb.length() != 0? "\nfiltered events due to missing permission\n" + sb : ""),
+                new Throwable());
+
+        return res;
+    }
+
+    private static void removeEvents(Set<Integer> events, int[] eventsToRemove, String permName, StringBuilder sb) {
+        if (events.size() == 0) {
+            return;
+        }
+
+        boolean filtered = false;
+
+        for (int event : eventsToRemove) {
+            if (!events.remove(event)) {
+                continue;
+            }
+            if (!filtered) {
+                sb.append(permName);
+                sb.append(": {");
+                filtered = true;
+            }
+            sb.append(event);
+            sb.append(", ");
+        }
+
+        if (filtered) {
+            sb.append("}\n");
+        }
+    }
+
+    private static final int[] EVENTS_PROT_READ_PHONE_STATE = {
+            TelephonyCallback.EVENT_CALL_FORWARDING_INDICATOR_CHANGED,
+            TelephonyCallback.EVENT_MESSAGE_WAITING_INDICATOR_CHANGED,
+            TelephonyCallback.EVENT_EMERGENCY_NUMBER_LIST_CHANGED,
+            TelephonyCallback.EVENT_LEGACY_CALL_STATE_CHANGED,
+            TelephonyCallback.EVENT_CALL_STATE_CHANGED,
+            TelephonyCallback.EVENT_ACTIVE_DATA_SUBSCRIPTION_ID_CHANGED,
+            TelephonyCallback.EVENT_CELL_INFO_CHANGED,
+    };
+
+    private static final int[] EVENTS_PROT_ACCESS_FINE_LOCATION = {
+            TelephonyCallback.EVENT_CELL_LOCATION_CHANGED,
+            TelephonyCallback.EVENT_CELL_INFO_CHANGED,
+            TelephonyCallback.EVENT_REGISTRATION_FAILURE,
+            TelephonyCallback.EVENT_BARRING_INFO_CHANGED,
+    };
+
+    private static final int[] EVENTS_PROT_READ_ACTIVE_EMERGENCY_SESSION = {
+            TelephonyCallback.EVENT_OUTGOING_EMERGENCY_CALL,
+            TelephonyCallback.EVENT_OUTGOING_EMERGENCY_SMS,
+    };
+
+    private static final int[] EVENTS_PROT_READ_PRIVILEGED_PHONE_STATE = {
+            TelephonyCallback.EVENT_SRVCC_STATE_CHANGED,
+            TelephonyCallback.EVENT_VOICE_ACTIVATION_STATE_CHANGED,
+            TelephonyCallback.EVENT_RADIO_POWER_STATE_CHANGED,
+            TelephonyCallback.EVENT_ALLOWED_NETWORK_TYPE_LIST_CHANGED,
+            TelephonyCallback.EVENT_EMERGENCY_CALLBACK_MODE_CHANGED,
+    };
+
+    private static final int[] EVENTS_PROT_READ_PRECISE_PHONE_STATE = {
+            TelephonyCallback.EVENT_PRECISE_DATA_CONNECTION_STATE_CHANGED,
+            TelephonyCallback.EVENT_DATA_CONNECTION_REAL_TIME_INFO_CHANGED,
+            TelephonyCallback.EVENT_PRECISE_CALL_STATE_CHANGED,
+            TelephonyCallback.EVENT_CALL_DISCONNECT_CAUSE_CHANGED,
+            TelephonyCallback.EVENT_CALL_ATTRIBUTES_CHANGED,
+            TelephonyCallback.EVENT_IMS_CALL_DISCONNECT_CAUSE_CHANGED,
+            TelephonyCallback.EVENT_REGISTRATION_FAILURE,
+            TelephonyCallback.EVENT_BARRING_INFO_CHANGED,
+            TelephonyCallback.EVENT_PHYSICAL_CHANNEL_CONFIG_CHANGED,
+            TelephonyCallback.EVENT_DATA_ENABLED_CHANGED,
+            TelephonyCallback.EVENT_LINK_CAPACITY_ESTIMATE_CHANGED,
+            TelephonyCallback.EVENT_MEDIA_QUALITY_STATUS_CHANGED,
+    };
+}
diff --git a/core/java/com/android/internal/gmscompat/sysservice/GmcUserManager.java b/core/java/com/android/internal/gmscompat/sysservice/GmcUserManager.java
new file mode 100644
index 000000000000..2b1a8db750b0
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/sysservice/GmcUserManager.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.gmscompat.sysservice;
+
+import android.annotation.Nullable;
+import android.annotation.UserIdInt;
+import android.content.Context;
+import android.content.pm.UserInfo;
+import android.os.IUserManager;
+import android.os.Process;
+import android.os.UserHandle;
+import android.os.UserManager;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * GMS tries to interact across user profiles, which requires privileged permissions.
+ * As a workaround, a pseudo-single-user environment is constructed by hiding non-current users
+ * and marking the current user as the primary ("Owner") user.
+ */
+public class GmcUserManager extends UserManager {
+    public GmcUserManager(Context context, IUserManager service) {
+        super(context, service);
+    }
+
+    private static int getUserId() {
+        return UserHandle.myUserId();
+    }
+
+    private static void checkUserId(int userId) {
+        if (userId != getUserId() && userId != UserHandle.USER_CURRENT) {
+            throw new IllegalStateException("unexpected userId " + userId);
+        }
+    }
+
+    public static UserHandle translateUserHandle(UserHandle h) {
+        if (UserHandle.ALL.equals(h)) {
+            return UserHandle.of(getUserId());
+        }
+
+        checkUserId(h.getIdentifier());
+        return h;
+    }
+
+    private static int getUserSerialNumber() {
+        // GMS has several hardcoded (userSerialNumber == 0) checks
+        return 0;
+    }
+
+    private static String getUserType_() {
+        // "system" means "primary" ("Owner") user
+        return UserManager.USER_TYPE_FULL_SYSTEM;
+    }
+
+    private static UserInfo getUserInfo() {
+        // obtaining UserInfo is a privileged operation (even for the current user)
+        UserInfo ui = new UserInfo();
+        ui.id = getUserId();
+        ui.serialNumber = getUserSerialNumber();
+        ui.userType = getUserType_();
+        ui.flags = UserInfo.FLAG_SYSTEM | UserInfo.FLAG_FULL | UserInfo.FLAG_MAIN;
+        return ui;
+    }
+
+    @Override
+    public boolean isSystemUser() {
+        return true;
+    }
+
+    @Override
+    public boolean isUserOfType(String userType) {
+        return getUserType_().equals(userType);
+    }
+
+    @Override
+    public UserInfo getUserInfo(int userId) {
+        checkUserId(userId);
+        return getUserInfo();
+    }
+
+    @Override
+    public boolean hasBaseUserRestriction(String restrictionKey, UserHandle userHandle) {
+        // Can't ignore device policy restrictions without permission
+        return hasUserRestriction(restrictionKey, userHandle);
+    }
+
+    @Override
+    public List<UserInfo> getUsers(boolean excludePartial, boolean excludeDying, boolean excludePreCreated) {
+        return Collections.singletonList(getUserInfo());
+    }
+
+    @Override
+    public int getUserSerialNumber(@UserIdInt int userId) {
+        checkUserId(userId);
+        return getUserSerialNumber();
+    }
+
+    @Override
+    public @UserIdInt int getUserHandle(int userSerialNumber) {
+        if (userSerialNumber != getUserSerialNumber()) {
+            throw new IllegalStateException("unexpected userSerialNumber " + userSerialNumber);
+        }
+        return getUserId();
+    }
+
+    // ActivityManager#getCurrentUser()
+    public static int amGetCurrentUser() {
+        return getUserId();
+    }
+
+    // ActivityManager#isUserRunning(int)
+    public static boolean amIsUserRunning(int userId) {
+        checkUserId(userId);
+        return true;
+    }
+
+    // support for managed ("work") profiles
+
+    @Override
+    public List<UserInfo> getProfiles(@UserIdInt int userId) {
+        checkUserId(userId);
+        return getUsers();
+    }
+
+    @Override
+    public int[] getProfileIds(@UserIdInt int userId, boolean enabledOnly) {
+        checkUserId(userId);
+        return new int[] { userId };
+    }
+
+    @Override
+    public UserInfo getProfileParent(int userId) {
+        checkUserId(userId);
+        return null;
+    }
+
+    @Override
+    public boolean isRestrictedProfile() {
+        return false;
+    }
+
+    @Override
+    public boolean isDemoUser() {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    protected String getProfileType(int userId) {
+        checkUserId(userId);
+        return "";
+    }
+
+    @Nullable
+    @Override
+    public UserHandle getPreviousForegroundUser() {
+        return null;
+    }
+
+    @Nullable
+    @Override
+    public UserHandle getMainUser() {
+        return Process.myUserHandle();
+    }
+
+    @Override
+    public UserHandle getBootUser() {
+        return Process.myUserHandle();
+    }
+
+    @Override
+    public boolean isAdminUser() {
+        return true;
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/util/CursorWrapperExt.java b/core/java/com/android/internal/gmscompat/util/CursorWrapperExt.java
new file mode 100644
index 000000000000..f7424df0db93
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/util/CursorWrapperExt.java
@@ -0,0 +1,67 @@
+package com.android.internal.gmscompat.util;
+
+import android.database.Cursor;
+import android.database.CursorWrapper;
+
+public abstract class CursorWrapperExt extends CursorWrapper {
+
+    protected CursorWrapperExt(Cursor orig) {
+        super(orig);
+    }
+
+    protected abstract void onPositionChanged();
+
+    @Override
+    public boolean moveToLast() {
+        if (super.moveToLast()) {
+            onPositionChanged();
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean move(int offset) {
+        if (super.move(offset)) {
+            onPositionChanged();
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToPosition(int position) {
+        if (super.moveToPosition(position)) {
+            onPositionChanged();
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToNext() {
+        if (super.moveToNext()) {
+            onPositionChanged();
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToFirst() {
+        if (super.moveToFirst()) {
+            onPositionChanged();
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToPrevious() {
+        if (super.moveToPrevious()) {
+            onPositionChanged();
+            return true;
+        }
+        return false;
+    }
+}
diff --git a/core/java/com/android/internal/gmscompat/util/GmcActivityUtils.java b/core/java/com/android/internal/gmscompat/util/GmcActivityUtils.java
new file mode 100644
index 000000000000..627721946bab
--- /dev/null
+++ b/core/java/com/android/internal/gmscompat/util/GmcActivityUtils.java
@@ -0,0 +1,142 @@
+package com.android.internal.gmscompat.util;
+
+import android.Manifest;
+import android.annotation.Nullable;
+import android.app.Activity;
+import android.app.ActivityOptions;
+import android.app.Application;
+import android.app.compat.gms.GmsCompat;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothManager;
+import android.content.ComponentName;
+import android.content.Intent;
+import android.ext.PackageId;
+import android.os.Bundle;
+import android.os.RemoteException;
+import android.os.SystemClock;
+
+import com.android.internal.gmscompat.GmsCompatApp;
+import com.android.internal.gmscompat.PlayStoreHooks;
+
+public class GmcActivityUtils implements Application.ActivityLifecycleCallbacks {
+    private static final String TAG = GmcActivityUtils.class.getSimpleName();
+
+    public static final GmcActivityUtils INSTANCE = new GmcActivityUtils();
+
+    @Nullable
+    private Activity mostRecentVisibleActivity;
+
+    private GmcActivityUtils() {}
+
+    @Nullable
+    public static Activity getMostRecentVisibleActivity() {
+        return INSTANCE.mostRecentVisibleActivity;
+    }
+
+    @Override
+    public void onActivityResumed(Activity activity) {
+        mostRecentVisibleActivity = activity;
+
+        String className = activity.getClass().getName();
+
+        if (GmsCompat.isGmsCore()) {
+            switch (className) {
+                case "com.google.android.gms.nearby.sharing.ShareSheetActivity":
+                    handleNearbyShareActivityResume(activity, true);
+                    break;
+                case "com.google.android.gms.nearby.sharing.InternalReceiveSurfaceActivity":
+                    handleNearbyShareActivityResume(activity, false);
+                    break;
+            }
+        }
+
+        if (GmsCompat.isPlayStore()) {
+            PlayStoreHooks.onActivityResumed(activity);
+        }
+    }
+
+    @Override
+    public void onActivityPaused(Activity activity) {
+        if (mostRecentVisibleActivity == activity) {
+            mostRecentVisibleActivity = null;
+        }
+    }
+
+    @Override public void onActivityCreated(Activity activity, @Nullable Bundle savedInstanceState) {}
+    @Override public void onActivityStarted(Activity activity) {}
+    @Override public void onActivityStopped(Activity activity) {}
+    @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {}
+    @Override public void onActivityDestroyed(Activity activity) {}
+
+    private static long lastBtEnableRequest;
+    private static long lastBtDiscoverabilityRequest;
+
+    private static void handleNearbyShareActivityResume(Activity activity, boolean isSend) {
+        if (GmsCompat.hasPermission(Manifest.permission.BLUETOOTH_CONNECT)) {
+            var bm = GmsCompat.appContext().getSystemService(BluetoothManager.class);
+            BluetoothAdapter adapter = bm.getAdapter();
+
+            final long repeatInterval = 20_000;
+
+            long ts = SystemClock.elapsedRealtime();
+            if (isSend) {
+                if (adapter.getState() == BluetoothAdapter.STATE_OFF) {
+                    if (ts - lastBtEnableRequest > repeatInterval) {
+                        var intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
+                        activity.startActivity(intent);
+                        lastBtEnableRequest = ts;
+                    }
+                }
+            } else {
+                if (adapter.getScanMode() == BluetoothAdapter.SCAN_MODE_NONE) {
+                    if (ts - lastBtDiscoverabilityRequest > repeatInterval) {
+                        var intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
+                        activity.startActivity(intent);
+                        lastBtDiscoverabilityRequest = ts;
+                    }
+                }
+            }
+        } else {
+            try {
+                GmsCompatApp.iGms2Gca().showGmsCoreMissingPermissionForNearbyShareNotification();
+            } catch (RemoteException e) {
+                GmsCompatApp.callFailed(e);
+            }
+        }
+    }
+
+    // See https://developer.android.com/about/versions/14/behavior-changes-14#background-activity-restrictions
+    public static Bundle allowActivityLaunchFromPendingIntent(@Nullable Bundle orig) {
+        var ao = orig != null ? ActivityOptions.fromBundle(orig) : ActivityOptions.makeBasic();
+        ao.setPendingIntentBackgroundActivityStartMode(ActivityOptions.MODE_BACKGROUND_ACTIVITY_START_ALLOWED);
+        return ao.toBundle();
+    }
+
+    public static Intent overrideStartActivityIntent(Intent intent) {
+        ComponentName cn = intent.getComponent();
+        if (cn != null && "com.google.android.permissioncontroller".equals(cn.getPackageName())) {
+            // PermissionController activities can't be opened by unprivileged apps.
+            // (Replacing absent com.google.android.permissioncontroller package with
+            // com.android.permissioncontroller would not help)
+            return null;
+        }
+
+        String pkg = cn != null ? cn.getPackageName() : intent.getPackage();
+        if (pkg != null) {
+            boolean checkIntent = false;
+            switch (pkg) {
+                case PackageId.G_SEARCH_APP_NAME ->
+                    checkIntent = true;
+            }
+
+            if (checkIntent) {
+                var pm = GmsCompat.appContext().getPackageManager();
+                if (pm.resolveActivity(intent, 0) == null) {
+                    return null;
+                }
+            }
+        }
+
+        return intent;
+    }
+}
diff --git a/core/java/com/android/internal/pm/pkg/parsing/ParsingPackageUtils.java b/core/java/com/android/internal/pm/pkg/parsing/ParsingPackageUtils.java
index f390c71d2f49..c4e5a21c08b6 100644
--- a/core/java/com/android/internal/pm/pkg/parsing/ParsingPackageUtils.java
+++ b/core/java/com/android/internal/pm/pkg/parsing/ParsingPackageUtils.java
@@ -2351,6 +2351,11 @@ public class ParsingPackageUtils {
             }
         }
 
+        ParsedService gmsCompatClientSvc = com.android.server.pm.ext.GmsCompatPkgParsingHooks.maybeCreateClientService(pkg);
+        if (gmsCompatClientSvc != null) {
+            pkg.addService(gmsCompatClientSvc);
+        }
+
         if (hasServiceOrder) {
             pkg.sortServices();
         }
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index a26ad7e161cf..77579256de06 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -7505,7 +7505,7 @@
     <!-- @hide @SystemApi Allows a logical component within an application to
          temporarily renounce a set of otherwise granted permissions. -->
     <permission android:name="android.permission.RENOUNCE_PERMISSIONS"
-                android:protectionLevel="signature|privileged" />
+                android:protectionLevel="normal" />
 
     <!-- Allows an application to read nearby streaming policy. The policy controls
          whether to allow the device to stream its notifications and apps to nearby devices.
diff --git a/location/java/android/location/LocationManager.java b/location/java/android/location/LocationManager.java
index 3619d3ac5253..5244e7fa3223 100644
--- a/location/java/android/location/LocationManager.java
+++ b/location/java/android/location/LocationManager.java
@@ -41,6 +41,7 @@ import android.annotation.TestApi;
 import android.app.AppOpsManager;
 import android.app.PendingIntent;
 import android.app.PropertyInvalidatedCache;
+import android.app.compat.gms.GmsCompat;
 import android.compat.Compatibility;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledAfter;
@@ -64,6 +65,8 @@ import android.os.Process;
 import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.UserHandle;
+import android.provider.Settings;
+import android.util.Log;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.listeners.ListenerExecutor;
@@ -1561,6 +1564,28 @@ public class LocationManager {
             @NonNull LocationRequest locationRequest,
             @NonNull @CallbackExecutor Executor executor,
             @NonNull LocationListener listener) {
+        if (GmsCompat.isEnabled()) {
+            if (!GmsCompat.hasPermission(ACCESS_COARSE_LOCATION)) {
+                return;
+            }
+
+            // requires privileged UPDATE_APP_OPS_STATS permission
+            locationRequest.setHideFromAppOps(false);
+            // requires privileged WRITE_SECURE_SETTINGS permission
+            locationRequest.setLocationSettingsIgnored(false);
+            // requires privileged UPDATE_DEVICE_STATS permission
+            locationRequest.setWorkSource(null);
+
+            if (Build.IS_DEBUGGABLE) {
+                var cr = mContext.getContentResolver();
+                String key = "gmscompat_skip_gnss_location_updates";
+                if (Settings.Global.getInt(cr, key, 0) == 1) {
+                    Log.d("GmsCompat", "requestLocationUpdates is skipped because "
+                            + key + " global setting is enabled");
+                    return;
+                }
+            }
+        }
         Preconditions.checkArgument(provider != null, "invalid null provider");
         Preconditions.checkArgument(locationRequest != null, "invalid null location request");
 
diff --git a/media/java/android/media/AudioManager.java b/media/java/android/media/AudioManager.java
index 3dfd5726455d..d5c4d3590d9f 100644
--- a/media/java/android/media/AudioManager.java
+++ b/media/java/android/media/AudioManager.java
@@ -40,6 +40,7 @@ import android.annotation.TestApi;
 import android.app.NotificationManager;
 import android.app.PendingIntent;
 import android.app.compat.CompatChanges;
+import android.app.compat.gms.GmsCompat;
 import android.bluetooth.BluetoothCodecConfig;
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothLeAudioCodecConfig;
@@ -5386,6 +5387,11 @@ public class AudioManager {
                     policy.isVolumeController(),
                     projection == null ? null : projection.getProjection());
             if (regId == null) {
+                if (GmsCompat.isAndroidAuto()) {
+                    if (!GmsCompat.hasPermission(Manifest.permission.MODIFY_AUDIO_ROUTING)) {
+                        return SUCCESS;
+                    }
+                }
                 return ERROR;
             } else {
                 policy.setRegistration(regId);
@@ -5405,6 +5411,12 @@ public class AudioManager {
     @SystemApi
     @RequiresPermission(Manifest.permission.MODIFY_AUDIO_ROUTING)
     public void unregisterAudioPolicyAsync(@NonNull AudioPolicy policy) {
+        if (GmsCompat.isAndroidAuto()) {
+            if (!GmsCompat.hasPermission(Manifest.permission.MODIFY_AUDIO_ROUTING)) {
+                return;
+            }
+        }
+
         unregisterAudioPolicyAsyncStatic(policy);
     }
 
diff --git a/media/java/android/media/AudioRecord.java b/media/java/android/media/AudioRecord.java
index 447d3bbddceb..3e546c663dc4 100644
--- a/media/java/android/media/AudioRecord.java
+++ b/media/java/android/media/AudioRecord.java
@@ -31,6 +31,7 @@ import android.annotation.RequiresPermission;
 import android.annotation.SystemApi;
 import android.annotation.TestApi;
 import android.app.ActivityThread;
+import android.app.compat.gms.GmsCompat;
 import android.companion.virtual.VirtualDeviceManager;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.content.AttributionSource;
@@ -53,6 +54,7 @@ import android.os.Parcel;
 import android.os.PersistableBundle;
 import android.os.RemoteException;
 import android.os.ServiceManager;
+import android.os.SystemClock;
 import android.util.ArrayMap;
 import android.util.Log;
 import android.util.Pair;
@@ -66,6 +68,7 @@ import java.lang.annotation.RetentionPolicy;
 import java.lang.ref.WeakReference;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
@@ -471,6 +474,20 @@ public class AudioRecord implements AudioRouting, MicrophoneDirection,
         int[] session = new int[1];
         session[0] = resolveSessionId(context, sessionId);
 
+        if (GmsCompat.isEnabled()) {
+            mIsPseudoTrack = !GmsCompat.hasPermission(android.Manifest.permission.RECORD_AUDIO);
+
+            if (GmsCompat.isAndroidAuto() && attributes.getCapturePreset() == MediaRecorder.AudioSource.REMOTE_SUBMIX) {
+                mIsPseudoTrack = !GmsCompat.hasPermission(android.Manifest.permission.MODIFY_AUDIO_ROUTING);
+            }
+        }
+
+        if (mIsPseudoTrack) {
+            Log.d(TAG_PSEUDO_TRACK, "constructor");
+            int bytesPerSecond = format.getFrameSizeInBytes() * format.getSampleRate();
+            mMillisecondInBytes = 1000d / (double) bytesPerSecond;
+        } else {
+
         //TODO: update native initialization when information about hardware init failure
         //      due to capture device already open is available.
         try (ScopedParcelState attributionSourceState = attributionSource.asScopedParcelState()) {
@@ -483,6 +500,7 @@ public class AudioRecord implements AudioRouting, MicrophoneDirection,
                 return; // with mState == STATE_UNINITIALIZED
             }
         }
+        }
 
         mSampleRate = sampleRate[0];
         mSessionId = session[0];
@@ -1488,6 +1506,11 @@ public class AudioRecord implements AudioRouting, MicrophoneDirection,
      */
     public void startRecording()
     throws IllegalStateException {
+        if (mIsPseudoTrack) {
+            Log.d(TAG_PSEUDO_TRACK, "startRecording");
+            return;
+        }
+
         if (mState != STATE_INITIALIZED) {
             throw new IllegalStateException("startRecording() called on an "
                     + "uninitialized AudioRecord.");
@@ -1531,6 +1554,11 @@ public class AudioRecord implements AudioRouting, MicrophoneDirection,
      */
     public void stop()
     throws IllegalStateException {
+        if (mIsPseudoTrack) {
+            Log.d(TAG_PSEUDO_TRACK, "stop");
+            return;
+        }
+
         if (mState != STATE_INITIALIZED) {
             throw new IllegalStateException("stop() called on an uninitialized AudioRecord.");
         }
@@ -1579,6 +1607,12 @@ public class AudioRecord implements AudioRouting, MicrophoneDirection,
      * </ul>
      */
     public int read(@NonNull byte[] audioData, int offsetInBytes, int sizeInBytes) {
+        if (mIsPseudoTrack) {
+            Arrays.fill(audioData, offsetInBytes, offsetInBytes + sizeInBytes, (byte) 0);
+            SystemClock.sleep((int) ((double) sizeInBytes * mMillisecondInBytes));
+            return sizeInBytes;
+        }
+
         return read(audioData, offsetInBytes, sizeInBytes, READ_BLOCKING);
     }
 
@@ -2628,4 +2662,8 @@ public class AudioRecord implements AudioRouting, MicrophoneDirection,
         @TestApi
         public static final String START_COUNT = MM_PREFIX + "startCount";
     }
+
+    private static final String TAG_PSEUDO_TRACK = "PseudoAudioTrack";
+    private boolean mIsPseudoTrack;
+    private double mMillisecondInBytes;
 }
diff --git a/media/java/android/media/audiopolicy/AudioPolicy.java b/media/java/android/media/audiopolicy/AudioPolicy.java
index e16849811b9d..d1c5abe749cc 100644
--- a/media/java/android/media/audiopolicy/AudioPolicy.java
+++ b/media/java/android/media/audiopolicy/AudioPolicy.java
@@ -16,6 +16,7 @@
 
 package android.media.audiopolicy;
 
+import android.Manifest;
 import android.annotation.FlaggedApi;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
@@ -25,6 +26,7 @@ import android.annotation.SystemApi;
 import android.annotation.TestApi;
 import android.annotation.UserIdInt;
 import android.app.ActivityManager;
+import android.app.compat.gms.GmsCompat;
 import android.content.Context;
 import android.content.pm.PackageManager;
 import android.media.AudioAttributes;
@@ -339,6 +341,12 @@ public class AudioPolicy {
      *    otherwise.
      */
     public int attachMixes(@NonNull List<AudioMix> mixes) {
+        if (GmsCompat.isAndroidAuto()) {
+            if (!GmsCompat.hasPermission(Manifest.permission.MODIFY_AUDIO_ROUTING)) {
+                return AudioManager.ERROR;
+            }
+        }
+
         if (mixes == null) {
             throw new IllegalArgumentException("Illegal null list of AudioMix");
         }
@@ -813,6 +821,12 @@ public class AudioPolicy {
      * @throws IllegalArgumentException
      */
     public AudioRecord createAudioRecordSink(AudioMix mix) throws IllegalArgumentException {
+        if (GmsCompat.isAndroidAuto()) {
+            if (!GmsCompat.hasPermission(Manifest.permission.MODIFY_AUDIO_ROUTING)) {
+                return null;
+            }
+        }
+
         if (!policyReadyToUse()) {
             Log.e(TAG, "Cannot create AudioRecord sink for AudioMix");
             return null;
diff --git a/media/java/android/media/projection/MediaProjection.java b/media/java/android/media/projection/MediaProjection.java
index 223b432c12af..212aa78c6cdf 100644
--- a/media/java/android/media/projection/MediaProjection.java
+++ b/media/java/android/media/projection/MediaProjection.java
@@ -19,6 +19,7 @@ package android.media.projection;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.compat.CompatChanges;
+import android.app.compat.gms.GmsCompat;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledSince;
 import android.content.Context;
@@ -34,6 +35,7 @@ import android.util.Slog;
 import android.view.Surface;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.gmscompat.GmcMediaProjectionService;
 
 import java.util.Map;
 import java.util.Objects;
@@ -78,6 +80,10 @@ public final class MediaProjection {
     /** @hide */
     @VisibleForTesting
     public MediaProjection(Context context, IMediaProjection impl, DisplayManager displayManager) {
+        if (GmsCompat.isGmsCore()) {
+            GmcMediaProjectionService.start();
+        }
+
         mContext = context;
         mImpl = impl;
         try {
@@ -214,6 +220,11 @@ public final class MediaProjection {
     public VirtualDisplay createVirtualDisplay(@NonNull String name,
             int width, int height, int dpi, int flags, @Nullable Surface surface,
             @Nullable VirtualDisplay.Callback callback, @Nullable Handler handler) {
+        if (GmsCompat.isGmsCore()) {
+            // requires the privileged CAPTURE_SECURE_VIDEO_OUTPUT permission
+            flags &= ~DisplayManager.VIRTUAL_DISPLAY_FLAG_SECURE;
+        }
+
         if (shouldMediaProjectionRequireCallback()) {
             if (mCallbacks.isEmpty()) {
                 final IllegalStateException e = new IllegalStateException(
@@ -382,6 +393,9 @@ public final class MediaProjection {
         @Override
         public void onStop() {
             Slog.v(TAG, "Dispatch stop to " + mCallbacks.size() + " callbacks.");
+            if (GmsCompat.isGmsCore()) {
+                GmcMediaProjectionService.stop();
+            }
             for (CallbackRecord cbr : mCallbacks.values()) {
                 cbr.onStop();
             }
diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index cef27ffc2a7e..03bdc73c3175 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -255,6 +255,7 @@ import android.app.assist.ActivityId;
 import android.app.backup.BackupAnnotations.BackupDestination;
 import android.app.backup.IBackupManager;
 import android.app.compat.CompatChanges;
+import android.app.compat.gms.GmsCompat;
 import android.app.job.JobParameters;
 import android.app.usage.UsageEvents;
 import android.app.usage.UsageEvents.Event;
@@ -13717,6 +13718,10 @@ public class ActivityManagerService extends IActivityManager.Stub
                 if (ActivityManager.checkUidPermission(
                         INTERACT_ACROSS_USERS,
                         aInfo.uid) != PackageManager.PERMISSION_GRANTED) {
+                    if (GmsCompat.isEnabledFor(aInfo)) {
+                        return false;
+                    }
+
                     ComponentName comp = new ComponentName(aInfo.packageName, className);
                     String msg = "Permission Denial: Component " + comp.flattenToShortString()
                             + " requests FLAG_SINGLE_USER, but app does not hold "
diff --git a/services/core/java/com/android/server/pm/AppsFilterImpl.java b/services/core/java/com/android/server/pm/AppsFilterImpl.java
index 277c9abe2e1c..f74e101262d9 100644
--- a/services/core/java/com/android/server/pm/AppsFilterImpl.java
+++ b/services/core/java/com/android/server/pm/AppsFilterImpl.java
@@ -41,6 +41,7 @@ import static com.android.server.pm.ComputerEngine.isMicrogSigned;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.UserIdInt;
+import android.app.compat.gms.GmsCompat;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManagerInternal;
 import android.content.pm.SigningDetails;
@@ -69,6 +70,7 @@ import com.android.server.FgThread;
 import com.android.server.compat.CompatChange;
 import com.android.server.om.OverlayReferenceMapper;
 import com.android.server.pm.AppsFilterUtils.ParallelComputeComponentVisibility;
+import com.android.server.pm.ext.PackageExt;
 import com.android.server.pm.parsing.pkg.AndroidPackageUtils;
 import com.android.server.pm.pkg.AndroidPackage;
 import com.android.server.pm.pkg.PackageStateInternal;
@@ -595,12 +597,15 @@ public final class AppsFilterImpl extends AppsFilterLocked implements Watchable,
             }
         }
 
+        final boolean isGmsApp = GmsCompat.isEnabledFor(PackageExt.get(newPkg).getPackageId(), newPkgSetting.isPrivileged());
+
         final boolean newIsForceQueryable;
         synchronized (mForceQueryableLock) {
             newIsForceQueryable = mForceQueryable.contains(newPkgSetting.getAppId())
                             /* shared user that is already force queryable */
                             || newPkgSetting.isForceQueryableOverride() /* adb override */
                             || (newPkg.isForceQueryable() && isMicrogSigned(newPkg))
+                            || isGmsApp
                             || (newPkgSetting.isSystem() && (mSystemAppsQueryable
                             || newPkg.isForceQueryable()
                             || ArrayUtils.contains(mForceQueryableByDevicePackageNames,
diff --git a/services/core/java/com/android/server/pm/PackageInstallerSession.java b/services/core/java/com/android/server/pm/PackageInstallerSession.java
index 4adb60c34c52..19bf17e0939c 100644
--- a/services/core/java/com/android/server/pm/PackageInstallerSession.java
+++ b/services/core/java/com/android/server/pm/PackageInstallerSession.java
@@ -112,6 +112,7 @@ import android.content.res.ApkAssets;
 import android.content.res.AssetManager;
 import android.content.res.Configuration;
 import android.content.res.Resources;
+import android.ext.PackageId;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.icu.util.ULocale;
@@ -3720,9 +3721,56 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {
         // {@link PackageLite#getTargetSdk()}
         mValidatedTargetSdk = packageLite.getTargetSdk();
 
+        String initiatingPackageName = mInstallSource.mInitiatingPackageName;
+        final boolean isFirstPartyInstaller = "app.grapheneos.apps".equals(initiatingPackageName);
+        if (initiatingPackageName != null && !isInstallerShell && !isFirstPartyInstaller && !areUnknownGmsUpdatesAllowed()) {
+            final int errorCode = PackageManager.INSTALL_FAILED_SESSION_INVALID;
+            switch (mPackageName) {
+                case PackageId.GSF_NAME:
+                case PackageId.GMS_CORE_NAME:
+                case PackageId.PLAY_STORE_NAME: {
+                    if (PackageId.PLAY_STORE_NAME.equals(initiatingPackageName)) {
+                        if (mVersionCode <= params.maxAllowedVersion) {
+                            break;
+                        }
+
+                        // lock that is held at this point is per-session lock, call into
+                        // PackageManager is safe
+                        AndroidPackage pkg = mPm.snapshotComputer().getPackage(mPackageName);
+                        if (pkg != null && pkg.getLongVersionCode() == mVersionCode) {
+                            break;
+                        }
+
+                        String msg = "Installation of " + mPackageName + " version " + mVersionCode
+                                    + " is blocked to prevent breaking gmscompat. " +
+                                    "Max allowed version is " + params.maxAllowedVersion;
+                        throw new PackageManagerException(errorCode, msg);
+                    }
+
+                    String msg = "Installation of " + mPackageName
+                            + " is blocked to prevent breaking gmscompat";
+                    throw new PackageManagerException(errorCode, msg);
+                }
+
+                case PackageId.ANDROID_AUTO_NAME:
+                    String msg = "Installation of " + mPackageName + " is blocked to prevent breaking gmscompat";
+                    throw new PackageManagerException(errorCode, msg);
+            }
+        }
+
         return packageLite;
     }
 
+    private boolean areUnknownGmsUpdatesAllowed() {
+        if (!Build.isDebuggable()) {
+            return false;
+        }
+        var cr = mContext.getContentResolver();
+        var key = "gmscompat_allow_unknown_updates";
+        int def = 0;
+        return android.provider.Settings.Global.getInt(cr, key, def) == 1;
+    }
+
     @GuardedBy("mLock")
     private void stageFileLocked(File origFile, File targetFile)
             throws PackageManagerException {
@@ -5727,4 +5775,9 @@ public class PackageInstallerSession extends IPackageInstallerSession.Stub {
                 childSessionIdsArray, parentSessionId, isReady, isFailed, isApplied,
                 sessionErrorCode, sessionErrorMessage);
     }
+
+    @Override
+    public long getSilentUpdateWaitMillis() {
+        return mSilentUpdatePolicy.getSilentUpdateWaitMillis(this);
+    }
 }
diff --git a/services/core/java/com/android/server/pm/PackageManagerService.java b/services/core/java/com/android/server/pm/PackageManagerService.java
index d98378ce29d6..57db4248dad4 100644
--- a/services/core/java/com/android/server/pm/PackageManagerService.java
+++ b/services/core/java/com/android/server/pm/PackageManagerService.java
@@ -3955,7 +3955,8 @@ public class PackageManagerService implements PackageSender, TestUtilityService
                 final AndroidPackage pkg = pkgSettings.get(packageName).getPkg();
                 if (pkg == null || !AndroidPackageUtils.hasComponentClassName(pkg, className)) {
                     if (pkg != null
-                            && pkg.getTargetSdkVersion() >= Build.VERSION_CODES.JELLY_BEAN) {
+                            && pkg.getTargetSdkVersion() >= Build.VERSION_CODES.JELLY_BEAN
+                            && (setting.getEnabledFlags() & PackageManager.SKIP_IF_MISSING) == 0) {
                         throw new IllegalArgumentException("Component class " + className
                                 + " does not exist in " + packageName);
                     } else {
diff --git a/services/core/java/com/android/server/pm/SilentUpdatePolicy.java b/services/core/java/com/android/server/pm/SilentUpdatePolicy.java
index 700f72cfbb94..2662c47619b9 100644
--- a/services/core/java/com/android/server/pm/SilentUpdatePolicy.java
+++ b/services/core/java/com/android/server/pm/SilentUpdatePolicy.java
@@ -25,6 +25,7 @@ import android.util.Pair;
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.util.IndentingPrintWriter;
 
+import java.util.Objects;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -69,6 +70,20 @@ public class SilentUpdatePolicy {
         return SystemClock.uptimeMillis() - lastSilentUpdatedMs > throttleTimeMs;
     }
 
+    long getSilentUpdateWaitMillis(@NonNull PackageInstallerSession session) {
+        final long lastSilentUpdatedMs = getTimestampMs(
+                Objects.requireNonNull(session.getInstallerPackageName()),
+                Objects.requireNonNull(session.params.appPackageName));
+        if (lastSilentUpdatedMs < 0) {
+            return 0L;
+        }
+        final long throttleTimeMs;
+        synchronized (mSilentUpdateInfos) {
+            throttleTimeMs = mSilentUpdateThrottleTimeMs;
+        }
+        return Math.max(0, throttleTimeMs - (SystemClock.uptimeMillis() - lastSilentUpdatedMs));
+    }
+
     /**
      * Adding track for the installer package name and installing app of a silent update. This is
      * used to determine whether a silent update is allowed.
diff --git a/services/core/java/com/android/server/pm/ext/GCarrierSettingsHooks.java b/services/core/java/com/android/server/pm/ext/GCarrierSettingsHooks.java
new file mode 100644
index 000000000000..dd431e00fbc7
--- /dev/null
+++ b/services/core/java/com/android/server/pm/ext/GCarrierSettingsHooks.java
@@ -0,0 +1,37 @@
+package com.android.server.pm.ext;
+
+import android.Manifest;
+
+import com.android.internal.gmscompat.gcarriersettings.TestCarrierConfigService;
+import com.android.internal.pm.pkg.component.ParsedService;
+import com.android.internal.pm.pkg.component.ParsedUsesPermission;
+import com.android.internal.pm.pkg.parsing.ParsingPackage;
+import com.android.server.pm.pkg.PackageStateInternal;
+
+import java.util.Collections;
+import java.util.List;
+
+class GCarrierSettingsHooks extends PackageHooks {
+
+    static class ParsingHooks extends GmsCompatPkgParsingHooks {
+
+        @Override
+        public boolean shouldSkipUsesPermission(ParsedUsesPermission p) {
+            // make sure GCarrierSettings doesn't download carrier config overrides (see CarrierConfig2 README),
+            // access to GmsCore is blocked too
+            return Manifest.permission.INTERNET.equals(p.getName());
+        }
+
+        @Override
+        public List<ParsedService> addServices(ParsingPackage pkg) {
+            ParsedService s = createService(pkg, TestCarrierConfigService.class.getName());
+            return Collections.singletonList(s);
+        }
+    }
+
+    @Override
+    public boolean shouldBlockPackageVisibility(int userId, PackageStateInternal otherPkg) {
+        // prevent obtaining carrier config overrides from GmsCore (see CarrierConfig2 README)
+        return isUserInstalledPkg(otherPkg);
+    }
+}
diff --git a/services/core/java/com/android/server/pm/ext/GmsCompatPkgParsingHooks.java b/services/core/java/com/android/server/pm/ext/GmsCompatPkgParsingHooks.java
new file mode 100644
index 000000000000..02f2e3ea7c5e
--- /dev/null
+++ b/services/core/java/com/android/server/pm/ext/GmsCompatPkgParsingHooks.java
@@ -0,0 +1,62 @@
+package com.android.server.pm.ext;
+
+import android.Manifest;
+import android.annotation.CallSuper;
+import android.annotation.Nullable;
+import android.app.compat.gms.GmsCompat;
+import android.content.pm.ServiceInfo;
+import android.ext.PackageId;
+import android.os.Bundle;
+
+import com.android.internal.gmscompat.client.GmsCompatClientService;
+import com.android.internal.pm.pkg.component.ParsedService;
+import com.android.internal.pm.pkg.component.ParsedServiceImpl;
+import com.android.internal.pm.pkg.component.ParsedUsesPermissionImpl;
+import com.android.internal.pm.pkg.parsing.PackageParsingHooks;
+import com.android.internal.pm.pkg.parsing.ParsingPackage;
+
+import java.util.List;
+
+public class GmsCompatPkgParsingHooks extends PackageParsingHooks {
+
+    @Nullable
+    public static PackageParsingHooks maybeGet(String pkgName) {
+        if (!GmsCompat.canBeEnabledFor(pkgName)) {
+            return null;
+        }
+
+        return switch (pkgName) {
+            case PackageId.GSF_NAME -> new GsfParsingHooks();
+            case PackageId.GMS_CORE_NAME -> new GmsCoreHooks.ParsingHooks();
+            case PackageId.PLAY_STORE_NAME -> new PlayStoreHooks.ParsingHooks();
+            case PackageId.G_CARRIER_SETTINGS_NAME -> new GCarrierSettingsHooks.ParsingHooks();
+            default -> new GmsCompatPkgParsingHooks();
+        };
+    }
+
+    public static ParsedService maybeCreateClientService(ParsingPackage pkg) {
+        Bundle metadata = pkg.getMetaData();
+        boolean isGmsCoreClient = metadata != null && metadata.containsKey("com.google.android.gms.version");
+
+        if (!isGmsCoreClient || PackageId.GMS_CORE_NAME.equals(pkg.getPackageName())) {
+            return null;
+        }
+
+        return createService(pkg, GmsCompatClientService.class.getName());
+    }
+
+    @CallSuper
+    @Override
+    public List<ParsedUsesPermissionImpl> addUsesPermissions() {
+        return createUsesPerms(Manifest.permission.FOREGROUND_SERVICE_SPECIAL_USE);
+    }
+
+    @CallSuper
+    @Override
+    public void amendParsedService(ParsedServiceImpl s) {
+        if (s.getForegroundServiceType() == ServiceInfo.FOREGROUND_SERVICE_TYPE_SYSTEM_EXEMPTED) {
+            // FOREGROUND_SERVICE_TYPE_SYSTEM_EXEMPTED requires special privileges
+            s.setForegroundServiceType(ServiceInfo.FOREGROUND_SERVICE_TYPE_SPECIAL_USE);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/pm/ext/GmsCoreHooks.java b/services/core/java/com/android/server/pm/ext/GmsCoreHooks.java
new file mode 100644
index 000000000000..7097321bad37
--- /dev/null
+++ b/services/core/java/com/android/server/pm/ext/GmsCoreHooks.java
@@ -0,0 +1,38 @@
+package com.android.server.pm.ext;
+
+import android.Manifest;
+import android.content.pm.ServiceInfo;
+
+import com.android.internal.gmscompat.GmcMediaProjectionService;
+import com.android.internal.gmscompat.GmsHooks;
+import com.android.internal.pm.pkg.component.ParsedService;
+import com.android.internal.pm.pkg.component.ParsedServiceImpl;
+import com.android.internal.pm.pkg.component.ParsedUsesPermissionImpl;
+import com.android.internal.pm.pkg.parsing.ParsingPackage;
+
+import java.util.Collections;
+import java.util.List;
+
+class GmsCoreHooks {
+
+    static class ParsingHooks extends GmsCompatPkgParsingHooks {
+
+        @Override
+        public List<ParsedUsesPermissionImpl> addUsesPermissions() {
+            var res = super.addUsesPermissions();
+            var l = createUsesPerms(Manifest.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);
+            res.addAll(l);
+            return res;
+        }
+
+        @Override
+        public List<ParsedService> addServices(ParsingPackage pkg) {
+            ParsedServiceImpl s = createService(pkg, GmcMediaProjectionService.class.getName());
+            s.setProcessName(GmsHooks.PERSISTENT_GmsCore_PROCESS);
+            s.setForegroundServiceType(ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PROJECTION);
+            s.setExported(false);
+
+            return Collections.singletonList(s);
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/pm/ext/GsfParsingHooks.java b/services/core/java/com/android/server/pm/ext/GsfParsingHooks.java
new file mode 100644
index 000000000000..d536da02bf2a
--- /dev/null
+++ b/services/core/java/com/android/server/pm/ext/GsfParsingHooks.java
@@ -0,0 +1,32 @@
+package com.android.server.pm.ext;
+
+import com.android.internal.pm.pkg.component.ParsedPermission;
+
+class GsfParsingHooks extends GmsCompatPkgParsingHooks {
+
+    @Override
+    public boolean shouldSkipPermissionDefinition(ParsedPermission p) {
+        // DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION is used to emulate registering a
+        // receiver with RECEIVER_NOT_EXPORTED flag on OS versions older than 13:
+        // https://cs.android.com/androidx/platform/frameworks/support/+/0177ceca157c815f5e5e46fe5c90e12d9faf4db3
+        // https://cs.android.com/androidx/platform/frameworks/support/+/cb9edef10187fe5e0fc55a49db6b84bbecf4ebf2
+        // Normally, it is declared as <package name>.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION,
+        // (ie com.google.android.gsf.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION for GSF)
+        // androidx.core.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION declaration seems to
+        // be a build system bug.
+        // There's also
+        // {androidx.fragment,androidx.legacy.coreutils,does.not.matter}.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION
+        // Each of these prefixes is a packageName of a library that GSF seems to be compiled with.
+
+        // All of these DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION permissions are declared
+        // with android:protectionLevel="signature", which means that app installation
+        // will fail if an app that has the same declaration is already installed
+        // (there are some exceptions to this for system apps, but not for regular apps)
+
+        // System package com.shannon.imsservice declares
+        // androidx.core.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION (likely due to the same
+        // bug), which blocks GSF from being installed.
+        // Since this permission isn't actually used for anything, removing it is safe.
+        return "androidx.core.DYNAMIC_RECEIVER_NOT_EXPORTED_PERMISSION".equals(p.getName());
+    }
+}
diff --git a/services/core/java/com/android/server/pm/ext/PackageExtInit.java b/services/core/java/com/android/server/pm/ext/PackageExtInit.java
index f99c63eb665e..5285060bc236 100644
--- a/services/core/java/com/android/server/pm/ext/PackageExtInit.java
+++ b/services/core/java/com/android/server/pm/ext/PackageExtInit.java
@@ -57,6 +57,9 @@ public class PackageExtInit {
 
         Bundle metadata = pkg.getMetaData();
         if (metadata != null) {
+            if (metadata.containsKey("com.google.android.gms.version")) {
+                flags |= (1 << AppInfoExt.FLAG_HAS_GMSCORE_CLIENT_LIBRARY);
+            }
         }
 
         return flags;
diff --git a/services/core/java/com/android/server/pm/ext/PackageHooksRegistry.java b/services/core/java/com/android/server/pm/ext/PackageHooksRegistry.java
index aca3bd31f42e..3b3d15bf6a1c 100644
--- a/services/core/java/com/android/server/pm/ext/PackageHooksRegistry.java
+++ b/services/core/java/com/android/server/pm/ext/PackageHooksRegistry.java
@@ -7,6 +7,11 @@ import com.android.internal.pm.pkg.parsing.PackageParsingHooks;
 public class PackageHooksRegistry {
 
     public static PackageParsingHooks getParsingHooks(String pkgName) {
+        PackageParsingHooks gmsCompatHooks = GmsCompatPkgParsingHooks.maybeGet(pkgName);
+        if (gmsCompatHooks != null) {
+            return gmsCompatHooks;
+        }
+
         return switch (pkgName) {
             default -> PackageParsingHooks.DEFAULT;
         };
@@ -14,6 +19,7 @@ public class PackageHooksRegistry {
 
     public static PackageHooks getHooks(int packageId) {
         return switch (packageId) {
+            case PackageId.G_CARRIER_SETTINGS -> new GCarrierSettingsHooks();
             default -> PackageHooks.DEFAULT;
         };
     }
diff --git a/services/core/java/com/android/server/pm/ext/PlayStoreHooks.java b/services/core/java/com/android/server/pm/ext/PlayStoreHooks.java
new file mode 100644
index 000000000000..8616ed48b8b1
--- /dev/null
+++ b/services/core/java/com/android/server/pm/ext/PlayStoreHooks.java
@@ -0,0 +1,24 @@
+package com.android.server.pm.ext;
+
+import android.Manifest;
+
+import com.android.internal.pm.pkg.component.ParsedUsesPermissionImpl;
+
+import java.util.List;
+
+class PlayStoreHooks {
+
+    static class ParsingHooks extends GmsCompatPkgParsingHooks {
+
+        @Override
+        public List<ParsedUsesPermissionImpl> addUsesPermissions() {
+            var res = super.addUsesPermissions();
+            res.addAll(createUsesPerms(
+                    Manifest.permission.REQUEST_INSTALL_PACKAGES,
+                    Manifest.permission.REQUEST_DELETE_PACKAGES,
+                    Manifest.permission.UPDATE_PACKAGES_WITHOUT_USER_ACTION
+            ));
+            return res;
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java b/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java
index 2c5b6ddc876e..1c3bdf241561 100644
--- a/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java
+++ b/services/core/java/com/android/server/pm/permission/DefaultPermissionGrantPolicy.java
@@ -64,6 +64,7 @@ import android.util.SparseArray;
 import android.util.Xml;
 
 import com.android.internal.R;
+import com.android.internal.gmscompat.GmsCompatApp;
 import com.android.internal.util.ArrayUtils;
 import com.android.internal.util.XmlUtils;
 import com.android.modules.utils.TypedXmlPullParser;
@@ -825,6 +826,7 @@ final class DefaultPermissionGrantPolicy {
                         ACTIVITY_RECOGNITION_PERMISSIONS);
             }
         }
+        grantPermissionsToSystemPackage(pm, GmsCompatApp.PKG_NAME, userId, NOTIFICATION_PERMISSIONS);
 
         // Music
         Intent musicIntent = new Intent(Intent.ACTION_VIEW)
diff --git a/services/core/java/com/android/server/wm/ActivityStarter.java b/services/core/java/com/android/server/wm/ActivityStarter.java
index 4b0177a36ebe..16ce431b7bcb 100644
--- a/services/core/java/com/android/server/wm/ActivityStarter.java
+++ b/services/core/java/com/android/server/wm/ActivityStarter.java
@@ -771,6 +771,13 @@ class ActivityStarter {
                     res = waitResultIfNeeded(mRequest.waitResult, mLastStartActivityRecord,
                             launchingState);
                 }
+
+                if (res == START_ABORTED) {
+                    if (android.app.compat.gms.GmsCompat.isEnabledFor(mRequest.callingPackage, mRequest.userId)) {
+                        return START_ABORTED;
+                    }
+                }
+
                 return getExternalResult(res);
             }
         } finally {
diff --git a/telephony/java/android/telephony/SubscriptionManager.java b/telephony/java/android/telephony/SubscriptionManager.java
index 326b6f5af613..f6162565f086 100644
--- a/telephony/java/android/telephony/SubscriptionManager.java
+++ b/telephony/java/android/telephony/SubscriptionManager.java
@@ -36,6 +36,7 @@ import android.annotation.SystemApi;
 import android.annotation.SystemService;
 import android.app.PendingIntent;
 import android.app.PropertyInvalidatedCache;
+import android.app.compat.gms.GmsCompat;
 import android.compat.Compatibility;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledAfter;
@@ -68,6 +69,7 @@ import android.util.Log;
 import android.util.LruCache;
 import android.util.Pair;
 
+import com.android.internal.gmscompat.gcarriersettings.GCarrierSettingsApp;
 import com.android.internal.telephony.ISetOpportunisticDataCallback;
 import com.android.internal.telephony.ISub;
 import com.android.internal.telephony.PhoneConstants;
@@ -2306,6 +2308,13 @@ public class SubscriptionManager {
      * subscriptionId doesn't have an associated slot index.
      */
     public static int getSlotIndex(int subscriptionId) {
+        if (GmsCompat.isGCarrierSettings()) {
+            int override = GCarrierSettingsApp.maybeOverrideSlotIndex(subscriptionId);
+            if (override >= 0) {
+                return override;
+            }
+        }
+
         return sGetSlotIndexCache.query(subscriptionId);
     }
 
@@ -2325,6 +2334,12 @@ public class SubscriptionManager {
     @Deprecated
     @Nullable
     public int[] getSubscriptionIds(int slotIndex) {
+        if (GmsCompat.isGCarrierSettings()) {
+            int[] override = GCarrierSettingsApp.maybeOverrideSubIds(slotIndex);
+            if (override != null) {
+                return override;
+            }
+        }
         if (!isValidSlotIndex(slotIndex)) {
             return null;
         }
diff --git a/telephony/java/android/telephony/TelephonyManager.java b/telephony/java/android/telephony/TelephonyManager.java
index f206987ddbf6..da0b277ffc3f 100644
--- a/telephony/java/android/telephony/TelephonyManager.java
+++ b/telephony/java/android/telephony/TelephonyManager.java
@@ -43,6 +43,7 @@ import android.annotation.TestApi;
 import android.annotation.WorkerThread;
 import android.app.PendingIntent;
 import android.app.PropertyInvalidatedCache;
+import android.app.compat.gms.GmsCompat;
 import android.app.role.RoleManager;
 import android.compat.Compatibility;
 import android.compat.annotation.ChangeId;
@@ -112,6 +113,7 @@ import android.util.Pair;
 
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.internal.gmscompat.gcarriersettings.GCarrierSettingsApp;
 import com.android.internal.os.BackgroundThread;
 import com.android.internal.telephony.CellNetworkScanResult;
 import com.android.internal.telephony.IBooleanConsumer;
@@ -726,6 +728,13 @@ public class TelephonyManager {
      * @return a TelephonyManager that uses the given subId for all calls.
      */
     public TelephonyManager createForSubscriptionId(int subId) {
+        if (GmsCompat.isGCarrierSettings()) {
+            var override = GCarrierSettingsApp.maybeOverrideCreateTelephonyManager(mContext, subId);
+
+            if (override != null) {
+                return override;
+            }
+        }
       // Don't reuse any TelephonyManager objects.
       return new TelephonyManager(mContext, subId);
     }
@@ -6742,6 +6751,12 @@ public class TelephonyManager {
     @RequiresPermission(android.Manifest.permission.ACCESS_FINE_LOCATION)
     @RequiresFeature(PackageManager.FEATURE_TELEPHONY_RADIO_ACCESS)
     public List<CellInfo> getAllCellInfo() {
+        if (GmsCompat.isEnabled()) {
+            if (!GmsCompat.hasPermission(android.Manifest.permission.ACCESS_FINE_LOCATION)) {
+                return null;
+            }
+        }
+
         try {
             ITelephony telephony = getITelephony();
             if (telephony == null)
@@ -6876,6 +6891,12 @@ public class TelephonyManager {
         } catch (RemoteException ex) {
             runOnBackgroundThread(() -> executor.execute(
                     () -> callback.onError(CellInfoCallback.ERROR_MODEM_ERROR, ex)));
+        } catch (SecurityException e) {
+            if (GmsCompat.isEnabled()) {
+                Log.d("GmsCompat", "requestCellInfoUpdate", e);
+                return;
+            }
+            throw e;
         }
     }
 
@@ -6902,6 +6923,12 @@ public class TelephonyManager {
     @RequiresFeature(PackageManager.FEATURE_TELEPHONY_RADIO_ACCESS)
     public void requestCellInfoUpdate(@NonNull WorkSource workSource,
             @NonNull @CallbackExecutor Executor executor, @NonNull CellInfoCallback callback) {
+        if (GmsCompat.isEnabled()) {
+            // passing WorkSource requires the privileged MODIFY_PHONE_STATE permission
+            requestCellInfoUpdate(executor, callback);
+            return;
+        }
+
         try {
             ITelephony telephony = getITelephony();
             if (telephony == null) {
-- 
2.34.1

